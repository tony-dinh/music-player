/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _promise = __webpack_require__(1);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _events = __webpack_require__(66);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _request = __webpack_require__(67);
	
	var _request2 = _interopRequireDefault(_request);
	
	var _utils = __webpack_require__(70);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _socket = __webpack_require__(71);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _navBar = __webpack_require__(127);
	
	var _playlistSelector = __webpack_require__(129);
	
	var _userSelector = __webpack_require__(130);
	
	var _library = __webpack_require__(131);
	
	var _library2 = _interopRequireDefault(_library);
	
	var _playlists = __webpack_require__(132);
	
	var _playlists2 = _interopRequireDefault(_playlists);
	
	var _search = __webpack_require__(200);
	
	var _search2 = _interopRequireDefault(_search);
	
	var _login = __webpack_require__(201);
	
	var _login2 = _interopRequireDefault(_login);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// UI
	var _initialState = function _initialState() {
	    var isLoginPage = /^\/login$/.test(location.pathname);
	    var hiddenClass = 'u-hidden';
	    var $loginPage = $('#login-page');
	    var $playlistApp = $('#playlist-app');
	
	    if (isLoginPage) {
	        $loginPage.removeClass(hiddenClass);
	        $playlistApp.addClass(hiddenClass);
	    } else {
	        $playlistApp.removeClass(hiddenClass);
	        $loginPage.addClass(hiddenClass);
	    }
	};
	
	// Components
	// Global
	
	
	var _bindEvents = function _bindEvents() {
	    var $body = $('body');
	    $body.on(_events2.default.names.PLAYLISTS_UPDATE_NEEDED, function () {
	        _request2.default.getMusicData('playlists').then(function (playlists) {
	            window.PLAYLISTS = playlists;
	            $body.trigger(_events2.default.names.PLAYLISTS_UPDATED);
	            $body.trigger(_events2.default.names.PLAYLIST_SELECTOR_UPDATE_NEEDED);
	        });
	    });
	};
	
	var loadMusic = function loadMusic() {
	    return _promise2.default.all([_request2.default.getMusicData('playlists'), _request2.default.getMusicData('songs')]).then(function (musicData) {
	        var $body = $('body');
	        window.PLAYLISTS = musicData[0];
	        window.SONGS = musicData[1];
	        $body.trigger(_events2.default.names.SONGS_UPDATED);
	        $body.trigger(_events2.default.names.PLAYLISTS_UPDATED);
	        $body.trigger(_events2.default.names.PLAYLIST_SELECTOR_UPDATE_NEEDED);
	    });
	};
	
	var App = function App() {
	    window.UTILS = _utils2.default;
	    _bindEvents();
	
	    // Load UI components / bind events
	    (0, _navBar.NavBarUI)();
	    (0, _login2.default)();
	    (0, _library2.default)();
	    (0, _playlists2.default)();
	    (0, _search2.default)();
	    (0, _playlistSelector.PlaylistSelectorUI)();
	    (0, _userSelector.UserSelectorUI)();
	    _initialState();
	
	    loadMusic();
	};
	
	App();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(2), __esModule: true };

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(4);
	__webpack_require__(48);
	__webpack_require__(52);
	module.exports = __webpack_require__(12).Promise;

/***/ },
/* 3 */
/***/ function(module, exports) {



/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(5)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(8)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(6)
	  , defined   = __webpack_require__(7);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 6 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 7 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(9)
	  , $export        = __webpack_require__(10)
	  , redefine       = __webpack_require__(25)
	  , hide           = __webpack_require__(15)
	  , has            = __webpack_require__(26)
	  , Iterators      = __webpack_require__(27)
	  , $iterCreate    = __webpack_require__(28)
	  , setToStringTag = __webpack_require__(44)
	  , getPrototypeOf = __webpack_require__(46)
	  , ITERATOR       = __webpack_require__(45)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(11)
	  , core      = __webpack_require__(12)
	  , ctx       = __webpack_require__(13)
	  , hide      = __webpack_require__(15)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 11 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 12 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(14);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(16)
	  , createDesc = __webpack_require__(24);
	module.exports = __webpack_require__(20) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(17)
	  , IE8_DOM_DEFINE = __webpack_require__(19)
	  , toPrimitive    = __webpack_require__(23)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(20) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(18);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(20) && !__webpack_require__(21)(function(){
	  return Object.defineProperty(__webpack_require__(22)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(21)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(18)
	  , document = __webpack_require__(11).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(18);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(15);

/***/ },
/* 26 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(29)
	  , descriptor     = __webpack_require__(24)
	  , setToStringTag = __webpack_require__(44)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(15)(IteratorPrototype, __webpack_require__(45)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(17)
	  , dPs         = __webpack_require__(30)
	  , enumBugKeys = __webpack_require__(42)
	  , IE_PROTO    = __webpack_require__(39)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(22)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(43).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(16)
	  , anObject = __webpack_require__(17)
	  , getKeys  = __webpack_require__(31);
	
	module.exports = __webpack_require__(20) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(32)
	  , enumBugKeys = __webpack_require__(42);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(26)
	  , toIObject    = __webpack_require__(33)
	  , arrayIndexOf = __webpack_require__(36)(false)
	  , IE_PROTO     = __webpack_require__(39)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(34)
	  , defined = __webpack_require__(7);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(35);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(33)
	  , toLength  = __webpack_require__(37)
	  , toIndex   = __webpack_require__(38);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(6)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(6)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(40)('keys')
	  , uid    = __webpack_require__(41);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11).document && document.documentElement;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(16).f
	  , has = __webpack_require__(26)
	  , TAG = __webpack_require__(45)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(40)('wks')
	  , uid        = __webpack_require__(41)
	  , Symbol     = __webpack_require__(11).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(26)
	  , toObject    = __webpack_require__(47)
	  , IE_PROTO    = __webpack_require__(39)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(7);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(49);
	var global        = __webpack_require__(11)
	  , hide          = __webpack_require__(15)
	  , Iterators     = __webpack_require__(27)
	  , TO_STRING_TAG = __webpack_require__(45)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(50)
	  , step             = __webpack_require__(51)
	  , Iterators        = __webpack_require__(27)
	  , toIObject        = __webpack_require__(33);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(8)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(9)
	  , global             = __webpack_require__(11)
	  , ctx                = __webpack_require__(13)
	  , classof            = __webpack_require__(53)
	  , $export            = __webpack_require__(10)
	  , isObject           = __webpack_require__(18)
	  , aFunction          = __webpack_require__(14)
	  , anInstance         = __webpack_require__(54)
	  , forOf              = __webpack_require__(55)
	  , speciesConstructor = __webpack_require__(59)
	  , task               = __webpack_require__(60).set
	  , microtask          = __webpack_require__(62)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(45)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(63)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(44)($Promise, PROMISE);
	__webpack_require__(64)(PROMISE);
	Wrapper = __webpack_require__(12)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(65)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(35)
	  , TAG = __webpack_require__(45)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(13)
	  , call        = __webpack_require__(56)
	  , isArrayIter = __webpack_require__(57)
	  , anObject    = __webpack_require__(17)
	  , toLength    = __webpack_require__(37)
	  , getIterFn   = __webpack_require__(58)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(17);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(27)
	  , ITERATOR   = __webpack_require__(45)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(53)
	  , ITERATOR  = __webpack_require__(45)('iterator')
	  , Iterators = __webpack_require__(27);
	module.exports = __webpack_require__(12).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(17)
	  , aFunction = __webpack_require__(14)
	  , SPECIES   = __webpack_require__(45)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(13)
	  , invoke             = __webpack_require__(61)
	  , html               = __webpack_require__(43)
	  , cel                = __webpack_require__(22)
	  , global             = __webpack_require__(11)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(35)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 61 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(11)
	  , macrotask = __webpack_require__(60).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(35)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(15);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(11)
	  , core        = __webpack_require__(12)
	  , dP          = __webpack_require__(16)
	  , DESCRIPTORS = __webpack_require__(20)
	  , SPECIES     = __webpack_require__(45)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(45)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 66 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var Events = {};
	var $body = $('body');
	
	Events.names = {
	    MUSIC_LOADED: '@@music/LOADED',
	    PLAYLISTS_UPDATE_NEEDED: '@@playlists/UPDATE_NEEDED',
	    PLAYLIST_SELECTOR_UPDATE_NEEDED: '@@playlist-selector/UPDATE_NEEDED',
	    PLAYLISTS_UPDATED: '@@playlists/UPDATED',
	    PLAYLIST_ADDED: '@@playlist/ADDED',
	    PLAYLIST_SONG_ADDED: '@@playlist/SONG_ADDED',
	    PLAYLIST_SONG_DELETED: '@@playlist/SONG_DELETED',
	    SIGNED_IN: '@@user/SIGNED_IN',
	    SONGS_UPDATED: '@@songs/UPDATED'
	};
	
	Events.trigger = function (event, payload) {
	    $body.trigger(event, payload);
	};
	
	exports.default = Events;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(68);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _promise = __webpack_require__(1);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Request = {};
	
	Request.getMusicData = function (key) {
	    return new _promise2.default(function (resolve, reject) {
	        $.get('/api/' + key, function (data, status, xhr) {
	            if (xhr.status !== 200) {
	                console.error('Failed to retrieve ' + key);
	                reject();
	            }
	            resolve(data[key]);
	        });
	    });
	};
	
	Request.getUsers = function () {
	    return new _promise2.default(function (resolve, reject) {
	        $.get('/api/users', function (data, status, xhr) {
	            if (xhr.status !== 200) {
	                console.error('Failed to retrieve ' + key);
	                reject();
	            }
	            resolve(data.users);
	        });
	    });
	};
	
	Request.addNewPlaylist = function (playlist) {
	    return new _promise2.default(function (resolve, reject) {
	        $.post('/api/playlists/', playlist, function (data, status, xhr) {
	            if (xhr.status !== 200) {
	                reject('[ Request ] Failed to add new playlist: ' + status);
	            }
	            resolve(data);
	        }, 'json');
	    });
	};
	
	Request.addSongToPlaylist = function (songId, playlistId) {
	    return new _promise2.default(function (resolve, reject) {
	        $.ajax({
	            url: 'api/playlists/' + playlistId,
	            contentType: 'application/json',
	            type: 'POST',
	            data: (0, _stringify2.default)({ song: songId }),
	            success: function success(data, status, xhr) {
	                if (xhr.status !== 200) {
	                    reject('[ Request ] Failed to add song to playlist: ' + status);
	                }
	                resolve();
	            },
	            error: function error() {
	                reject('[ Request ] Failed to add song to playlist: ' + status);
	            }
	        });
	    });
	};
	
	Request.removeSongFromPlaylist = function (songId, playlistId) {
	    return new _promise2.default(function (resolve, reject) {
	        $.ajax({
	            url: '/playlists/' + playlistId,
	            contentType: 'application/json',
	            type: 'DELETE',
	            data: (0, _stringify2.default)({ song: songId }),
	            success: function success(data, status, xhr) {
	                if (xhr.status !== 200) {
	                    reject('[ Request ] Failed to remove song from playlist: ' + status);
	                }
	                resolve();
	            }
	        });
	    });
	};
	
	Request.submitLogin = function (data) {
	    return new _promise2.default(function (resolve, reject) {
	        $.ajax({
	            url: '/login',
	            contentType: 'application/json',
	            type: 'POST',
	            data: (0, _stringify2.default)(data),
	            success: function success(data, status, xhr) {
	                if (xhr.status !== 200) {
	                    reject('[ Request ] Login Failed');
	                }
	                resolve(data);
	            },
	            error: function error() {
	                reject('[ Request ] Login Failed');
	            }
	
	        });
	    });
	};
	
	Request.grantUserPlaylistPermission = function (_ref) {
	    var userId = _ref.userId,
	        playlistId = _ref.playlistId;
	
	    return new _promise2.default(function (resolve, reject) {
	        $.ajax({
	            url: '/api/playlists/' + playlistId + '/users',
	            contentType: 'application/json',
	            type: 'POST',
	            data: (0, _stringify2.default)({ user: userId }),
	            success: function success(data, status, xhr) {
	                if (xhr.status !== 200) {
	                    reject('[ Request ] Failed to grant permission');
	                }
	                resolve(data);
	            },
	            error: function error() {
	                reject('[ Request ] Failed to grant permission');
	            }
	
	        });
	    });
	};
	
	exports.default = Request;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(69), __esModule: true };

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(12)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },
/* 70 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var Utils = {};
	
	Utils.getObjWithId = function (arr, id) {
	    if (!arr || arr.length === 0) {
	        return undefined;
	    }
	    var objId = parseInt(id);
	    var matches = arr.filter(function (obj) {
	        return obj.id === objId;
	    });
	
	    return matches.length > 0 ? matches[0] : undefined;
	};
	
	Utils.songElementFor = function (songObj) {
	    var songElClass = 'c-table-grid__item c-library__item';
	    var songElHTML = '<div class="c-library__item-content c-table-grid__item-content"><img class="c-library__item-art" src="assets/song-art-200.jpg" alt="Album Art"><div class="c-library__item-text u-flex-col u--middle"><h4> ' + songObj.title + ' </h4><h5> ' + songObj.artist + ' </h5></div><div class="c-library__item-disclosure"><button type="button" name="Play" class="js-play c-button c--disclosure glyphicon glyphicon-play"></button><button type="button" name="Add To Playlist" class="js-add-to-playlist c-button c--disclosure glyphicon glyphicon-plus-sign"></button><button type="button" name="Remove from Playlist" class="js-remove-from-playlist c-remove-from-playlist c-button c--disclosure glyphicon glyphicon-remove"></button></div></div>';
	
	    return $('<div></div>').addClass(songElClass).attr('data-id', songObj.id).html(songElHTML);
	};
	
	Utils.playlistElementFor = function (playlistObj) {
	    var playlistElClass = 'c-table-grid__item c-playlist__item';
	    var playlistElHTML = '<div class="c-playlist__item-content c-table-grid__item-content"><img class="c-playlist__item-art" src="assets/playlist-art-200.jpg" alt="Playlist Art"><div class="c-playlist__item-text u-flex-col u--middle"><h4> ' + playlistObj.name + ' </h4></div><div class="c-playlist__item-disclosure"><span class="glyphicon glyphicon-chevron-right"></span></div></div>';
	
	    return $('<div></div>').addClass(playlistElClass).attr('data-id', playlistObj.id).html(playlistElHTML);
	};
	
	Utils.addSongToPlaylist = function (songId, playlistObj) {
	    var songIdInt = parseInt(songId);
	    if (!!playlistObj && !playlistObj.songs.includes(songIdInt)) {
	        playlistObj.songs.push(songIdInt);
	        return true;
	    }
	    return false;
	};
	
	Utils.removeSongFromPlaylist = function (songId, playlistObj) {
	    var songIdInt = parseInt(songId);
	    if (!playlistObj.songs.includes(songId)) {
	        return;
	    }
	
	    playlistObj.songs = playlistObj.songs.filter(function (currentSongId) {
	        return currentSongId !== songIdInt;
	    });
	};
	
	exports.default = Utils;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _socket = __webpack_require__(72);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _events = __webpack_require__(66);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Socket = {};
	
	Socket.events = {
	    PLAYLIST_SONG_ADDED: '@@playlist/SONG_ADDED',
	    PLAYLIST_SONG_DELETED: '@@playlist/SONG_DELETED'
	};
	
	Socket.log = function (message) {
	    console.log('[ SOCKET ] ' + message);
	};
	
	Socket.connect = function () {
	    var _this = this;
	
	    this.socket = _socket2.default.connect('/');
	    this.socket.on('connect', function () {
	        return _this.log('Connected.');
	    });
	    this.socket.on('event', _socketEventHandler);
	};
	
	var _socketEventHandler = function _socketEventHandler(data) {
	    var jsonData = JSON.parse(data);
	    var playlistObj = jsonData.playlist ? UTILS.getObjWithId(PLAYLISTS, jsonData.playlist) : null;
	
	    Socket.log(jsonData.event + ' triggered.');
	
	    switch (jsonData.event) {
	        case Socket.events.PLAYLIST_SONG_ADDED:
	            if (!UTILS.addSongToPlaylist(jsonData.song, playlistObj)) return;
	            _events2.default.trigger(_events2.default.names.PLAYLIST_SONG_ADDED, { playlistId: jsonData.playlist, songId: jsonData.song });
	            return;
	
	        case Socket.events.PLAYLIST_SONG_DELETED:
	            UTILS.removeSongFromPlaylist(jsonData.song, playlistObj);
	            _events2.default.trigger(_events2.default.names.PLAYLIST_SONG_DELETED, { playlistId: jsonData.playlist, songId: jsonData.song });
	            return;
	
	        default:
	            break;
	    }
	};
	
	exports.default = Socket;

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(73);
	var parser = __webpack_require__(79);
	var Manager = __webpack_require__(90);
	var debug = __webpack_require__(75)('socket.io-client');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = lookup;
	
	/**
	 * Managers cache.
	 */
	
	var cache = exports.managers = {};
	
	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */
	
	function lookup (uri, opts) {
	  if (typeof uri === 'object') {
	    opts = uri;
	    uri = undefined;
	  }
	
	  opts = opts || {};
	
	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] ||
	                      false === opts.multiplex || sameNamespace;
	
	  var io;
	
	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	  if (parsed.query && !opts.query) {
	    opts.query = parsed.query;
	  } else if (opts && 'object' === typeof opts.query) {
	    opts.query = encodeQueryString(opts.query);
	  }
	  return io.socket(parsed.path, opts);
	}
	/**
	 *  Helper method to parse query objects to string.
	 * @param {object} query
	 * @returns {string}
	 */
	function encodeQueryString (obj) {
	  var str = [];
	  for (var p in obj) {
	    if (obj.hasOwnProperty(p)) {
	      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
	    }
	  }
	  return str.join('&');
	}
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = parser.protocol;
	
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */
	
	exports.connect = lookup;
	
	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */
	
	exports.Manager = __webpack_require__(90);
	exports.Socket = __webpack_require__(121);


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module dependencies.
	 */
	
	var parseuri = __webpack_require__(74);
	var debug = __webpack_require__(75)('socket.io-client:url');
	
	/**
	 * Module exports.
	 */
	
	module.exports = url;
	
	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */
	
	function url (uri, loc) {
	  var obj = uri;
	
	  // default to window.location
	  loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;
	
	  // relative path support
	  if ('string' === typeof uri) {
	    if ('/' === uri.charAt(0)) {
	      if ('/' === uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }
	
	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' !== typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }
	
	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }
	
	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }
	
	  obj.path = obj.path || '/';
	
	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;
	
	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));
	
	  return obj;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    return uri;
	};


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(77);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    return exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (typeof process !== 'undefined' && 'env' in process) {
	    return process.env.DEBUG;
	  }
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76)))

/***/ },
/* 76 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug.debug = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(78);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting
	    args = exports.formatArgs.apply(self, args);
	
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var debug = __webpack_require__(80)('socket.io-parser');
	var json = __webpack_require__(83);
	var Emitter = __webpack_require__(86);
	var binary = __webpack_require__(87);
	var isBuf = __webpack_require__(89);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	exports.protocol = 4;
	
	/**
	 * Packet types.
	 *
	 * @api public
	 */
	
	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];
	
	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */
	
	exports.CONNECT = 0;
	
	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */
	
	exports.DISCONNECT = 1;
	
	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */
	
	exports.EVENT = 2;
	
	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */
	
	exports.ACK = 3;
	
	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */
	
	exports.ERROR = 4;
	
	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */
	
	exports.BINARY_EVENT = 5;
	
	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */
	
	exports.BINARY_ACK = 6;
	
	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */
	
	exports.Encoder = Encoder;
	
	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */
	
	exports.Decoder = Decoder;
	
	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */
	
	function Encoder() {}
	
	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */
	
	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);
	
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};
	
	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */
	
	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;
	
	  // first is type
	  str += obj.type;
	
	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }
	
	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }
	
	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }
	
	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }
	
	  debug('encoded %j as %s', obj, str);
	  return str;
	}
	
	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */
	
	function encodeAsBinary(obj, callback) {
	
	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;
	
	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }
	
	  binary.removeBlobs(obj, writeEncoding);
	}
	
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */
	
	function Decoder() {
	  this.reconstructor = null;
	}
	
	/**
	 * Mix in `Emitter` with Decoder.
	 */
	
	Emitter(Decoder.prototype);
	
	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */
	
	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);
	
	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};
	
	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */
	
	function decodeString(str) {
	  var p = {};
	  var i = 0;
	
	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();
	
	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }
	
	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }
	
	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }
	
	  // look up json data
	  if (str.charAt(++i)) {
	    p = tryParse(p, str.substr(i));
	  }
	
	  debug('decoded %s as %j', str, p);
	  return p;
	}
	
	function tryParse(p, str) {
	  try {
	    p.data = json.parse(str);
	  } catch(e){
	    return error();
	  }
	  return p; 
	};
	
	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */
	
	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};
	
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */
	
	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}
	
	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */
	
	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};
	
	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */
	
	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};
	
	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(81);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(82);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 82 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(85);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(84)(module), (function() { return this; }())))

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 85 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 86 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/
	
	/**
	 * Module requirements
	 */
	
	var isArray = __webpack_require__(88);
	var isBuf = __webpack_require__(89);
	
	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */
	
	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;
	
	  function _deconstructPacket(data) {
	    if (!data) return data;
	
	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }
	
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};
	
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */
	
	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;
	
	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }
	
	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};
	
	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;
	
	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;
	
	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }
	
	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };
	
	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }
	
	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 89 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;
	
	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */
	
	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var eio = __webpack_require__(91);
	var Socket = __webpack_require__(121);
	var Emitter = __webpack_require__(122);
	var parser = __webpack_require__(79);
	var on = __webpack_require__(124);
	var bind = __webpack_require__(125);
	var debug = __webpack_require__(75)('socket.io-client:manager');
	var indexOf = __webpack_require__(119);
	var Backoff = __webpack_require__(126);
	
	/**
	 * IE6+ hasOwnProperty
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Module exports
	 */
	
	module.exports = Manager;
	
	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */
	
	function Manager (uri, opts) {
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && ('object' === typeof uri)) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};
	
	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}
	
	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */
	
	Manager.prototype.emitAll = function () {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};
	
	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */
	
	Manager.prototype.updateSocketIds = function () {
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Manager.prototype);
	
	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnection = function (v) {
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};
	
	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionAttempts = function (v) {
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};
	
	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelay = function (v) {
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};
	
	Manager.prototype.randomizationFactor = function (v) {
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};
	
	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.reconnectionDelayMax = function (v) {
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};
	
	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */
	
	Manager.prototype.timeout = function (v) {
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};
	
	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */
	
	Manager.prototype.maybeReconnectOnOpen = function () {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};
	
	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */
	
	Manager.prototype.open =
	Manager.prototype.connect = function (fn, opts) {
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;
	
	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;
	
	  // emit `open`
	  var openSub = on(socket, 'open', function () {
	    self.onopen();
	    fn && fn();
	  });
	
	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function (data) {
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });
	
	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);
	
	    // set timer
	    var timer = setTimeout(function () {
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);
	
	    this.subs.push({
	      destroy: function () {
	        clearTimeout(timer);
	      }
	    });
	  }
	
	  this.subs.push(openSub);
	  this.subs.push(errorSub);
	
	  return this;
	};
	
	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */
	
	Manager.prototype.onopen = function () {
	  debug('open');
	
	  // clear old subs
	  this.cleanup();
	
	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');
	
	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};
	
	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */
	
	Manager.prototype.onping = function () {
	  this.lastPing = new Date();
	  this.emitAll('ping');
	};
	
	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.onpong = function () {
	  this.emitAll('pong', new Date() - this.lastPing);
	};
	
	/**
	 * Called with data.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondata = function (data) {
	  this.decoder.add(data);
	};
	
	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */
	
	Manager.prototype.ondecoded = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */
	
	Manager.prototype.onerror = function (err) {
	  debug('error', err);
	  this.emitAll('error', err);
	};
	
	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */
	
	Manager.prototype.socket = function (nsp, opts) {
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp, opts);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function () {
	      socket.id = self.engine.id;
	    });
	
	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }
	
	  function onConnecting () {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }
	
	  return socket;
	};
	
	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */
	
	Manager.prototype.destroy = function (socket) {
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;
	
	  this.close();
	};
	
	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Manager.prototype.packet = function (packet) {
	  debug('writing packet %j', packet);
	  var self = this;
	  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;
	
	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function (encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else { // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};
	
	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */
	
	Manager.prototype.processPacketQueue = function () {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};
	
	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */
	
	Manager.prototype.cleanup = function () {
	  debug('cleanup');
	
	  var subsLength = this.subs.length;
	  for (var i = 0; i < subsLength; i++) {
	    var sub = this.subs.shift();
	    sub.destroy();
	  }
	
	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;
	
	  this.decoder.destroy();
	};
	
	/**
	 * Close the current socket.
	 *
	 * @api private
	 */
	
	Manager.prototype.close =
	Manager.prototype.disconnect = function () {
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' === this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};
	
	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */
	
	Manager.prototype.onclose = function (reason) {
	  debug('onclose');
	
	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);
	
	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};
	
	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */
	
	Manager.prototype.reconnect = function () {
	  if (this.reconnecting || this.skipReconnect) return this;
	
	  var self = this;
	
	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);
	
	    this.reconnecting = true;
	    var timer = setTimeout(function () {
	      if (self.skipReconnect) return;
	
	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);
	
	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;
	
	      self.open(function (err) {
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);
	
	    this.subs.push({
	      destroy: function () {
	        clearTimeout(timer);
	      }
	    });
	  }
	};
	
	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */
	
	Manager.prototype.onreconnect = function () {
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(92);


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = __webpack_require__(93);
	
	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(100);


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var transports = __webpack_require__(94);
	var Emitter = __webpack_require__(109);
	var debug = __webpack_require__(113)('engine.io-client:socket');
	var index = __webpack_require__(119);
	var parser = __webpack_require__(100);
	var parseuri = __webpack_require__(74);
	var parsejson = __webpack_require__(120);
	var parseqs = __webpack_require__(110);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Socket;
	
	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */
	
	function Socket (uri, opts) {
	  if (!(this instanceof Socket)) return new Socket(uri, opts);
	
	  opts = opts || {};
	
	  if (uri && 'object' === typeof uri) {
	    opts = uri;
	    uri = null;
	  }
	
	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }
	
	  this.secure = null != opts.secure ? opts.secure
	    : (global.location && 'https:' === location.protocol);
	
	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }
	
	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port
	      ? location.port
	      : (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.prevBufferLen = 0;
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;
	
	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;
	  this.forceNode = !!opts.forceNode;
	
	  // other options for Node.js client
	  var freeGlobal = typeof global === 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	
	    if (opts.localAddress) {
	      this.localAddress = opts.localAddress;
	    }
	  }
	
	  // set on handshake
	  this.id = null;
	  this.upgrades = null;
	  this.pingInterval = null;
	  this.pingTimeout = null;
	
	  // set on heartbeat
	  this.pingIntervalTimer = null;
	  this.pingTimeoutTimer = null;
	
	  this.open();
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(99);
	Socket.transports = __webpack_require__(94);
	Socket.parser = __webpack_require__(100);
	
	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */
	
	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);
	
	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;
	
	  // transport name
	  query.transport = name;
	
	  // session id if we already have one
	  if (this.id) query.sid = this.id;
	
	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders,
	    forceNode: this.forceNode,
	    localAddress: this.localAddress
	  });
	
	  return transport;
	};
	
	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function () {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';
	
	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }
	
	  transport.open();
	  this.setTransport(transport);
	};
	
	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */
	
	Socket.prototype.setTransport = function (transport) {
	  debug('setting transport %s', transport.name);
	  var self = this;
	
	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }
	
	  // set up transport
	  this.transport = transport;
	
	  // set up transport listeners
	  transport
	  .on('drain', function () {
	    self.onDrain();
	  })
	  .on('packet', function (packet) {
	    self.onPacket(packet);
	  })
	  .on('error', function (e) {
	    self.onError(e);
	  })
	  .on('close', function () {
	    self.onClose('transport close');
	  });
	};
	
	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */
	
	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 });
	  var failed = false;
	  var self = this;
	
	  Socket.priorWebsocketSuccess = false;
	
	  function onTransportOpen () {
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;
	
	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' === msg.type && 'probe' === msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' === transport.name;
	
	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' === self.readyState) return;
	          debug('changing transport and sending upgrade packet');
	
	          cleanup();
	
	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }
	
	  function freezeTransport () {
	    if (failed) return;
	
	    // Any callback called by transport should be ignored since now
	    failed = true;
	
	    cleanup();
	
	    transport.close();
	    transport = null;
	  }
	
	  // Handle any error that happens while probing
	  function onerror (err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;
	
	    freezeTransport();
	
	    debug('probe transport "%s" failed because of error: %s', name, err);
	
	    self.emit('upgradeError', error);
	  }
	
	  function onTransportClose () {
	    onerror('transport closed');
	  }
	
	  // When the socket is closed while we're probing
	  function onclose () {
	    onerror('socket closed');
	  }
	
	  // When the socket is upgraded while we're probing
	  function onupgrade (to) {
	    if (transport && to.name !== transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }
	
	  // Remove all listeners on the transport and on self
	  function cleanup () {
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }
	
	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);
	
	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);
	
	  transport.open();
	};
	
	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */
	
	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
	  this.emit('open');
	  this.flush();
	
	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};
	
	/**
	 * Handles a packet.
	 *
	 * @api private
	 */
	
	Socket.prototype.onPacket = function (packet) {
	  if ('opening' === this.readyState || 'open' === this.readyState ||
	      'closing' === this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	    this.emit('packet', packet);
	
	    // Socket is live - any packet counts
	    this.emit('heartbeat');
	
	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;
	
	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;
	
	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;
	
	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};
	
	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */
	
	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if ('closed' === this.readyState) return;
	  this.setPing();
	
	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};
	
	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */
	
	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' === self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};
	
	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};
	
	/**
	* Sends a ping packet.
	*
	* @api private
	*/
	
	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function () {
	    self.emit('ping');
	  });
	};
	
	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */
	
	Socket.prototype.onDrain = function () {
	  this.writeBuffer.splice(0, this.prevBufferLen);
	
	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;
	
	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};
	
	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */
	
	Socket.prototype.flush = function () {
	  if ('closed' !== this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};
	
	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */
	
	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */
	
	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if ('function' === typeof data) {
	    fn = data;
	    data = undefined;
	  }
	
	  if ('function' === typeof options) {
	    fn = options;
	    options = null;
	  }
	
	  if ('closing' === this.readyState || 'closed' === this.readyState) {
	    return;
	  }
	
	  options = options || {};
	  options.compress = false !== options.compress;
	
	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};
	
	/**
	 * Closes the connection.
	 *
	 * @api private
	 */
	
	Socket.prototype.close = function () {
	  if ('opening' === this.readyState || 'open' === this.readyState) {
	    this.readyState = 'closing';
	
	    var self = this;
	
	    if (this.writeBuffer.length) {
	      this.once('drain', function () {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }
	
	  function close () {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }
	
	  function cleanupAndClose () {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }
	
	  function waitForUpgrade () {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }
	
	  return this;
	};
	
	/**
	 * Called upon transport error
	 *
	 * @api private
	 */
	
	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};
	
	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */
	
	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;
	
	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);
	
	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');
	
	    // ensure transport won't stay open
	    this.transport.close();
	
	    // ignore further transport communication
	    this.transport.removeAllListeners();
	
	    // set ready state
	    this.readyState = 'closed';
	
	    // clear session id
	    this.id = null;
	
	    // emit close event
	    this.emit('close', reason, desc);
	
	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};
	
	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */
	
	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i < j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */
	
	var XMLHttpRequest = __webpack_require__(95);
	var XHR = __webpack_require__(97);
	var JSONP = __webpack_require__(116);
	var websocket = __webpack_require__(117);
	
	/**
	 * Export transports.
	 */
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling (opts) {
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;
	
	  if (global.location) {
	    var isSSL = 'https:' === location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname !== location.hostname || port !== opts.port;
	    xs = opts.secure !== isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module
	
	var hasCORS = __webpack_require__(96);
	
	module.exports = function (opts) {
	  var xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }
	
	  if (!xdomain) {
	    try {
	      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
	    } catch (e) { }
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 96 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */
	
	var XMLHttpRequest = __webpack_require__(95);
	var Polling = __webpack_require__(98);
	var Emitter = __webpack_require__(109);
	var inherit = __webpack_require__(111);
	var debug = __webpack_require__(113)('engine.io-client:polling-xhr');
	
	/**
	 * Module exports.
	 */
	
	module.exports = XHR;
	module.exports.Request = Request;
	
	/**
	 * Empty function
	 */
	
	function empty () {}
	
	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function XHR (opts) {
	  Polling.call(this, opts);
	  this.requestTimeout = opts.requestTimeout;
	
	  if (global.location) {
	    var isSSL = 'https:' === location.protocol;
	    var port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    this.xd = opts.hostname !== global.location.hostname ||
	      port !== opts.port;
	    this.xs = opts.secure !== isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(XHR, Polling);
	
	/**
	 * XHR supports binary
	 */
	
	XHR.prototype.supportsBinary = true;
	
	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */
	
	XHR.prototype.request = function (opts) {
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  opts.requestTimeout = this.requestTimeout;
	
	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;
	
	  return new Request(opts);
	};
	
	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	XHR.prototype.doWrite = function (data, fn) {
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function (err) {
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	XHR.prototype.doPoll = function () {
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function (data) {
	    self.onData(data);
	  });
	  req.on('error', function (err) {
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};
	
	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	function Request (opts) {
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined !== opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	  this.requestTimeout = opts.requestTimeout;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	
	  this.create();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */
	
	Request.prototype.create = function () {
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	
	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;
	
	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }
	
	    if ('POST' === this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }
	
	    try {
	      xhr.setRequestHeader('Accept', '*/*');
	    } catch (e) {}
	
	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }
	
	    if (this.requestTimeout) {
	      xhr.timeout = this.requestTimeout;
	    }
	
	    if (this.hasXDR()) {
	      xhr.onload = function () {
	        self.onLoad();
	      };
	      xhr.onerror = function () {
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function () {
	        if (4 !== xhr.readyState) return;
	        if (200 === xhr.status || 1223 === xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function () {
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }
	
	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function () {
	      self.onError(e);
	    }, 0);
	    return;
	  }
	
	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};
	
	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */
	
	Request.prototype.onSuccess = function () {
	  this.emit('success');
	  this.cleanup();
	};
	
	/**
	 * Called if we have data.
	 *
	 * @api private
	 */
	
	Request.prototype.onData = function (data) {
	  this.emit('data', data);
	  this.onSuccess();
	};
	
	/**
	 * Called upon error.
	 *
	 * @api private
	 */
	
	Request.prototype.onError = function (err) {
	  this.emit('error', err);
	  this.cleanup(true);
	};
	
	/**
	 * Cleans up house.
	 *
	 * @api private
	 */
	
	Request.prototype.cleanup = function (fromError) {
	  if ('undefined' === typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }
	
	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch (e) {}
	  }
	
	  if (global.document) {
	    delete Request.requests[this.index];
	  }
	
	  this.xhr = null;
	};
	
	/**
	 * Called upon load.
	 *
	 * @api private
	 */
	
	Request.prototype.onLoad = function () {
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response || this.xhr.responseText;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }
	
	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};
	
	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */
	
	Request.prototype.hasXDR = function () {
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};
	
	/**
	 * Aborts the request.
	 *
	 * @api public
	 */
	
	Request.prototype.abort = function () {
	  this.cleanup();
	};
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	Request.requestsCount = 0;
	Request.requests = {};
	
	if (global.document) {
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}
	
	function unloadHandler () {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(99);
	var parseqs = __webpack_require__(110);
	var parser = __webpack_require__(100);
	var inherit = __webpack_require__(111);
	var yeast = __webpack_require__(112);
	var debug = __webpack_require__(113)('engine.io-client:polling');
	
	/**
	 * Module exports.
	 */
	
	module.exports = Polling;
	
	/**
	 * Is XHR2 supported?
	 */
	
	var hasXHR2 = (function () {
	  var XMLHttpRequest = __webpack_require__(95);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();
	
	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */
	
	function Polling (opts) {
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(Polling, Transport);
	
	/**
	 * Transport name.
	 */
	
	Polling.prototype.name = 'polling';
	
	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */
	
	Polling.prototype.doOpen = function () {
	  this.poll();
	};
	
	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */
	
	Polling.prototype.pause = function (onPause) {
	  var self = this;
	
	  this.readyState = 'pausing';
	
	  function pause () {
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }
	
	  if (this.polling || !this.writable) {
	    var total = 0;
	
	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function () {
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }
	
	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function () {
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};
	
	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */
	
	Polling.prototype.poll = function () {
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};
	
	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */
	
	Polling.prototype.onData = function (data) {
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function (packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' === self.readyState) {
	      self.onOpen();
	    }
	
	    // if its a close packet, we close the ongoing requests
	    if ('close' === packet.type) {
	      self.onClose();
	      return false;
	    }
	
	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };
	
	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);
	
	  // if an event did not trigger closing
	  if ('closed' !== this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');
	
	    if ('open' === this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};
	
	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */
	
	Polling.prototype.doClose = function () {
	  var self = this;
	
	  function close () {
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }
	
	  if ('open' === this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};
	
	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */
	
	Polling.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	  var callbackfn = function () {
	    self.writable = true;
	    self.emit('drain');
	  };
	
	  parser.encodePayload(packets, this.supportsBinary, function (data) {
	    self.doWrite(data, callbackfn);
	  });
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	Polling.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';
	
	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // avoid port if default for schema
	  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
	     ('http' === schema && Number(this.port) !== 80))) {
	    port = ':' + this.port;
	  }
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(100);
	var Emitter = __webpack_require__(109);
	
	/**
	 * Module exports.
	 */
	
	module.exports = Transport;
	
	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */
	
	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;
	
	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	  this.forceNode = opts.forceNode;
	
	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	  this.localAddress = opts.localAddress;
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Transport.prototype);
	
	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */
	
	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};
	
	/**
	 * Opens the transport.
	 *
	 * @api public
	 */
	
	Transport.prototype.open = function () {
	  if ('closed' === this.readyState || '' === this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }
	
	  return this;
	};
	
	/**
	 * Closes the transport.
	 *
	 * @api private
	 */
	
	Transport.prototype.close = function () {
	  if ('opening' === this.readyState || 'open' === this.readyState) {
	    this.doClose();
	    this.onClose();
	  }
	
	  return this;
	};
	
	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	Transport.prototype.send = function (packets) {
	  if ('open' === this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};
	
	/**
	 * Called upon open
	 *
	 * @api private
	 */
	
	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};
	
	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */
	
	Transport.prototype.onData = function (data) {
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};
	
	/**
	 * Called with a decoded packet.
	 */
	
	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};
	
	/**
	 * Called upon close.
	 *
	 * @api private
	 */
	
	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var keys = __webpack_require__(101);
	var hasBinary = __webpack_require__(102);
	var sliceBuffer = __webpack_require__(104);
	var after = __webpack_require__(105);
	var utf8 = __webpack_require__(106);
	
	var base64encoder;
	if (global && global.ArrayBuffer) {
	  base64encoder = __webpack_require__(107);
	}
	
	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */
	
	var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
	
	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);
	
	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;
	
	/**
	 * Current protocol version.
	 */
	
	exports.protocol = 3;
	
	/**
	 * Packet types.
	 */
	
	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};
	
	var packetslist = keys(packets);
	
	/**
	 * Premade error packet.
	 */
	
	var err = { type: 'error', data: 'parser error' };
	
	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */
	
	var Blob = __webpack_require__(108);
	
	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */
	
	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }
	
	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }
	
	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;
	
	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }
	
	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }
	
	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];
	
	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }
	
	  return callback('' + encoded);
	
	};
	
	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}
	
	/**
	 * Encode packet helpers for binary types
	 */
	
	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);
	
	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }
	
	  return callback(resultBuffer.buffer);
	}
	
	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}
	
	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }
	
	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }
	
	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);
	
	  return callback(blob);
	}
	
	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */
	
	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }
	
	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};
	
	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */
	
	exports.decodePacket = function (data, binaryType, utf8decode) {
	  if (data === undefined) {
	    return err;
	  }
	  // String data
	  if (typeof data == 'string') {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }
	
	    if (utf8decode) {
	      data = tryDecode(data);
	      if (data === false) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);
	
	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }
	
	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }
	
	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};
	
	function tryDecode(data) {
	  try {
	    data = utf8.decode(data);
	  } catch (e) {
	    return false;
	  }
	  return data;
	}
	
	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */
	
	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!base64encoder) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }
	
	  var data = base64encoder.decode(msg.substr(1));
	
	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }
	
	  return { type: type, data: data };
	};
	
	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */
	
	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }
	
	  var isBinary = hasBinary(packets);
	
	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }
	
	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }
	
	  if (!packets.length) {
	    return callback('0:');
	  }
	
	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};
	
	/**
	 * Async array map using after
	 */
	
	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);
	
	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };
	
	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}
	
	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */
	
	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }
	
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	  var length = ''
	    , n, msg;
	
	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);
	
	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      msg = data.substr(i + 1, n);
	
	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }
	
	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);
	
	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }
	
	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }
	
	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }
	
	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }
	
	};
	
	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */
	
	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }
	
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }
	
	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);
	
	    var resultArray = new Uint8Array(totalLength);
	
	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }
	
	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }
	
	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;
	
	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });
	
	    return callback(resultArray.buffer);
	  });
	};
	
	/**
	 * Encode as Blob
	 */
	
	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }
	
	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;
	
	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;
	
	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }
	
	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};
	
	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */
	
	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }
	
	  var bufferTail = data;
	  var buffers = [];
	
	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';
	
	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;
	
	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }
	
	      msgLength += tailArray[i];
	    }
	
	    if(numberTooLong) return callback(err, 0, 1);
	
	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);
	
	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }
	
	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }
	
	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 101 */
/***/ function(module, exports) {

	
	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */
	
	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;
	
	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */
	
	var isArray = __webpack_require__(103);
	
	/**
	 * Module exports.
	 */
	
	module.exports = hasBinary;
	
	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */
	
	function hasBinary(data) {
	
	  function _hasBinary(obj) {
	    if (!obj) return false;
	
	    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }
	
	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }
	
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }
	
	    return false;
	  }
	
	  return _hasBinary(data);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 103 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */
	
	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;
	
	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
	
	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }
	
	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }
	
	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = after
	
	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count
	
	    return (count === 0) ? callback() : proxy
	
	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count
	
	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}
	
	function noop() {}


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/wtf8 v1.0.0 by @mathias */
	;(function(root) {
	
		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;
	
		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;
	
		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}
	
		/*--------------------------------------------------------------------------*/
	
		var stringFromCharCode = String.fromCharCode;
	
		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}
	
		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}
	
		function wtf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}
	
		/*--------------------------------------------------------------------------*/
	
		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}
	
			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}
	
			// If we end up here, it’s not a continuation byte.
			throw Error('Invalid continuation byte');
		}
	
		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;
	
			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}
	
			if (byteIndex == byteCount) {
				return false;
			}
	
			// Read the first byte.
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;
	
			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}
	
			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}
	
			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}
	
			throw Error('Invalid WTF-8 detected');
		}
	
		var byteArray;
		var byteCount;
		var byteIndex;
		function wtf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}
	
		/*--------------------------------------------------------------------------*/
	
		var wtf8 = {
			'version': '1.0.0',
			'encode': wtf8encode,
			'decode': wtf8decode
		};
	
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return wtf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = wtf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in wtf8) {
					hasOwnProperty.call(wtf8, key) && (freeExports[key] = wtf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.wtf8 = wtf8;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(84)(module), (function() { return this; }())))

/***/ },
/* 107 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(){
	  "use strict";
	
	  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	
	  // Use a lookup table to find the index.
	  var lookup = new Uint8Array(256);
	  for (var i = 0; i < chars.length; i++) {
	    lookup[chars.charCodeAt(i)] = i;
	  }
	
	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";
	
	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i+=4) {
	      encoded1 = lookup[base64.charCodeAt(i)];
	      encoded2 = lookup[base64.charCodeAt(i+1)];
	      encoded3 = lookup[base64.charCodeAt(i+2)];
	      encoded4 = lookup[base64.charCodeAt(i+3)];
	
	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }
	
	    return arraybuffer;
	  };
	})();


/***/ },
/* 108 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */
	
	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;
	
	/**
	 * Check if Blob constructor is supported
	 */
	
	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */
	
	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();
	
	/**
	 * Check if BlobBuilder is supported
	 */
	
	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;
	
	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */
	
	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;
	
	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }
	
	      ary[i] = buf;
	    }
	  }
	}
	
	function BlobBuilderConstructor(ary, options) {
	  options = options || {};
	
	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);
	
	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }
	
	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};
	
	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};
	
	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	if (true) {
	  module.exports = Emitter;
	}
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 111 */
/***/ function(module, exports) {

	
	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ },
/* 112 */
/***/ function(module, exports) {

	'use strict';
	
	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;
	
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	
	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);
	
	  return encoded;
	}
	
	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;
	
	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }
	
	  return decoded;
	}
	
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	
	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}
	
	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;
	
	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(114);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    return exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (typeof process !== 'undefined' && 'env' in process) {
	    return process.env.DEBUG;
	  }
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug.debug = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(115);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting
	    args = exports.formatArgs.apply(self, args);
	
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */
	
	var Polling = __webpack_require__(98);
	var inherit = __webpack_require__(111);
	
	/**
	 * Module exports.
	 */
	
	module.exports = JSONPPolling;
	
	/**
	 * Cached regular expressions.
	 */
	
	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	var callbacks;
	
	/**
	 * Noop.
	 */
	
	function empty () { }
	
	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */
	
	function JSONPPolling (opts) {
	  Polling.call(this, opts);
	
	  this.query = this.query || {};
	
	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }
	
	  // callback identifier
	  this.index = callbacks.length;
	
	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });
	
	  // append to query string
	  this.query.j = this.index;
	
	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}
	
	/**
	 * Inherits from Polling.
	 */
	
	inherit(JSONPPolling, Polling);
	
	/*
	 * JSONP only supports binary as base64 encoded strings
	 */
	
	JSONPPolling.prototype.supportsBinary = false;
	
	/**
	 * Closes the socket.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }
	
	  Polling.prototype.doClose.call(this);
	};
	
	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */
	
	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');
	
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }
	
	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function (e) {
	    self.onError('jsonp poll error', e);
	  };
	
	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  } else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;
	
	  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);
	
	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};
	
	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */
	
	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;
	
	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;
	
	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);
	
	    this.form = form;
	    this.area = area;
	  }
	
	  this.form.action = this.uri();
	
	  function complete () {
	    initIframe();
	    fn();
	  }
	
	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }
	
	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }
	
	    iframe.id = self.iframeId;
	
	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }
	
	  initIframe();
	
	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');
	
	  try {
	    this.form.submit();
	  } catch (e) {}
	
	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function () {
	      if (self.iframe.readyState === 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */
	
	var Transport = __webpack_require__(99);
	var parser = __webpack_require__(100);
	var parseqs = __webpack_require__(110);
	var inherit = __webpack_require__(111);
	var yeast = __webpack_require__(112);
	var debug = __webpack_require__(113)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
	var NodeWebSocket;
	if (typeof window === 'undefined') {
	  try {
	    NodeWebSocket = __webpack_require__(118);
	  } catch (e) { }
	}
	
	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */
	
	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  WebSocket = NodeWebSocket;
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = WS;
	
	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */
	
	function WS (opts) {
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
	  if (!this.usingBrowserWebSocket) {
	    WebSocket = NodeWebSocket;
	  }
	  Transport.call(this, opts);
	}
	
	/**
	 * Inherits from Transport.
	 */
	
	inherit(WS, Transport);
	
	/**
	 * Transport name.
	 *
	 * @api public
	 */
	
	WS.prototype.name = 'websocket';
	
	/*
	 * WebSockets support binary
	 */
	
	WS.prototype.supportsBinary = true;
	
	/**
	 * Opens socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doOpen = function () {
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }
	
	  var uri = this.uri();
	  var protocols = void (0);
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };
	
	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	  if (this.localAddress) {
	    opts.localAddress = this.localAddress;
	  }
	
	  try {
	    this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
	  } catch (err) {
	    return this.emit('error', err);
	  }
	
	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }
	
	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'nodebuffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }
	
	  this.addEventListeners();
	};
	
	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */
	
	WS.prototype.addEventListeners = function () {
	  var self = this;
	
	  this.ws.onopen = function () {
	    self.onOpen();
	  };
	  this.ws.onclose = function () {
	    self.onClose();
	  };
	  this.ws.onmessage = function (ev) {
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function (e) {
	    self.onError('websocket error', e);
	  };
	};
	
	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */
	
	WS.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	
	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function (packet) {
	      parser.encodePacket(packet, self.supportsBinary, function (data) {
	        if (!self.usingBrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }
	
	          if (self.perMessageDeflate) {
	            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }
	
	        // Sometimes the websocket has already been closed but the browser didn't
	        // have a chance of informing us about it yet, in that case send will
	        // throw an error
	        try {
	          if (self.usingBrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e) {
	          debug('websocket closed before onclose event');
	        }
	
	        --total || done();
	      });
	    })(packets[i]);
	  }
	
	  function done () {
	    self.emit('flush');
	
	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function () {
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};
	
	/**
	 * Called upon close
	 *
	 * @api private
	 */
	
	WS.prototype.onClose = function () {
	  Transport.prototype.onClose.call(this);
	};
	
	/**
	 * Closes socket.
	 *
	 * @api private
	 */
	
	WS.prototype.doClose = function () {
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};
	
	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */
	
	WS.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';
	
	  // avoid port if default for schema
	  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
	    ('ws' === schema && Number(this.port) !== 80))) {
	    port = ':' + this.port;
	  }
	
	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }
	
	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }
	
	  query = parseqs.encode(query);
	
	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }
	
	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};
	
	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */
	
	WS.prototype.check = function () {
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 118 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 119 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 120 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */
	
	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;
	
	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }
	
	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
	
	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }
	
	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var parser = __webpack_require__(79);
	var Emitter = __webpack_require__(122);
	var toArray = __webpack_require__(123);
	var on = __webpack_require__(124);
	var bind = __webpack_require__(125);
	var debug = __webpack_require__(75)('socket.io-client:socket');
	var hasBin = __webpack_require__(102);
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = Socket;
	
	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */
	
	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};
	
	/**
	 * Shortcut to `Emitter#emit`.
	 */
	
	var emit = Emitter.prototype.emit;
	
	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */
	
	function Socket (io, nsp, opts) {
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (opts && opts.query) {
	    this.query = opts.query;
	  }
	  if (this.io.autoConnect) this.open();
	}
	
	/**
	 * Mix in `Emitter`.
	 */
	
	Emitter(Socket.prototype);
	
	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */
	
	Socket.prototype.subEvents = function () {
	  if (this.subs) return;
	
	  var io = this.io;
	  this.subs = [
	    on(io, 'open', bind(this, 'onopen')),
	    on(io, 'packet', bind(this, 'onpacket')),
	    on(io, 'close', bind(this, 'onclose'))
	  ];
	};
	
	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */
	
	Socket.prototype.open =
	Socket.prototype.connect = function () {
	  if (this.connected) return this;
	
	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' === this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};
	
	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.send = function () {
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};
	
	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.emit = function (ev) {
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }
	
	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	  var packet = { type: parserType, data: args };
	
	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;
	
	  // event ack callback
	  if ('function' === typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }
	
	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }
	
	  delete this.flags;
	
	  return this;
	};
	
	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.packet = function (packet) {
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};
	
	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */
	
	Socket.prototype.onopen = function () {
	  debug('transport is open - connecting');
	
	  // write connect packet if necessary
	  if ('/' !== this.nsp) {
	    if (this.query) {
	      this.packet({type: parser.CONNECT, query: this.query});
	    } else {
	      this.packet({type: parser.CONNECT});
	    }
	  }
	};
	
	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */
	
	Socket.prototype.onclose = function (reason) {
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};
	
	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onpacket = function (packet) {
	  if (packet.nsp !== this.nsp) return;
	
	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;
	
	    case parser.EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;
	
	    case parser.ACK:
	      this.onack(packet);
	      break;
	
	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;
	
	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;
	
	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};
	
	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onevent = function (packet) {
	  var args = packet.data || [];
	  debug('emitting event %j', args);
	
	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }
	
	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};
	
	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */
	
	Socket.prototype.ack = function (id) {
	  var self = this;
	  var sent = false;
	  return function () {
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);
	
	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};
	
	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */
	
	Socket.prototype.onack = function (packet) {
	  var ack = this.acks[packet.id];
	  if ('function' === typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};
	
	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */
	
	Socket.prototype.onconnect = function () {
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};
	
	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */
	
	Socket.prototype.emitBuffered = function () {
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];
	
	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};
	
	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */
	
	Socket.prototype.ondisconnect = function () {
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};
	
	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */
	
	Socket.prototype.destroy = function () {
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }
	
	  this.io.destroy(this);
	};
	
	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.close =
	Socket.prototype.disconnect = function () {
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }
	
	  // remove socket from pool
	  this.destroy();
	
	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};
	
	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */
	
	Socket.prototype.compress = function (compress) {
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	if (true) {
	  module.exports = Emitter;
	}
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 123 */
/***/ function(module, exports) {

	module.exports = toArray
	
	function toArray(list, index) {
	    var array = []
	
	    index = index || 0
	
	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }
	
	    return array
	}


/***/ },
/* 124 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 */
	
	module.exports = on;
	
	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */
	
	function on (obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function () {
	      obj.removeListener(ev, fn);
	    }
	  };
	}


/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * Slice reference.
	 */
	
	var slice = [].slice;
	
	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */
	
	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ },
/* 126 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};
	


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.NavBarUI = exports.NavBar = undefined;
	
	var _overlay = __webpack_require__(128);
	
	var _overlay2 = _interopRequireDefault(_overlay);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NavBar = {};
	
	NavBar.setTabViewActive = function ($tabView) {
	    var activeClass = 'c--active';
	
	    $('.t-tab').removeClass(activeClass);
	    $tabView.addClass(activeClass);
	};
	
	NavBar.setTabActive = function ($tab, pushState) {
	    var tab = $tab.data('tab');
	    var activeTabViewSelector = '#' + tab + '-tab-content';
	
	    _highlightTab($tab);
	    NavBar.setTabViewActive($(activeTabViewSelector));
	
	    if (pushState) {
	        history.pushState({ 'tab': tab }, tab, '/' + tab);
	    }
	};
	
	var _bindEvents = function _bindEvents() {
	    $('body').on('click', '.c-nav-bar__tab', function (e) {
	        e.stopPropagation();
	        _overlay2.default.hide();
	
	        var $selectedTab = $(this);
	        NavBar.setTabActive($selectedTab, true);
	    });
	};
	
	var _highlightTab = function _highlightTab($tab) {
	    var activeClass = 'c--active';
	    var tab = $tab.data('tab');
	    var activeTabViewSelector = '#' + tab + '-tab-content';
	
	    $('.c-nav-bar__tab').removeClass(activeClass);
	    $tab.addClass(activeClass);
	};
	
	var _selectInitialTab = function _selectInitialTab() {
	    var pathMatchesTab = function pathMatchesTab(tab) {
	        return new RegExp('^/' + tab + '((/\\.*)|#)?').test(location.pathname);
	    };
	
	    if (pathMatchesTab('library')) {
	        NavBar.setTabActive($('.c-nav-bar__tab[data-tab=library]'));
	    } else if (pathMatchesTab('search')) {
	        NavBar.setTabActive($('.c-nav-bar__tab[data-tab=search]'));
	    } else {
	        NavBar.setTabActive($('.c-nav-bar__tab[data-tab=playlists]'));
	    }
	};
	
	var NavBarUI = function NavBarUI() {
	    _bindEvents();
	    _selectInitialTab();
	};
	
	exports.NavBar = NavBar;
	exports.NavBarUI = NavBarUI;

/***/ },
/* 128 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var OVERLAY_SELECTOR = '.c-overlay';
	var VISIBLE_CLASS = 'c--visible';
	var HIDDEN_CLASS = 'u-hidden';
	
	var Overlay = {};
	
	Overlay.show = function () {
	    $(OVERLAY_SELECTOR).addClass(VISIBLE_CLASS);
	};
	
	Overlay.hide = function () {
	    $(OVERLAY_SELECTOR).removeClass(VISIBLE_CLASS);
	    $('.js-overlay-modal').addClass(HIDDEN_CLASS);
	};
	
	var _bindEvents = function _bindEvents() {
	    $('body').on('click', OVERLAY_SELECTOR, function (e) {
	        e.stopPropagation();
	        if (this === e.target) {
	            Overlay.hide();
	        }
	    });
	};
	
	var _OverlayUI = function _OverlayUI() {
	    _bindEvents();
	};
	
	_OverlayUI();
	
	exports.default = Overlay;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.PlaylistSelectorUI = exports.PlaylistSelector = undefined;
	
	var _events = __webpack_require__(66);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _request = __webpack_require__(67);
	
	var _request2 = _interopRequireDefault(_request);
	
	var _overlay = __webpack_require__(128);
	
	var _overlay2 = _interopRequireDefault(_overlay);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LIST_SEL_SELECTOR = '.js-playlist-selector';
	var PLAYLIST_LIST_SELECTOR = '#playlist-list-selector';
	var HIDDEN_CLASS = 'u-hidden';
	
	var PlaylistSelector = {};
	
	PlaylistSelector.showSelectionFor = function (songId) {
	    // We don't want the content behind the overlay to be scrollable
	    $('body').addClass('u-no-scroll');
	    _overlay2.default.show();
	
	    var $playlistSel = $(LIST_SEL_SELECTOR);
	    $playlistSel.removeClass(HIDDEN_CLASS).data('song-id', songId);
	};
	
	PlaylistSelector.hide = function () {
	    $('body').removeClass('u-no-scroll');
	    _overlay2.default.hide();
	};
	
	PlaylistSelector.addPlaylist = function (playlistObj) {
	    var $playlistList = $(PLAYLIST_LIST_SELECTOR);
	    var $selectorEl = $('<li></li>');
	    var selectorClass = 'c-list-selector__item';
	
	    $selectorEl.addClass(selectorClass).text(playlistObj.name).data('id', playlistObj.id);
	
	    $playlistList.append($selectorEl[0]);
	};
	
	var _addPlaylists = function _addPlaylists() {
	    if (!$.isArray(PLAYLISTS) || PLAYLISTS.length === 0) {
	        return;
	    }
	    var $playlistList = $(PLAYLIST_LIST_SELECTOR);
	    $playlistList.html('');
	    PLAYLISTS.forEach(PlaylistSelector.addPlaylist);
	};
	
	var _bindEvents = function _bindEvents() {
	    var $body = $('body');
	    var $playlistSel = $(LIST_SEL_SELECTOR);
	    var $listSelCloseBtn = $('.js-playlist-selector .c-list-selector__close-button');
	
	    $listSelCloseBtn.on('click', function (e) {
	        e.stopPropagation();
	        PlaylistSelector.hide();
	    });
	
	    $body.on('click', '.js-playlist-selector .c-list-selector__item', function (e) {
	        e.stopPropagation();
	        var selectedSongId = $playlistSel.data('song-id');
	        var selectedPlaylistId = $(this).data('id');
	        var playlistObj = UTILS.getObjWithId(PLAYLISTS, selectedPlaylistId);
	        if (!playlistObj.songs.includes(parseInt(selectedSongId))) {
	            _request2.default.addSongToPlaylist(selectedSongId, selectedPlaylistId).then(function () {
	                UTILS.addSongToPlaylist(selectedSongId, playlistObj);
	            }).catch(function (err) {
	                console.log(err);
	            });
	        }
	        PlaylistSelector.hide();
	    });
	
	    $body.on(_events2.default.names.PLAYLIST_ADDED, function (e, playlistObj) {
	        PlaylistSelector.addPlaylist(playlistObj);
	    });
	
	    $body.on(_events2.default.names.PLAYLIST_SELECTOR_UPDATE_NEEDED, function () {
	        _addPlaylists();
	    });
	};
	
	var PlaylistSelectorUI = function PlaylistSelectorUI() {
	    _bindEvents();
	};
	
	exports.PlaylistSelector = PlaylistSelector;
	exports.PlaylistSelectorUI = PlaylistSelectorUI;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.UserSelectorUI = exports.UserSelector = undefined;
	
	var _events = __webpack_require__(66);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _request = __webpack_require__(67);
	
	var _request2 = _interopRequireDefault(_request);
	
	var _overlay = __webpack_require__(128);
	
	var _overlay2 = _interopRequireDefault(_overlay);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LIST_SEL_SELECTOR = '.js-user-selector';
	var USER_LIST_SELECTOR = '#user-list-selector';
	var HIDDEN_CLASS = 'u-hidden';
	
	var UserSelector = {};
	
	UserSelector.showSelectionFor = function (playlistId) {
	    // We don't want the content behind the overlay to be scrollable
	    $('body').addClass('u-no-scroll');
	    _overlay2.default.show();
	    _request2.default.getUsers().then(function (users) {
	        _addUsers(users);
	    });
	    var $userSelector = $(LIST_SEL_SELECTOR);
	    $userSelector.removeClass(HIDDEN_CLASS).data('playlist-id', playlistId);
	};
	
	UserSelector.hide = function () {
	    $('body').removeClass('u-no-scroll');
	    _overlay2.default.hide();
	};
	
	UserSelector.addUser = function (userObj) {
	    var $userList = $(USER_LIST_SELECTOR);
	    var $selectorEl = $('<li></li>');
	    var selectorClass = 'c-list-selector__item';
	
	    $selectorEl.addClass(selectorClass).text(userObj.name).data('id', userObj.id);
	
	    $userList.append($selectorEl[0]);
	};
	
	var _addUsers = function _addUsers(users) {
	    if (!$.isArray(users) || users.length === 0) {
	        return;
	    }
	    var $userList = $(USER_LIST_SELECTOR);
	    $userList.html('');
	    users.forEach(UserSelector.addUser);
	};
	
	var _bindEvents = function _bindEvents() {
	    var $body = $('body');
	    var $userSelector = $(LIST_SEL_SELECTOR);
	    var $userSelCloseBtn = $('.js-user-selector .c-list-selector__close-button');
	
	    $userSelCloseBtn.on('click', function (e) {
	        e.stopPropagation();
	        UserSelector.hide();
	    });
	
	    $body.on('click', '.js-user-selector .c-list-selector__item', function (e) {
	        e.stopPropagation();
	        var selectedPlaylistId = $userSelector.data('playlist-id');
	        var userId = $(this).data('id');
	
	        _request2.default.grantUserPlaylistPermission({
	            userId: userId,
	            playlistId: selectedPlaylistId
	        });
	        // const playlistObj = UTILS.getObjWithId(PLAYLISTS, selectedPlaylistId)
	        // if (!playlistObj.songs.includes(parseInt(selectedSongId))) {
	        //     Request.addSongToPlaylist(selectedSongId, selectedPlaylistId)
	        //         .then(function() {
	        //             UTILS.addSongToPlaylist(selectedSongId, playlistObj)
	        //         })
	        //         .catch(function(err) {
	        //             console.log(err)
	        //         })
	        // }
	        UserSelector.hide();
	    });
	};
	
	var UserSelectorUI = function UserSelectorUI() {
	    _bindEvents();
	};
	
	exports.UserSelector = UserSelector;
	exports.UserSelectorUI = UserSelectorUI;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _stringify = __webpack_require__(68);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _playlistSelector = __webpack_require__(129);
	
	var _events = __webpack_require__(66);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TITLE_SORT_KEY = 'title';
	var ARTIST_SORT_KEY = 'artist';
	
	var TITLE_SORTED_SONGS = undefined;
	var ARTIST_SORTED_SONGS = undefined;
	
	var _getSongsSortedBy = function _getSongsSortedBy(sortKey) {
	    var comparator = function comparator(a, b) {
	        var exclusionRegEx = new RegExp('^The(\\s)+', 'i');
	        var inAscendingOrder = a[sortKey].replace(exclusionRegEx, '') <= b[sortKey].replace(exclusionRegEx, '');
	        return inAscendingOrder ? -1 : 1;
	    };
	
	    switch (sortKey) {
	        case TITLE_SORT_KEY:
	            if (!TITLE_SORTED_SONGS) {
	                var sortedSongs = SONGS.sort(comparator);
	                TITLE_SORTED_SONGS = JSON.parse((0, _stringify2.default)(sortedSongs));
	            }
	            return TITLE_SORTED_SONGS;
	        default:
	            if (!ARTIST_SORTED_SONGS) {
	                var _sortedSongs = SONGS.sort(comparator);
	                ARTIST_SORTED_SONGS = JSON.parse((0, _stringify2.default)(_sortedSongs));
	            }
	            return ARTIST_SORTED_SONGS;
	    }
	};
	
	var _loadSongsSortedBy = function _loadSongsSortedBy(sortKey) {
	    if (!$.isArray(SONGS) || SONGS.length === 0) {
	        return;
	    }
	    $('#library').html('');
	    var sortedSongs = _getSongsSortedBy(sortKey);
	
	    sortedSongs.forEach(function (songObj) {
	        library.append(UTILS.songElementFor(songObj)[0]);
	    });
	};
	
	var _bindEvents = function _bindEvents() {
	    var activeClass = 'c--active';
	    var $body = $('body');
	
	    $body.on('click', '.js-add-to-playlist', function (e) {
	        e.stopPropagation();
	
	        var $songEl = $(this).closest('.c-library__item');
	        _playlistSelector.PlaylistSelector.showSelectionFor($songEl.data('id'));
	    });
	
	    $('.js-library-sort-button').on('click', function (e) {
	        e.stopPropagation();
	
	        // Set button active
	        var $selectedBtn = $(this);
	        $('.js-library-sort-button').removeClass(activeClass);
	        $selectedBtn.addClass(activeClass);
	
	        _loadSongsSortedBy($selectedBtn.data('key'));
	    });
	
	    $body.on(_events2.default.names.SONGS_UPDATED, function (e) {
	        _loadSongsSortedBy(ARTIST_SORT_KEY);
	    });
	};
	
	var LibraryUI = function LibraryUI() {
	    _bindEvents();
	};
	
	exports.default = LibraryUI;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _events = __webpack_require__(66);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _request = __webpack_require__(67);
	
	var _request2 = _interopRequireDefault(_request);
	
	var _navBar = __webpack_require__(127);
	
	var _addPlaylistForm = __webpack_require__(133);
	
	var _userSelector = __webpack_require__(130);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Playlists = {};
	
	Playlists.add = function (playlistObj) {
	    var $playlist = $('#playlists');
	    var $playlistEl = UTILS.playlistElementFor(playlistObj);
	    $playlist.append($playlistEl[0]);
	};
	
	var _loadPlaylists = function _loadPlaylists() {
	    if (!$.isArray(PLAYLISTS) || PLAYLISTS.length === 0) {
	        return;
	    }
	    // Clear all playlists
	    $('#playlists').html('');
	    PLAYLISTS.forEach(Playlists.add);
	};
	
	var _bindEvents = function _bindEvents() {
	    var $body = $('body');
	
	    $body.on('click', '.c-playlist__item', function (e) {
	        e.stopPropagation();
	
	        var $playlistDetailView = $('#playlist-details');
	        var $selectedPlaylist = $(this);
	        var playlistId = $selectedPlaylist.data('id');
	        var playlistObj = UTILS.getObjWithId(PLAYLISTS, playlistId);
	
	        var $playlistHeader = $('.c-playlist-details__heading-container h1');
	        var $playlistSongList = $('#playlist-song-list').html('');
	
	        $playlistHeader.text(playlistObj.name);
	        $playlistDetailView.data('playlist-id', playlistId);
	
	        playlistObj.songs.forEach(function (songId) {
	            var $songEl = UTILS.songElementFor(UTILS.getObjWithId(SONGS, songId));
	            $playlistSongList.append($songEl[0]);
	        });
	        _navBar.NavBar.setTabViewActive($playlistDetailView);
	    });
	
	    $body.on('click', '#playlist-button', function (e) {
	        _addPlaylistForm.AddPlaylistForm.show();
	    });
	
	    $body.on('click', '#user-button', function (e) {
	        var playlistDetailsId = $('#playlist-details').data('playlist-id');
	        _userSelector.UserSelector.showSelectionFor(playlistDetailsId);
	    });
	
	    $body.on('click', '#playlist-song-list .js-remove-from-playlist', function (e) {
	        var $songEl = $(this).closest('.c-library__item');
	        var songId = $songEl.data('id');
	        var playlistId = $('#playlist-details').data('playlist-id');
	
	        _request2.default.removeSongFromPlaylist(songId, playlistId).then(function () {
	            var playlistObj = UTILS.getObjWithId(PLAYLISTS, playlistId);
	            UTILS.removeSongFromPlaylist(songId, playlistObj);
	            $songEl.remove();
	        }).catch(function (err) {
	            console.log(err);
	        });
	    });
	
	    $body.on(_events2.default.names.PLAYLIST_ADDED, function (e, playlistObj) {
	        Playlists.add(playlistObj);
	    });
	
	    $body.on(_events2.default.names.PLAYLISTS_UPDATED, _loadPlaylists);
	
	    $body.on(_events2.default.names.PLAYLIST_SONG_ADDED, function (e, payload) {
	        var $playlistDetails = $('#playlist-details');
	        var playlistDetailsId = $playlistDetails.data('playlist-id');
	
	        // Only update UI if playlist is being viewed
	        if (payload.playlistId != playlistDetailsId || !$playlistDetails.hasClass('c--active')) {
	            return;
	        }
	
	        var $songEl = UTILS.songElementFor(UTILS.getObjWithId(SONGS, payload.songId));
	        $('#playlist-song-list').append($songEl[0]);
	    });
	
	    $body.on(_events2.default.names.PLAYLIST_SONG_DELETED, function (e, payload) {
	        var $playlistDetails = $('#playlist-details');
	        var playlistDetailsId = $playlistDetails.data('playlist-id');
	
	        // Only update UI if playlist is being viewed
	        if (payload.playlistId != playlistDetailsId || !$playlistDetails.hasClass('c--active')) {
	            return;
	        }
	
	        $('#playlist-song-list .c-library__item[data-id=' + payload.songId + ']').remove();
	    });
	};
	
	var PlaylistsUI = function PlaylistsUI() {
	    (0, _addPlaylistForm.AddPlaylistFormUI)();
	    _bindEvents();
	};
	
	exports.default = PlaylistsUI;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AddPlaylistFormUI = exports.AddPlaylistForm = undefined;
	
	var _regenerator = __webpack_require__(134);
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _bluebird = __webpack_require__(137);
	
	var _events = __webpack_require__(66);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _request = __webpack_require__(67);
	
	var _request2 = _interopRequireDefault(_request);
	
	var _overlay = __webpack_require__(128);
	
	var _overlay2 = _interopRequireDefault(_overlay);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ADD_BTN_SELECTOR = '.c-add-playlist-form .js-add';
	var CANCEL_BTN_SELECTOR = '.c-add-playlist-form .js-cancel';
	var FORM_CONTAINER_SELECTOR = '.c-add-playlist-form__container';
	var FORM_SELECTOR = '.c-add-playlist-form__container form';
	var NAME_INPUT_SELECTOR = '.js-playlist-name-input';
	var HIDDEN_CLASS = 'u-hidden';
	
	var AddPlaylistForm = {};
	
	AddPlaylistForm.show = function () {
	    // We don't want the content behind the overlay to be scrollable
	    $('body').addClass('u-no-scroll');
	    _overlay2.default.show();
	    $(FORM_CONTAINER_SELECTOR).removeClass(HIDDEN_CLASS);
	    $(NAME_INPUT_SELECTOR).focus();
	};
	
	AddPlaylistForm.hide = function () {
	    $('body').removeClass('u-no-scroll');
	    _overlay2.default.hide();
	};
	
	var _bindEvents = function _bindEvents() {
	    var $nameInput = $(NAME_INPUT_SELECTOR);
	    var dismissFormHandler = function dismissFormHandler(e) {
	        e.stopPropagation();
	        AddPlaylistForm.hide();
	        $nameInput.val('');
	    };
	    var formSubmissionHandler = function () {
	        var _ref = (0, _bluebird.coroutine)(_regenerator2.default.mark(function _callee(e) {
	            var playlist;
	            return _regenerator2.default.wrap(function _callee$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            // Prevent default form submission
	                            e.preventDefault();
	
	                            playlist = {
	                                'name': $nameInput.val()
	                            };
	
	
	                            _request2.default.addNewPlaylist(playlist).then(function (playlistObj) {
	                                playlistObj.songs = playlistObj.songs || [];
	                                PLAYLISTS.push(playlistObj);
	                                $('body').trigger(_events2.default.names.PLAYLIST_ADDED, playlistObj);
	                                dismissFormHandler(e);
	                            }).catch(function (err) {
	                                console.log(err);
	                            });
	
	                        case 3:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, _callee, this);
	        }));
	
	        return function formSubmissionHandler(_x) {
	            return _ref.apply(this, arguments);
	        };
	    }();
	
	    $(FORM_SELECTOR).on('submit', formSubmissionHandler);
	    $(CANCEL_BTN_SELECTOR).on('click', dismissFormHandler);
	    $(ADD_BTN_SELECTOR).on('click', formSubmissionHandler);
	};
	
	var AddPlaylistFormUI = function AddPlaylistFormUI() {
	    _bindEvents();
	};
	
	exports.AddPlaylistForm = AddPlaylistForm;
	exports.AddPlaylistFormUI = AddPlaylistFormUI;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(135);


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__(136);
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };
	
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	
	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	  runtime.AsyncIterator = AsyncIterator;
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      context.method = method;
	      context.arg = arg;
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	
	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;
	
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	
	          context.dispatchException(context.arg);
	
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	
	          return {
	            value: record.arg,
	            done: context.done
	          };
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;
	
	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);
	
	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }
	
	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }
	
	      return ContinueSentinel;
	    }
	
	    var record = tryCatch(method, delegate.iterator, context.arg);
	
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    var info = record.arg;
	
	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;
	
	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;
	
	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }
	
	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }
	
	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.method = "next";
	      this.arg = undefined;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	
	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }
	
	        return !! caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	
	      return this.complete(record);
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	
	      return ContinueSentinel;
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(76)))

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global) {"use strict";
	
	var _getIterator2 = __webpack_require__(138);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _from = __webpack_require__(141);
	
	var _from2 = _interopRequireDefault(_from);
	
	var _iterator = __webpack_require__(145);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(148);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _setImmediate2 = __webpack_require__(163);
	
	var _setImmediate3 = _interopRequireDefault(_setImmediate2);
	
	var _map = __webpack_require__(166);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _getPrototypeOf = __webpack_require__(177);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _getOwnPropertyNames = __webpack_require__(181);
	
	var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);
	
	var _keys = __webpack_require__(184);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _getOwnPropertyDescriptor = __webpack_require__(187);
	
	var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
	
	var _defineProperty = __webpack_require__(190);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	var _freeze = __webpack_require__(193);
	
	var _freeze2 = _interopRequireDefault(_freeze);
	
	var _stringify = __webpack_require__(68);
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _create = __webpack_require__(196);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _promise = __webpack_require__(1);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _typeof2 = __webpack_require__(199);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2015 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 3.4.7
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
	*/
	!function (t) {
	  if ("object" == ( false ? "undefined" : (0, _typeof3.default)(exports)) && "undefined" != typeof module) module.exports = t();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
	    var e;"undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self), e.Promise = t();
	  }
	}(function () {
	  var t, e, n;return function r(t, e, n) {
	    function i(s, a) {
	      if (!e[s]) {
	        if (!t[s]) {
	          var c = "function" == typeof _dereq_ && _dereq_;if (!a && c) return c(s, !0);if (o) return o(s, !0);var l = new Error("Cannot find module '" + s + "'");throw l.code = "MODULE_NOT_FOUND", l;
	        }var u = e[s] = { exports: {} };t[s][0].call(u.exports, function (e) {
	          var n = t[s][1][e];return i(n ? n : e);
	        }, u, u.exports, r, t, e, n);
	      }return e[s].exports;
	    }for (var o = "function" == typeof _dereq_ && _dereq_, s = 0; s < n.length; s++) {
	      i(n[s]);
	    }return i;
	  }({ 1: [function (t, e, n) {
	      "use strict";
	      e.exports = function (t) {
	        function e(t) {
	          var e = new n(t),
	              r = e.promise();return e.setHowMany(1), e.setUnwrap(), e.init(), r;
	        }var n = t._SomePromiseArray;t.any = function (t) {
	          return e(t);
	        }, t.prototype.any = function () {
	          return e(this);
	        };
	      };
	    }, {}], 2: [function (t, e, n) {
	      "use strict";
	      function r() {
	        this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new u(16), this._normalQueue = new u(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;var t = this;this.drainQueues = function () {
	          t._drainQueues();
	        }, this._schedule = l;
	      }function i(t, e, n) {
	        this._lateQueue.push(t, e, n), this._queueTick();
	      }function o(t, e, n) {
	        this._normalQueue.push(t, e, n), this._queueTick();
	      }function s(t) {
	        this._normalQueue._pushOne(t), this._queueTick();
	      }var a;try {
	        throw new Error();
	      } catch (c) {
	        a = c;
	      }var l = t("./schedule"),
	          u = t("./queue"),
	          p = t("./util");r.prototype.setScheduler = function (t) {
	        var e = this._schedule;return this._schedule = t, this._customScheduler = !0, e;
	      }, r.prototype.hasCustomScheduler = function () {
	        return this._customScheduler;
	      }, r.prototype.enableTrampoline = function () {
	        this._trampolineEnabled = !0;
	      }, r.prototype.disableTrampolineIfNecessary = function () {
	        p.hasDevTools && (this._trampolineEnabled = !1);
	      }, r.prototype.haveItemsQueued = function () {
	        return this._isTickUsed || this._haveDrainedQueues;
	      }, r.prototype.fatalError = function (t, e) {
	        e ? (process.stderr.write("Fatal " + (t instanceof Error ? t.stack : t) + "\n"), process.exit(2)) : this.throwLater(t);
	      }, r.prototype.throwLater = function (t, e) {
	        if (1 === arguments.length && (e = t, t = function t() {
	          throw e;
	        }), "undefined" != typeof setTimeout) setTimeout(function () {
	          t(e);
	        }, 0);else try {
	          this._schedule(function () {
	            t(e);
	          });
	        } catch (n) {
	          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
	        }
	      }, p.hasDevTools ? (r.prototype.invokeLater = function (t, e, n) {
	        this._trampolineEnabled ? i.call(this, t, e, n) : this._schedule(function () {
	          setTimeout(function () {
	            t.call(e, n);
	          }, 100);
	        });
	      }, r.prototype.invoke = function (t, e, n) {
	        this._trampolineEnabled ? o.call(this, t, e, n) : this._schedule(function () {
	          t.call(e, n);
	        });
	      }, r.prototype.settlePromises = function (t) {
	        this._trampolineEnabled ? s.call(this, t) : this._schedule(function () {
	          t._settlePromises();
	        });
	      }) : (r.prototype.invokeLater = i, r.prototype.invoke = o, r.prototype.settlePromises = s), r.prototype._drainQueue = function (t) {
	        for (; t.length() > 0;) {
	          var e = t.shift();if ("function" == typeof e) {
	            var n = t.shift(),
	                r = t.shift();e.call(n, r);
	          } else e._settlePromises();
	        }
	      }, r.prototype._drainQueues = function () {
	        this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
	      }, r.prototype._queueTick = function () {
	        this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
	      }, r.prototype._reset = function () {
	        this._isTickUsed = !1;
	      }, e.exports = r, e.exports.firstLineError = a;
	    }, { "./queue": 26, "./schedule": 29, "./util": 36 }], 3: [function (t, e, n) {
	      "use strict";
	      e.exports = function (t, e, n, r) {
	        var i = !1,
	            o = function o(t, e) {
	          this._reject(e);
	        },
	            s = function s(t, e) {
	          e.promiseRejectionQueued = !0, e.bindingPromise._then(o, o, null, this, t);
	        },
	            a = function a(t, e) {
	          0 === (50397184 & this._bitField) && this._resolveCallback(e.target);
	        },
	            c = function c(t, e) {
	          e.promiseRejectionQueued || this._reject(t);
	        };t.prototype.bind = function (o) {
	          i || (i = !0, t.prototype._propagateFrom = r.propagateFromFunction(), t.prototype._boundValue = r.boundValueFunction());var l = n(o),
	              u = new t(e);u._propagateFrom(this, 1);var p = this._target();if (u._setBoundTo(l), l instanceof t) {
	            var h = { promiseRejectionQueued: !1, promise: u, target: p, bindingPromise: l };p._then(e, s, void 0, u, h), l._then(a, c, void 0, u, h), u._setOnCancel(l);
	          } else u._resolveCallback(p);return u;
	        }, t.prototype._setBoundTo = function (t) {
	          void 0 !== t ? (this._bitField = 2097152 | this._bitField, this._boundTo = t) : this._bitField = -2097153 & this._bitField;
	        }, t.prototype._isBound = function () {
	          return 2097152 === (2097152 & this._bitField);
	        }, t.bind = function (e, n) {
	          return t.resolve(n).bind(e);
	        };
	      };
	    }, {}], 4: [function (t, e, n) {
	      "use strict";
	      function r() {
	        try {
	          _promise2.default === o && (Promise = i);
	        } catch (t) {}return o;
	      }var i;"undefined" != typeof _promise2.default && (i = _promise2.default);var o = t("./promise")();o.noConflict = r, e.exports = o;
	    }, { "./promise": 22 }], 5: [function (t, e, n) {
	      "use strict";
	      var r = _create2.default;if (r) {
	        var i = r(null),
	            o = r(null);i[" size"] = o[" size"] = 0;
	      }e.exports = function (e) {
	        function n(t, n) {
	          var r;if (null != t && (r = t[n]), "function" != typeof r) {
	            var i = "Object " + a.classString(t) + " has no method '" + a.toString(n) + "'";throw new e.TypeError(i);
	          }return r;
	        }function r(t) {
	          var e = this.pop(),
	              r = n(t, e);return r.apply(t, this);
	        }function i(t) {
	          return t[this];
	        }function o(t) {
	          var e = +this;return 0 > e && (e = Math.max(0, e + t.length)), t[e];
	        }var s,
	            a = t("./util"),
	            c = a.canEvaluate;a.isIdentifier;e.prototype.call = function (t) {
	          var e = [].slice.call(arguments, 1);return e.push(t), this._then(r, void 0, void 0, e, void 0);
	        }, e.prototype.get = function (t) {
	          var e,
	              n = "number" == typeof t;if (n) e = o;else if (c) {
	            var r = s(t);e = null !== r ? r : i;
	          } else e = i;return this._then(e, void 0, void 0, t, void 0);
	        };
	      };
	    }, { "./util": 36 }], 6: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i) {
	        var o = t("./util"),
	            s = o.tryCatch,
	            a = o.errorObj,
	            c = e._async;e.prototype["break"] = e.prototype.cancel = function () {
	          if (!i.cancellation()) return this._warn("cancellation is disabled");for (var t = this, e = t; t._isCancellable();) {
	            if (!t._cancelBy(e)) {
	              e._isFollowing() ? e._followee().cancel() : e._cancelBranched();break;
	            }var n = t._cancellationParent;if (null == n || !n._isCancellable()) {
	              t._isFollowing() ? t._followee().cancel() : t._cancelBranched();break;
	            }t._isFollowing() && t._followee().cancel(), t._setWillBeCancelled(), e = t, t = n;
	          }
	        }, e.prototype._branchHasCancelled = function () {
	          this._branchesRemainingToCancel--;
	        }, e.prototype._enoughBranchesHaveCancelled = function () {
	          return void 0 === this._branchesRemainingToCancel || this._branchesRemainingToCancel <= 0;
	        }, e.prototype._cancelBy = function (t) {
	          return t === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), this._enoughBranchesHaveCancelled() ? (this._invokeOnCancel(), !0) : !1);
	        }, e.prototype._cancelBranched = function () {
	          this._enoughBranchesHaveCancelled() && this._cancel();
	        }, e.prototype._cancel = function () {
	          this._isCancellable() && (this._setCancelled(), c.invoke(this._cancelPromises, this, void 0));
	        }, e.prototype._cancelPromises = function () {
	          this._length() > 0 && this._settlePromises();
	        }, e.prototype._unsetOnCancel = function () {
	          this._onCancelField = void 0;
	        }, e.prototype._isCancellable = function () {
	          return this.isPending() && !this._isCancelled();
	        }, e.prototype.isCancellable = function () {
	          return this.isPending() && !this.isCancelled();
	        }, e.prototype._doInvokeOnCancel = function (t, e) {
	          if (o.isArray(t)) for (var n = 0; n < t.length; ++n) {
	            this._doInvokeOnCancel(t[n], e);
	          } else if (void 0 !== t) if ("function" == typeof t) {
	            if (!e) {
	              var r = s(t).call(this._boundValue());r === a && (this._attachExtraTrace(r.e), c.throwLater(r.e));
	            }
	          } else t._resultCancelled(this);
	        }, e.prototype._invokeOnCancel = function () {
	          var t = this._onCancel();this._unsetOnCancel(), c.invoke(this._doInvokeOnCancel, this, t);
	        }, e.prototype._invokeInternalOnCancel = function () {
	          this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
	        }, e.prototype._resultCancelled = function () {
	          this.cancel();
	        };
	      };
	    }, { "./util": 36 }], 7: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e) {
	        function n(t, n, a) {
	          return function (c) {
	            var l = a._boundValue();t: for (var u = 0; u < t.length; ++u) {
	              var p = t[u];if (p === Error || null != p && p.prototype instanceof Error) {
	                if (c instanceof p) return o(n).call(l, c);
	              } else if ("function" == typeof p) {
	                var h = o(p).call(l, c);if (h === s) return h;if (h) return o(n).call(l, c);
	              } else if (r.isObject(c)) {
	                for (var f = i(p), _ = 0; _ < f.length; ++_) {
	                  var d = f[_];if (p[d] != c[d]) continue t;
	                }return o(n).call(l, c);
	              }
	            }return e;
	          };
	        }var r = t("./util"),
	            i = t("./es5").keys,
	            o = r.tryCatch,
	            s = r.errorObj;return n;
	      };
	    }, { "./es5": 13, "./util": 36 }], 8: [function (t, e, n) {
	      "use strict";
	      e.exports = function (t) {
	        function e() {
	          this._trace = new e.CapturedTrace(r());
	        }function n() {
	          return i ? new e() : void 0;
	        }function r() {
	          var t = o.length - 1;return t >= 0 ? o[t] : void 0;
	        }var i = !1,
	            o = [];return t.prototype._promiseCreated = function () {}, t.prototype._pushContext = function () {}, t.prototype._popContext = function () {
	          return null;
	        }, t._peekContext = t.prototype._peekContext = function () {}, e.prototype._pushContext = function () {
	          void 0 !== this._trace && (this._trace._promiseCreated = null, o.push(this._trace));
	        }, e.prototype._popContext = function () {
	          if (void 0 !== this._trace) {
	            var t = o.pop(),
	                e = t._promiseCreated;return t._promiseCreated = null, e;
	          }return null;
	        }, e.CapturedTrace = null, e.create = n, e.deactivateLongStackTraces = function () {}, e.activateLongStackTraces = function () {
	          var n = t.prototype._pushContext,
	              o = t.prototype._popContext,
	              s = t._peekContext,
	              a = t.prototype._peekContext,
	              c = t.prototype._promiseCreated;e.deactivateLongStackTraces = function () {
	            t.prototype._pushContext = n, t.prototype._popContext = o, t._peekContext = s, t.prototype._peekContext = a, t.prototype._promiseCreated = c, i = !1;
	          }, i = !0, t.prototype._pushContext = e.prototype._pushContext, t.prototype._popContext = e.prototype._popContext, t._peekContext = t.prototype._peekContext = r, t.prototype._promiseCreated = function () {
	            var t = this._peekContext();t && null == t._promiseCreated && (t._promiseCreated = this);
	          };
	        }, e;
	      };
	    }, {}], 9: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n) {
	        function r(t, e) {
	          return { promise: e };
	        }function i() {
	          return !1;
	        }function o(t, e, n) {
	          var r = this;try {
	            t(e, n, function (t) {
	              if ("function" != typeof t) throw new TypeError("onCancel must be a function, got: " + H.toString(t));r._attachCancellationCallback(t);
	            });
	          } catch (i) {
	            return i;
	          }
	        }function s(t) {
	          if (!this._isCancellable()) return this;var e = this._onCancel();void 0 !== e ? H.isArray(e) ? e.push(t) : this._setOnCancel([e, t]) : this._setOnCancel(t);
	        }function a() {
	          return this._onCancelField;
	        }function c(t) {
	          this._onCancelField = t;
	        }function l() {
	          this._cancellationParent = void 0, this._onCancelField = void 0;
	        }function u(t, e) {
	          if (0 !== (1 & e)) {
	            this._cancellationParent = t;var n = t._branchesRemainingToCancel;void 0 === n && (n = 0), t._branchesRemainingToCancel = n + 1;
	          }0 !== (2 & e) && t._isBound() && this._setBoundTo(t._boundTo);
	        }function p(t, e) {
	          0 !== (2 & e) && t._isBound() && this._setBoundTo(t._boundTo);
	        }function h() {
	          var t = this._boundTo;return void 0 !== t && t instanceof e ? t.isFulfilled() ? t.value() : void 0 : t;
	        }function f() {
	          this._trace = new S(this._peekContext());
	        }function _(t, e) {
	          if (N(t)) {
	            var n = this._trace;if (void 0 !== n && e && (n = n._parent), void 0 !== n) n.attachExtraTrace(t);else if (!t.__stackCleaned__) {
	              var r = j(t);H.notEnumerableProp(t, "stack", r.message + "\n" + r.stack.join("\n")), H.notEnumerableProp(t, "__stackCleaned__", !0);
	            }
	          }
	        }function d(t, e, n, r, i) {
	          if (void 0 === t && null !== e && W) {
	            if (void 0 !== i && i._returnedNonUndefined()) return;if (0 === (65535 & r._bitField)) return;n && (n += " ");var o = "",
	                s = "";if (e._trace) {
	              for (var a = e._trace.stack.split("\n"), c = w(a), l = c.length - 1; l >= 0; --l) {
	                var u = c[l];if (!U.test(u)) {
	                  var p = u.match(M);p && (o = "at " + p[1] + ":" + p[2] + ":" + p[3] + " ");break;
	                }
	              }if (c.length > 0) for (var h = c[0], l = 0; l < a.length; ++l) {
	                if (a[l] === h) {
	                  l > 0 && (s = "\n" + a[l - 1]);break;
	                }
	              }
	            }var f = "a promise was created in a " + n + "handler " + o + "but was not returned from it, see http://goo.gl/rRqMUw" + s;r._warn(f, !0, e);
	          }
	        }function v(t, e) {
	          var n = t + " is deprecated and will be removed in a future version.";return e && (n += " Use " + e + " instead."), y(n);
	        }function y(t, n, r) {
	          if (ot.warnings) {
	            var i,
	                o = new L(t);if (n) r._attachExtraTrace(o);else if (ot.longStackTraces && (i = e._peekContext())) i.attachExtraTrace(o);else {
	              var s = j(o);o.stack = s.message + "\n" + s.stack.join("\n");
	            }tt("warning", o) || E(o, "", !0);
	          }
	        }function m(t, e) {
	          for (var n = 0; n < e.length - 1; ++n) {
	            e[n].push("From previous event:"), e[n] = e[n].join("\n");
	          }return n < e.length && (e[n] = e[n].join("\n")), t + "\n" + e.join("\n");
	        }function g(t) {
	          for (var e = 0; e < t.length; ++e) {
	            (0 === t[e].length || e + 1 < t.length && t[e][0] === t[e + 1][0]) && (t.splice(e, 1), e--);
	          }
	        }function b(t) {
	          for (var e = t[0], n = 1; n < t.length; ++n) {
	            for (var r = t[n], i = e.length - 1, o = e[i], s = -1, a = r.length - 1; a >= 0; --a) {
	              if (r[a] === o) {
	                s = a;break;
	              }
	            }for (var a = s; a >= 0; --a) {
	              var c = r[a];if (e[i] !== c) break;e.pop(), i--;
	            }e = r;
	          }
	        }function w(t) {
	          for (var e = [], n = 0; n < t.length; ++n) {
	            var r = t[n],
	                i = "    (No stack trace)" === r || q.test(r),
	                o = i && nt(r);i && !o && ($ && " " !== r.charAt(0) && (r = "    " + r), e.push(r));
	          }return e;
	        }function C(t) {
	          for (var e = t.stack.replace(/\s+$/g, "").split("\n"), n = 0; n < e.length; ++n) {
	            var r = e[n];if ("    (No stack trace)" === r || q.test(r)) break;
	          }return n > 0 && "SyntaxError" != t.name && (e = e.slice(n)), e;
	        }function j(t) {
	          var e = t.stack,
	              n = t.toString();return e = "string" == typeof e && e.length > 0 ? C(t) : ["    (No stack trace)"], { message: n, stack: "SyntaxError" == t.name ? e : w(e) };
	        }function E(t, e, n) {
	          if ("undefined" != typeof console) {
	            var r;if (H.isObject(t)) {
	              var i = t.stack;r = e + Q(i, t);
	            } else r = e + String(t);"function" == typeof D ? D(r, n) : ("function" == typeof console.log || "object" == (0, _typeof3.default)(console.log)) && console.log(r);
	          }
	        }function k(t, e, n, r) {
	          var i = !1;try {
	            "function" == typeof e && (i = !0, "rejectionHandled" === t ? e(r) : e(n, r));
	          } catch (o) {
	            I.throwLater(o);
	          }"unhandledRejection" === t ? tt(t, n, r) || i || E(n, "Unhandled rejection ") : tt(t, r);
	        }function F(t) {
	          var e;if ("function" == typeof t) e = "[function " + (t.name || "anonymous") + "]";else {
	            e = t && "function" == typeof t.toString ? t.toString() : H.toString(t);var n = /\[object [a-zA-Z0-9$_]+\]/;if (n.test(e)) try {
	              var r = (0, _stringify2.default)(t);e = r;
	            } catch (i) {}0 === e.length && (e = "(empty array)");
	          }return "(<" + x(e) + ">, no stack trace)";
	        }function x(t) {
	          var e = 41;return t.length < e ? t : t.substr(0, e - 3) + "...";
	        }function T() {
	          return "function" == typeof it;
	        }function P(t) {
	          var e = t.match(rt);return e ? { fileName: e[1], line: parseInt(e[2], 10) } : void 0;
	        }function R(t, e) {
	          if (T()) {
	            for (var n, r, i = t.stack.split("\n"), o = e.stack.split("\n"), s = -1, a = -1, c = 0; c < i.length; ++c) {
	              var l = P(i[c]);if (l) {
	                n = l.fileName, s = l.line;break;
	              }
	            }for (var c = 0; c < o.length; ++c) {
	              var l = P(o[c]);if (l) {
	                r = l.fileName, a = l.line;break;
	              }
	            }0 > s || 0 > a || !n || !r || n !== r || s >= a || (nt = function nt(t) {
	              if (B.test(t)) return !0;var e = P(t);return e && e.fileName === n && s <= e.line && e.line <= a ? !0 : !1;
	            });
	          }
	        }function S(t) {
	          this._parent = t, this._promisesCreated = 0;var e = this._length = 1 + (void 0 === t ? 0 : t._length);it(this, S), e > 32 && this.uncycle();
	        }var O,
	            A,
	            D,
	            V = e._getDomain,
	            I = e._async,
	            L = t("./errors").Warning,
	            H = t("./util"),
	            N = H.canAttachTrace,
	            B = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/,
	            U = /\((?:timers\.js):\d+:\d+\)/,
	            M = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/,
	            q = null,
	            Q = null,
	            $ = !1,
	            G = !(0 == H.env("BLUEBIRD_DEBUG") || !H.env("BLUEBIRD_DEBUG") && "development" !== H.env("NODE_ENV")),
	            z = !(0 == H.env("BLUEBIRD_WARNINGS") || !G && !H.env("BLUEBIRD_WARNINGS")),
	            X = !(0 == H.env("BLUEBIRD_LONG_STACK_TRACES") || !G && !H.env("BLUEBIRD_LONG_STACK_TRACES")),
	            W = 0 != H.env("BLUEBIRD_W_FORGOTTEN_RETURN") && (z || !!H.env("BLUEBIRD_W_FORGOTTEN_RETURN"));e.prototype.suppressUnhandledRejections = function () {
	          var t = this._target();t._bitField = -1048577 & t._bitField | 524288;
	        }, e.prototype._ensurePossibleRejectionHandled = function () {
	          0 === (524288 & this._bitField) && (this._setRejectionIsUnhandled(), I.invokeLater(this._notifyUnhandledRejection, this, void 0));
	        }, e.prototype._notifyUnhandledRejectionIsHandled = function () {
	          k("rejectionHandled", O, void 0, this);
	        }, e.prototype._setReturnedNonUndefined = function () {
	          this._bitField = 268435456 | this._bitField;
	        }, e.prototype._returnedNonUndefined = function () {
	          return 0 !== (268435456 & this._bitField);
	        }, e.prototype._notifyUnhandledRejection = function () {
	          if (this._isRejectionUnhandled()) {
	            var t = this._settledValue();this._setUnhandledRejectionIsNotified(), k("unhandledRejection", A, t, this);
	          }
	        }, e.prototype._setUnhandledRejectionIsNotified = function () {
	          this._bitField = 262144 | this._bitField;
	        }, e.prototype._unsetUnhandledRejectionIsNotified = function () {
	          this._bitField = -262145 & this._bitField;
	        }, e.prototype._isUnhandledRejectionNotified = function () {
	          return (262144 & this._bitField) > 0;
	        }, e.prototype._setRejectionIsUnhandled = function () {
	          this._bitField = 1048576 | this._bitField;
	        }, e.prototype._unsetRejectionIsUnhandled = function () {
	          this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
	        }, e.prototype._isRejectionUnhandled = function () {
	          return (1048576 & this._bitField) > 0;
	        }, e.prototype._warn = function (t, e, n) {
	          return y(t, e, n || this);
	        }, e.onPossiblyUnhandledRejection = function (t) {
	          var e = V();A = "function" == typeof t ? null === e ? t : H.domainBind(e, t) : void 0;
	        }, e.onUnhandledRejectionHandled = function (t) {
	          var e = V();O = "function" == typeof t ? null === e ? t : H.domainBind(e, t) : void 0;
	        };var K = function K() {};e.longStackTraces = function () {
	          if (I.haveItemsQueued() && !ot.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");if (!ot.longStackTraces && T()) {
	            var t = e.prototype._captureStackTrace,
	                r = e.prototype._attachExtraTrace;ot.longStackTraces = !0, K = function K() {
	              if (I.haveItemsQueued() && !ot.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");e.prototype._captureStackTrace = t, e.prototype._attachExtraTrace = r, n.deactivateLongStackTraces(), I.enableTrampoline(), ot.longStackTraces = !1;
	            }, e.prototype._captureStackTrace = f, e.prototype._attachExtraTrace = _, n.activateLongStackTraces(), I.disableTrampolineIfNecessary();
	          }
	        }, e.hasLongStackTraces = function () {
	          return ot.longStackTraces && T();
	        };var J = function () {
	          try {
	            if ("function" == typeof CustomEvent) {
	              var t = new CustomEvent("CustomEvent");return H.global.dispatchEvent(t), function (t, e) {
	                var n = new CustomEvent(t.toLowerCase(), { detail: e, cancelable: !0 });return !H.global.dispatchEvent(n);
	              };
	            }if ("function" == typeof Event) {
	              var t = new Event("CustomEvent");return H.global.dispatchEvent(t), function (t, e) {
	                var n = new Event(t.toLowerCase(), { cancelable: !0 });return n.detail = e, !H.global.dispatchEvent(n);
	              };
	            }var t = document.createEvent("CustomEvent");return t.initCustomEvent("testingtheevent", !1, !0, {}), H.global.dispatchEvent(t), function (t, e) {
	              var n = document.createEvent("CustomEvent");return n.initCustomEvent(t.toLowerCase(), !1, !0, e), !H.global.dispatchEvent(n);
	            };
	          } catch (e) {}return function () {
	            return !1;
	          };
	        }(),
	            Y = function () {
	          return H.isNode ? function () {
	            return process.emit.apply(process, arguments);
	          } : H.global ? function (t) {
	            var e = "on" + t.toLowerCase(),
	                n = H.global[e];return n ? (n.apply(H.global, [].slice.call(arguments, 1)), !0) : !1;
	          } : function () {
	            return !1;
	          };
	        }(),
	            Z = { promiseCreated: r, promiseFulfilled: r, promiseRejected: r, promiseResolved: r, promiseCancelled: r, promiseChained: function promiseChained(t, e, n) {
	            return { promise: e, child: n };
	          }, warning: function warning(t, e) {
	            return { warning: e };
	          }, unhandledRejection: function unhandledRejection(t, e, n) {
	            return { reason: e, promise: n };
	          }, rejectionHandled: r },
	            tt = function tt(t) {
	          var e = !1;try {
	            e = Y.apply(null, arguments);
	          } catch (n) {
	            I.throwLater(n), e = !0;
	          }var r = !1;try {
	            r = J(t, Z[t].apply(null, arguments));
	          } catch (n) {
	            I.throwLater(n), r = !0;
	          }return r || e;
	        };e.config = function (t) {
	          if (t = Object(t), "longStackTraces" in t && (t.longStackTraces ? e.longStackTraces() : !t.longStackTraces && e.hasLongStackTraces() && K()), "warnings" in t) {
	            var n = t.warnings;ot.warnings = !!n, W = ot.warnings, H.isObject(n) && "wForgottenReturn" in n && (W = !!n.wForgottenReturn);
	          }if ("cancellation" in t && t.cancellation && !ot.cancellation) {
	            if (I.haveItemsQueued()) throw new Error("cannot enable cancellation after promises are in use");e.prototype._clearCancellationData = l, e.prototype._propagateFrom = u, e.prototype._onCancel = a, e.prototype._setOnCancel = c, e.prototype._attachCancellationCallback = s, e.prototype._execute = o, et = u, ot.cancellation = !0;
	          }return "monitoring" in t && (t.monitoring && !ot.monitoring ? (ot.monitoring = !0, e.prototype._fireEvent = tt) : !t.monitoring && ot.monitoring && (ot.monitoring = !1, e.prototype._fireEvent = i)), e;
	        }, e.prototype._fireEvent = i, e.prototype._execute = function (t, e, n) {
	          try {
	            t(e, n);
	          } catch (r) {
	            return r;
	          }
	        }, e.prototype._onCancel = function () {}, e.prototype._setOnCancel = function (t) {}, e.prototype._attachCancellationCallback = function (t) {}, e.prototype._captureStackTrace = function () {}, e.prototype._attachExtraTrace = function () {}, e.prototype._clearCancellationData = function () {}, e.prototype._propagateFrom = function (t, e) {};var et = p,
	            nt = function nt() {
	          return !1;
	        },
	            rt = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;H.inherits(S, Error), n.CapturedTrace = S, S.prototype.uncycle = function () {
	          var t = this._length;if (!(2 > t)) {
	            for (var e = [], n = {}, r = 0, i = this; void 0 !== i; ++r) {
	              e.push(i), i = i._parent;
	            }t = this._length = r;for (var r = t - 1; r >= 0; --r) {
	              var o = e[r].stack;void 0 === n[o] && (n[o] = r);
	            }for (var r = 0; t > r; ++r) {
	              var s = e[r].stack,
	                  a = n[s];if (void 0 !== a && a !== r) {
	                a > 0 && (e[a - 1]._parent = void 0, e[a - 1]._length = 1), e[r]._parent = void 0, e[r]._length = 1;var c = r > 0 ? e[r - 1] : this;t - 1 > a ? (c._parent = e[a + 1], c._parent.uncycle(), c._length = c._parent._length + 1) : (c._parent = void 0, c._length = 1);for (var l = c._length + 1, u = r - 2; u >= 0; --u) {
	                  e[u]._length = l, l++;
	                }return;
	              }
	            }
	          }
	        }, S.prototype.attachExtraTrace = function (t) {
	          if (!t.__stackCleaned__) {
	            this.uncycle();for (var e = j(t), n = e.message, r = [e.stack], i = this; void 0 !== i;) {
	              r.push(w(i.stack.split("\n"))), i = i._parent;
	            }b(r), g(r), H.notEnumerableProp(t, "stack", m(n, r)), H.notEnumerableProp(t, "__stackCleaned__", !0);
	          }
	        };var it = function () {
	          var t = /^\s*at\s*/,
	              e = function e(t, _e) {
	            return "string" == typeof t ? t : void 0 !== _e.name && void 0 !== _e.message ? _e.toString() : F(_e);
	          };if ("number" == typeof Error.stackTraceLimit && "function" == typeof Error.captureStackTrace) {
	            Error.stackTraceLimit += 6, q = t, Q = e;var n = Error.captureStackTrace;return nt = function nt(t) {
	              return B.test(t);
	            }, function (t, e) {
	              Error.stackTraceLimit += 6, n(t, e), Error.stackTraceLimit -= 6;
	            };
	          }var r = new Error();if ("string" == typeof r.stack && r.stack.split("\n")[0].indexOf("stackDetection@") >= 0) return q = /@/, Q = e, $ = !0, function (t) {
	            t.stack = new Error().stack;
	          };var i;try {
	            throw new Error();
	          } catch (o) {
	            i = "stack" in o;
	          }return "stack" in r || !i || "number" != typeof Error.stackTraceLimit ? (Q = function Q(t, e) {
	            return "string" == typeof t ? t : "object" != (typeof e === "undefined" ? "undefined" : (0, _typeof3.default)(e)) && "function" != typeof e || void 0 === e.name || void 0 === e.message ? F(e) : e.toString();
	          }, null) : (q = t, Q = e, function (t) {
	            Error.stackTraceLimit += 6;try {
	              throw new Error();
	            } catch (e) {
	              t.stack = e.stack;
	            }Error.stackTraceLimit -= 6;
	          });
	        }([]);"undefined" != typeof console && "undefined" != typeof console.warn && (D = function D(t) {
	          console.warn(t);
	        }, H.isNode && process.stderr.isTTY ? D = function D(t, e) {
	          var n = e ? "[33m" : "[31m";console.warn(n + t + "[0m\n");
	        } : H.isNode || "string" != typeof new Error().stack || (D = function D(t, e) {
	          console.warn("%c" + t, e ? "color: darkorange" : "color: red");
	        }));var ot = { warnings: z, longStackTraces: !1, cancellation: !1, monitoring: !1 };return X && e.longStackTraces(), { longStackTraces: function longStackTraces() {
	            return ot.longStackTraces;
	          }, warnings: function warnings() {
	            return ot.warnings;
	          }, cancellation: function cancellation() {
	            return ot.cancellation;
	          }, monitoring: function monitoring() {
	            return ot.monitoring;
	          }, propagateFromFunction: function propagateFromFunction() {
	            return et;
	          }, boundValueFunction: function boundValueFunction() {
	            return h;
	          }, checkForgottenReturns: d, setBounds: R, warn: y, deprecated: v, CapturedTrace: S, fireDomEvent: J, fireGlobalEvent: Y };
	      };
	    }, { "./errors": 12, "./util": 36 }], 10: [function (t, e, n) {
	      "use strict";
	      e.exports = function (t) {
	        function e() {
	          return this.value;
	        }function n() {
	          throw this.reason;
	        }t.prototype["return"] = t.prototype.thenReturn = function (n) {
	          return n instanceof t && n.suppressUnhandledRejections(), this._then(e, void 0, void 0, { value: n }, void 0);
	        }, t.prototype["throw"] = t.prototype.thenThrow = function (t) {
	          return this._then(n, void 0, void 0, { reason: t }, void 0);
	        }, t.prototype.catchThrow = function (t) {
	          if (arguments.length <= 1) return this._then(void 0, n, void 0, { reason: t }, void 0);var e = arguments[1],
	              r = function r() {
	            throw e;
	          };return this.caught(t, r);
	        }, t.prototype.catchReturn = function (n) {
	          if (arguments.length <= 1) return n instanceof t && n.suppressUnhandledRejections(), this._then(void 0, e, void 0, { value: n }, void 0);var r = arguments[1];r instanceof t && r.suppressUnhandledRejections();var i = function i() {
	            return r;
	          };return this.caught(n, i);
	        };
	      };
	    }, {}], 11: [function (t, e, n) {
	      "use strict";
	      e.exports = function (t, e) {
	        function n() {
	          return o(this);
	        }function r(t, n) {
	          return i(t, n, e, e);
	        }var i = t.reduce,
	            o = t.all;t.prototype.each = function (t) {
	          return i(this, t, e, 0)._then(n, void 0, void 0, this, void 0);
	        }, t.prototype.mapSeries = function (t) {
	          return i(this, t, e, e);
	        }, t.each = function (t, r) {
	          return i(t, r, e, 0)._then(n, void 0, void 0, t, void 0);
	        }, t.mapSeries = r;
	      };
	    }, {}], 12: [function (t, e, n) {
	      "use strict";
	      function r(t, e) {
	        function n(r) {
	          return this instanceof n ? (p(this, "message", "string" == typeof r ? r : e), p(this, "name", t), void (Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this))) : new n(r);
	        }return u(n, Error), n;
	      }function i(t) {
	        return this instanceof i ? (p(this, "name", "OperationalError"), p(this, "message", t), this.cause = t, this.isOperational = !0, void (t instanceof Error ? (p(this, "message", t.message), p(this, "stack", t.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor))) : new i(t);
	      }var o,
	          s,
	          a = t("./es5"),
	          c = a.freeze,
	          l = t("./util"),
	          u = l.inherits,
	          p = l.notEnumerableProp,
	          h = r("Warning", "warning"),
	          f = r("CancellationError", "cancellation error"),
	          _ = r("TimeoutError", "timeout error"),
	          d = r("AggregateError", "aggregate error");try {
	        o = TypeError, s = RangeError;
	      } catch (v) {
	        o = r("TypeError", "type error"), s = r("RangeError", "range error");
	      }for (var y = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), m = 0; m < y.length; ++m) {
	        "function" == typeof Array.prototype[y[m]] && (d.prototype[y[m]] = Array.prototype[y[m]]);
	      }a.defineProperty(d.prototype, "length", { value: 0, configurable: !1, writable: !0, enumerable: !0 }), d.prototype.isOperational = !0;var g = 0;d.prototype.toString = function () {
	        var t = Array(4 * g + 1).join(" "),
	            e = "\n" + t + "AggregateError of:\n";g++, t = Array(4 * g + 1).join(" ");for (var n = 0; n < this.length; ++n) {
	          for (var r = this[n] === this ? "[Circular AggregateError]" : this[n] + "", i = r.split("\n"), o = 0; o < i.length; ++o) {
	            i[o] = t + i[o];
	          }r = i.join("\n"), e += r + "\n";
	        }return g--, e;
	      }, u(i, Error);var b = Error.__BluebirdErrorTypes__;b || (b = c({ CancellationError: f, TimeoutError: _, OperationalError: i, RejectionError: i, AggregateError: d }), a.defineProperty(Error, "__BluebirdErrorTypes__", { value: b, writable: !1, enumerable: !1, configurable: !1 })), e.exports = { Error: Error, TypeError: o, RangeError: s, CancellationError: b.CancellationError, OperationalError: b.OperationalError, TimeoutError: b.TimeoutError, AggregateError: b.AggregateError, Warning: h };
	    }, { "./es5": 13, "./util": 36 }], 13: [function (t, e, n) {
	      var r = function () {
	        "use strict";
	        return void 0 === this;
	      }();if (r) e.exports = { freeze: _freeze2.default, defineProperty: _defineProperty2.default, getDescriptor: _getOwnPropertyDescriptor2.default, keys: _keys2.default, names: _getOwnPropertyNames2.default, getPrototypeOf: _getPrototypeOf2.default, isArray: Array.isArray, isES5: r, propertyIsWritable: function propertyIsWritable(t, e) {
	          var n = (0, _getOwnPropertyDescriptor2.default)(t, e);return !(n && !n.writable && !n.set);
	        } };else {
	        var i = {}.hasOwnProperty,
	            o = {}.toString,
	            s = {}.constructor.prototype,
	            a = function a(t) {
	          var e = [];for (var n in t) {
	            i.call(t, n) && e.push(n);
	          }return e;
	        },
	            c = function c(t, e) {
	          return { value: t[e] };
	        },
	            l = function l(t, e, n) {
	          return t[e] = n.value, t;
	        },
	            u = function u(t) {
	          return t;
	        },
	            p = function p(t) {
	          try {
	            return Object(t).constructor.prototype;
	          } catch (e) {
	            return s;
	          }
	        },
	            h = function h(t) {
	          try {
	            return "[object Array]" === o.call(t);
	          } catch (e) {
	            return !1;
	          }
	        };e.exports = { isArray: h, keys: a, names: a, defineProperty: l, getDescriptor: c, freeze: u, getPrototypeOf: p, isES5: r, propertyIsWritable: function propertyIsWritable() {
	            return !0;
	          } };
	      }
	    }, {}], 14: [function (t, e, n) {
	      "use strict";
	      e.exports = function (t, e) {
	        var n = t.map;t.prototype.filter = function (t, r) {
	          return n(this, t, r, e);
	        }, t.filter = function (t, r, i) {
	          return n(t, r, i, e);
	        };
	      };
	    }, {}], 15: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n) {
	        function r(t, e, n) {
	          this.promise = t, this.type = e, this.handler = n, this.called = !1, this.cancelPromise = null;
	        }function i(t) {
	          this.finallyHandler = t;
	        }function o(t, e) {
	          return null != t.cancelPromise ? (arguments.length > 1 ? t.cancelPromise._reject(e) : t.cancelPromise._cancel(), t.cancelPromise = null, !0) : !1;
	        }function s() {
	          return c.call(this, this.promise._target()._settledValue());
	        }function a(t) {
	          return o(this, t) ? void 0 : (p.e = t, p);
	        }function c(t) {
	          var r = this.promise,
	              c = this.handler;if (!this.called) {
	            this.called = !0;var l = this.isFinallyHandler() ? c.call(r._boundValue()) : c.call(r._boundValue(), t);if (void 0 !== l) {
	              r._setReturnedNonUndefined();var h = n(l, r);if (h instanceof e) {
	                if (null != this.cancelPromise) {
	                  if (h._isCancelled()) {
	                    var f = new u("late cancellation observer");return r._attachExtraTrace(f), p.e = f, p;
	                  }h.isPending() && h._attachCancellationCallback(new i(this));
	                }return h._then(s, a, void 0, this, void 0);
	              }
	            }
	          }return r.isRejected() ? (o(this), p.e = t, p) : (o(this), t);
	        }var l = t("./util"),
	            u = e.CancellationError,
	            p = l.errorObj;return r.prototype.isFinallyHandler = function () {
	          return 0 === this.type;
	        }, i.prototype._resultCancelled = function () {
	          o(this.finallyHandler);
	        }, e.prototype._passThrough = function (t, e, n, i) {
	          return "function" != typeof t ? this.then() : this._then(n, i, void 0, new r(this, e, t), void 0);
	        }, e.prototype.lastly = e.prototype["finally"] = function (t) {
	          return this._passThrough(t, 0, c, c);
	        }, e.prototype.tap = function (t) {
	          return this._passThrough(t, 1, c);
	        }, r;
	      };
	    }, { "./util": 36 }], 16: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i, o, s) {
	        function a(t, n, r) {
	          for (var o = 0; o < n.length; ++o) {
	            r._pushContext();var s = f(n[o])(t);if (r._popContext(), s === h) {
	              r._pushContext();var a = e.reject(h.e);return r._popContext(), a;
	            }var c = i(s, r);if (c instanceof e) return c;
	          }return null;
	        }function c(t, n, i, o) {
	          if (s.cancellation()) {
	            var a = new e(r),
	                c = this._finallyPromise = new e(r);this._promise = a.lastly(function () {
	              return c;
	            }), a._captureStackTrace(), a._setOnCancel(this);
	          } else {
	            var l = this._promise = new e(r);l._captureStackTrace();
	          }this._stack = o, this._generatorFunction = t, this._receiver = n, this._generator = void 0, this._yieldHandlers = "function" == typeof i ? [i].concat(_) : _, this._yieldedPromise = null, this._cancellationPhase = !1;
	        }var l = t("./errors"),
	            u = l.TypeError,
	            p = t("./util"),
	            h = p.errorObj,
	            f = p.tryCatch,
	            _ = [];p.inherits(c, o), c.prototype._isResolved = function () {
	          return null === this._promise;
	        }, c.prototype._cleanup = function () {
	          this._promise = this._generator = null, s.cancellation() && null !== this._finallyPromise && (this._finallyPromise._fulfill(), this._finallyPromise = null);
	        }, c.prototype._promiseCancelled = function () {
	          if (!this._isResolved()) {
	            var t,
	                n = "undefined" != typeof this._generator["return"];if (n) this._promise._pushContext(), t = f(this._generator["return"]).call(this._generator, void 0), this._promise._popContext();else {
	              var r = new e.CancellationError("generator .return() sentinel");e.coroutine.returnSentinel = r, this._promise._attachExtraTrace(r), this._promise._pushContext(), t = f(this._generator["throw"]).call(this._generator, r), this._promise._popContext();
	            }this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(t);
	          }
	        }, c.prototype._promiseFulfilled = function (t) {
	          this._yieldedPromise = null, this._promise._pushContext();var e = f(this._generator.next).call(this._generator, t);this._promise._popContext(), this._continue(e);
	        }, c.prototype._promiseRejected = function (t) {
	          this._yieldedPromise = null, this._promise._attachExtraTrace(t), this._promise._pushContext();var e = f(this._generator["throw"]).call(this._generator, t);this._promise._popContext(), this._continue(e);
	        }, c.prototype._resultCancelled = function () {
	          if (this._yieldedPromise instanceof e) {
	            var t = this._yieldedPromise;this._yieldedPromise = null, t.cancel();
	          }
	        }, c.prototype.promise = function () {
	          return this._promise;
	        }, c.prototype._run = function () {
	          this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
	        }, c.prototype._continue = function (t) {
	          var n = this._promise;if (t === h) return this._cleanup(), this._cancellationPhase ? n.cancel() : n._rejectCallback(t.e, !1);var r = t.value;if (t.done === !0) return this._cleanup(), this._cancellationPhase ? n.cancel() : n._resolveCallback(r);var o = i(r, this._promise);if (!(o instanceof e) && (o = a(o, this._yieldHandlers, this._promise), null === o)) return void this._promiseRejected(new u("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", r) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));o = o._target();var s = o._bitField;0 === (50397184 & s) ? (this._yieldedPromise = o, o._proxy(this, null)) : 0 !== (33554432 & s) ? e._async.invoke(this._promiseFulfilled, this, o._value()) : 0 !== (16777216 & s) ? e._async.invoke(this._promiseRejected, this, o._reason()) : this._promiseCancelled();
	        }, e.coroutine = function (t, e) {
	          if ("function" != typeof t) throw new u("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");var n = Object(e).yieldHandler,
	              r = c,
	              i = new Error().stack;return function () {
	            var e = t.apply(this, arguments),
	                o = new r(void 0, void 0, n, i),
	                s = o.promise();return o._generator = e, o._promiseFulfilled(void 0), s;
	          };
	        }, e.coroutine.addYieldHandler = function (t) {
	          if ("function" != typeof t) throw new u("expecting a function but got " + p.classString(t));_.push(t);
	        }, e.spawn = function (t) {
	          if (s.deprecated("Promise.spawn()", "Promise.coroutine()"), "function" != typeof t) return n("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");var r = new c(t, this),
	              i = r.promise();return r._run(e.spawn), i;
	        };
	      };
	    }, { "./errors": 12, "./util": 36 }], 17: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i, o, s) {
	        var a = t("./util");a.canEvaluate, a.tryCatch, a.errorObj;e.join = function () {
	          var t,
	              e = arguments.length - 1;if (e > 0 && "function" == typeof arguments[e]) {
	            t = arguments[e];var r;
	          }var i = [].slice.call(arguments);t && i.pop();var r = new n(i).promise();return void 0 !== t ? r.spread(t) : r;
	        };
	      };
	    }, { "./util": 36 }], 18: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i, o, s) {
	        function a(t, e, n, r) {
	          this.constructor$(t), this._promise._captureStackTrace();var i = l();this._callback = null === i ? e : u.domainBind(i, e), this._preservedValues = r === o ? new Array(this.length()) : null, this._limit = n, this._inFlight = 0, this._queue = [], f.invoke(this._asyncInit, this, void 0);
	        }function c(t, n, i, o) {
	          if ("function" != typeof n) return r("expecting a function but got " + u.classString(n));var s = 0;if (void 0 !== i) {
	            if ("object" != (typeof i === "undefined" ? "undefined" : (0, _typeof3.default)(i)) || null === i) return e.reject(new TypeError("options argument must be an object but it is " + u.classString(i)));if ("number" != typeof i.concurrency) return e.reject(new TypeError("'concurrency' must be a number but it is " + u.classString(i.concurrency)));s = i.concurrency;
	          }return s = "number" == typeof s && isFinite(s) && s >= 1 ? s : 0, new a(t, n, s, o).promise();
	        }var l = e._getDomain,
	            u = t("./util"),
	            p = u.tryCatch,
	            h = u.errorObj,
	            f = e._async;u.inherits(a, n), a.prototype._asyncInit = function () {
	          this._init$(void 0, -2);
	        }, a.prototype._init = function () {}, a.prototype._promiseFulfilled = function (t, n) {
	          var r = this._values,
	              o = this.length(),
	              a = this._preservedValues,
	              c = this._limit;if (0 > n) {
	            if (n = -1 * n - 1, r[n] = t, c >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved())) return !0;
	          } else {
	            if (c >= 1 && this._inFlight >= c) return r[n] = t, this._queue.push(n), !1;null !== a && (a[n] = t);var l = this._promise,
	                u = this._callback,
	                f = l._boundValue();l._pushContext();var _ = p(u).call(f, t, n, o),
	                d = l._popContext();if (s.checkForgottenReturns(_, d, null !== a ? "Promise.filter" : "Promise.map", l), _ === h) return this._reject(_.e), !0;var v = i(_, this._promise);if (v instanceof e) {
	              v = v._target();var y = v._bitField;if (0 === (50397184 & y)) return c >= 1 && this._inFlight++, r[n] = v, v._proxy(this, -1 * (n + 1)), !1;if (0 === (33554432 & y)) return 0 !== (16777216 & y) ? (this._reject(v._reason()), !0) : (this._cancel(), !0);_ = v._value();
	            }r[n] = _;
	          }var m = ++this._totalResolved;return m >= o ? (null !== a ? this._filter(r, a) : this._resolve(r), !0) : !1;
	        }, a.prototype._drainQueue = function () {
	          for (var t = this._queue, e = this._limit, n = this._values; t.length > 0 && this._inFlight < e;) {
	            if (this._isResolved()) return;var r = t.pop();this._promiseFulfilled(n[r], r);
	          }
	        }, a.prototype._filter = function (t, e) {
	          for (var n = e.length, r = new Array(n), i = 0, o = 0; n > o; ++o) {
	            t[o] && (r[i++] = e[o]);
	          }r.length = i, this._resolve(r);
	        }, a.prototype.preservedValues = function () {
	          return this._preservedValues;
	        }, e.prototype.map = function (t, e) {
	          return c(this, t, e, null);
	        }, e.map = function (t, e, n, r) {
	          return c(t, e, n, r);
	        };
	      };
	    }, { "./util": 36 }], 19: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i, o) {
	        var s = t("./util"),
	            a = s.tryCatch;e.method = function (t) {
	          if ("function" != typeof t) throw new e.TypeError("expecting a function but got " + s.classString(t));return function () {
	            var r = new e(n);r._captureStackTrace(), r._pushContext();var i = a(t).apply(this, arguments),
	                s = r._popContext();return o.checkForgottenReturns(i, s, "Promise.method", r), r._resolveFromSyncValue(i), r;
	          };
	        }, e.attempt = e["try"] = function (t) {
	          if ("function" != typeof t) return i("expecting a function but got " + s.classString(t));var r = new e(n);r._captureStackTrace(), r._pushContext();var c;if (arguments.length > 1) {
	            o.deprecated("calling Promise.try with more than 1 argument");var l = arguments[1],
	                u = arguments[2];c = s.isArray(l) ? a(t).apply(u, l) : a(t).call(u, l);
	          } else c = a(t)();var p = r._popContext();return o.checkForgottenReturns(c, p, "Promise.try", r), r._resolveFromSyncValue(c), r;
	        }, e.prototype._resolveFromSyncValue = function (t) {
	          t === s.errorObj ? this._rejectCallback(t.e, !1) : this._resolveCallback(t, !0);
	        };
	      };
	    }, { "./util": 36 }], 20: [function (t, e, n) {
	      "use strict";
	      function r(t) {
	        return t instanceof Error && u.getPrototypeOf(t) === Error.prototype;
	      }function i(t) {
	        var e;if (r(t)) {
	          e = new l(t), e.name = t.name, e.message = t.message, e.stack = t.stack;for (var n = u.keys(t), i = 0; i < n.length; ++i) {
	            var o = n[i];p.test(o) || (e[o] = t[o]);
	          }return e;
	        }return s.markAsOriginatingFromRejection(t), t;
	      }function o(t, e) {
	        return function (n, r) {
	          if (null !== t) {
	            if (n) {
	              var o = i(a(n));t._attachExtraTrace(o), t._reject(o);
	            } else if (e) {
	              var s = [].slice.call(arguments, 1);t._fulfill(s);
	            } else t._fulfill(r);t = null;
	          }
	        };
	      }var s = t("./util"),
	          a = s.maybeWrapAsError,
	          c = t("./errors"),
	          l = c.OperationalError,
	          u = t("./es5"),
	          p = /^(?:name|message|stack|cause)$/;e.exports = o;
	    }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e) {
	        function n(t, e) {
	          var n = this;if (!o.isArray(t)) return r.call(n, t, e);var i = a(e).apply(n._boundValue(), [null].concat(t));i === c && s.throwLater(i.e);
	        }function r(t, e) {
	          var n = this,
	              r = n._boundValue(),
	              i = void 0 === t ? a(e).call(r, null) : a(e).call(r, null, t);i === c && s.throwLater(i.e);
	        }function i(t, e) {
	          var n = this;if (!t) {
	            var r = new Error(t + "");r.cause = t, t = r;
	          }var i = a(e).call(n._boundValue(), t);i === c && s.throwLater(i.e);
	        }var o = t("./util"),
	            s = e._async,
	            a = o.tryCatch,
	            c = o.errorObj;e.prototype.asCallback = e.prototype.nodeify = function (t, e) {
	          if ("function" == typeof t) {
	            var o = r;void 0 !== e && Object(e).spread && (o = n), this._then(o, i, void 0, this, t);
	          }return this;
	        };
	      };
	    }, { "./util": 36 }], 22: [function (t, e, n) {
	      "use strict";
	      e.exports = function () {
	        function n() {}function r(t, e) {
	          if ("function" != typeof e) throw new m("expecting a function but got " + f.classString(e));if (t.constructor !== i) throw new m("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
	        }function i(t) {
	          this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, t !== b && (r(this, t), this._resolveFromExecutor(t)), this._promiseCreated(), this._fireEvent("promiseCreated", this);
	        }function o(t) {
	          this.promise._resolveCallback(t);
	        }function s(t) {
	          this.promise._rejectCallback(t, !1);
	        }function a(t) {
	          var e = new i(b);e._fulfillmentHandler0 = t, e._rejectionHandler0 = t, e._promise0 = t, e._receiver0 = t;
	        }var c,
	            l = function l() {
	          return new m("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
	        },
	            u = function u() {
	          return new i.PromiseInspection(this._target());
	        },
	            p = function p(t) {
	          return i.reject(new m(t));
	        },
	            h = {},
	            f = t("./util");c = f.isNode ? function () {
	          var t = process.domain;return void 0 === t && (t = null), t;
	        } : function () {
	          return null;
	        }, f.notEnumerableProp(i, "_getDomain", c);var _ = t("./es5"),
	            d = t("./async"),
	            v = new d();_.defineProperty(i, "_async", { value: v });var y = t("./errors"),
	            m = i.TypeError = y.TypeError;i.RangeError = y.RangeError;var g = i.CancellationError = y.CancellationError;i.TimeoutError = y.TimeoutError, i.OperationalError = y.OperationalError, i.RejectionError = y.OperationalError, i.AggregateError = y.AggregateError;var b = function b() {},
	            w = {},
	            C = {},
	            j = t("./thenables")(i, b),
	            E = t("./promise_array")(i, b, j, p, n),
	            k = t("./context")(i),
	            F = k.create,
	            x = t("./debuggability")(i, k),
	            T = (x.CapturedTrace, t("./finally")(i, j)),
	            P = t("./catch_filter")(C),
	            R = t("./nodeback"),
	            S = f.errorObj,
	            O = f.tryCatch;return i.prototype.toString = function () {
	          return "[object Promise]";
	        }, i.prototype.caught = i.prototype["catch"] = function (t) {
	          var e = arguments.length;if (e > 1) {
	            var n,
	                r = new Array(e - 1),
	                i = 0;for (n = 0; e - 1 > n; ++n) {
	              var o = arguments[n];if (!f.isObject(o)) return p("expecting an object but got A catch statement predicate " + f.classString(o));r[i++] = o;
	            }return r.length = i, t = arguments[n], this.then(void 0, P(r, t, this));
	          }return this.then(void 0, t);
	        }, i.prototype.reflect = function () {
	          return this._then(u, u, void 0, this, void 0);
	        }, i.prototype.then = function (t, e) {
	          if (x.warnings() && arguments.length > 0 && "function" != typeof t && "function" != typeof e) {
	            var n = ".then() only accepts functions but was passed: " + f.classString(t);arguments.length > 1 && (n += ", " + f.classString(e)), this._warn(n);
	          }return this._then(t, e, void 0, void 0, void 0);
	        }, i.prototype.done = function (t, e) {
	          var n = this._then(t, e, void 0, void 0, void 0);n._setIsFinal();
	        }, i.prototype.spread = function (t) {
	          return "function" != typeof t ? p("expecting a function but got " + f.classString(t)) : this.all()._then(t, void 0, void 0, w, void 0);
	        }, i.prototype.toJSON = function () {
	          var t = { isFulfilled: !1, isRejected: !1, fulfillmentValue: void 0, rejectionReason: void 0 };return this.isFulfilled() ? (t.fulfillmentValue = this.value(), t.isFulfilled = !0) : this.isRejected() && (t.rejectionReason = this.reason(), t.isRejected = !0), t;
	        }, i.prototype.all = function () {
	          return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new E(this).promise();
	        }, i.prototype.error = function (t) {
	          return this.caught(f.originatesFromRejection, t);
	        }, i.getNewLibraryCopy = e.exports, i.is = function (t) {
	          return t instanceof i;
	        }, i.fromNode = i.fromCallback = function (t) {
	          var e = new i(b);e._captureStackTrace();var n = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : !1,
	              r = O(t)(R(e, n));return r === S && e._rejectCallback(r.e, !0), e._isFateSealed() || e._setAsyncGuaranteed(), e;
	        }, i.all = function (t) {
	          return new E(t).promise();
	        }, i.cast = function (t) {
	          var e = j(t);return e instanceof i || (e = new i(b), e._captureStackTrace(), e._setFulfilled(), e._rejectionHandler0 = t), e;
	        }, i.resolve = i.fulfilled = i.cast, i.reject = i.rejected = function (t) {
	          var e = new i(b);return e._captureStackTrace(), e._rejectCallback(t, !0), e;
	        }, i.setScheduler = function (t) {
	          if ("function" != typeof t) throw new m("expecting a function but got " + f.classString(t));return v.setScheduler(t);
	        }, i.prototype._then = function (t, e, n, r, o) {
	          var s = void 0 !== o,
	              a = s ? o : new i(b),
	              l = this._target(),
	              u = l._bitField;s || (a._propagateFrom(this, 3), a._captureStackTrace(), void 0 === r && 0 !== (2097152 & this._bitField) && (r = 0 !== (50397184 & u) ? this._boundValue() : l === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, a));var p = c();if (0 !== (50397184 & u)) {
	            var h,
	                _,
	                d = l._settlePromiseCtx;0 !== (33554432 & u) ? (_ = l._rejectionHandler0, h = t) : 0 !== (16777216 & u) ? (_ = l._fulfillmentHandler0, h = e, l._unsetRejectionIsUnhandled()) : (d = l._settlePromiseLateCancellationObserver, _ = new g("late cancellation observer"), l._attachExtraTrace(_), h = e), v.invoke(d, l, { handler: null === p ? h : "function" == typeof h && f.domainBind(p, h), promise: a, receiver: r, value: _ });
	          } else l._addCallbacks(t, e, a, r, p);return a;
	        }, i.prototype._length = function () {
	          return 65535 & this._bitField;
	        }, i.prototype._isFateSealed = function () {
	          return 0 !== (117506048 & this._bitField);
	        }, i.prototype._isFollowing = function () {
	          return 67108864 === (67108864 & this._bitField);
	        }, i.prototype._setLength = function (t) {
	          this._bitField = -65536 & this._bitField | 65535 & t;
	        }, i.prototype._setFulfilled = function () {
	          this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this);
	        }, i.prototype._setRejected = function () {
	          this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this);
	        }, i.prototype._setFollowing = function () {
	          this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this);
	        }, i.prototype._setIsFinal = function () {
	          this._bitField = 4194304 | this._bitField;
	        }, i.prototype._isFinal = function () {
	          return (4194304 & this._bitField) > 0;
	        }, i.prototype._unsetCancelled = function () {
	          this._bitField = -65537 & this._bitField;
	        }, i.prototype._setCancelled = function () {
	          this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this);
	        }, i.prototype._setWillBeCancelled = function () {
	          this._bitField = 8388608 | this._bitField;
	        }, i.prototype._setAsyncGuaranteed = function () {
	          v.hasCustomScheduler() || (this._bitField = 134217728 | this._bitField);
	        }, i.prototype._receiverAt = function (t) {
	          var e = 0 === t ? this._receiver0 : this[4 * t - 4 + 3];return e === h ? void 0 : void 0 === e && this._isBound() ? this._boundValue() : e;
	        }, i.prototype._promiseAt = function (t) {
	          return this[4 * t - 4 + 2];
	        }, i.prototype._fulfillmentHandlerAt = function (t) {
	          return this[4 * t - 4 + 0];
	        }, i.prototype._rejectionHandlerAt = function (t) {
	          return this[4 * t - 4 + 1];
	        }, i.prototype._boundValue = function () {}, i.prototype._migrateCallback0 = function (t) {
	          var e = (t._bitField, t._fulfillmentHandler0),
	              n = t._rejectionHandler0,
	              r = t._promise0,
	              i = t._receiverAt(0);void 0 === i && (i = h), this._addCallbacks(e, n, r, i, null);
	        }, i.prototype._migrateCallbackAt = function (t, e) {
	          var n = t._fulfillmentHandlerAt(e),
	              r = t._rejectionHandlerAt(e),
	              i = t._promiseAt(e),
	              o = t._receiverAt(e);void 0 === o && (o = h), this._addCallbacks(n, r, i, o, null);
	        }, i.prototype._addCallbacks = function (t, e, n, r, i) {
	          var o = this._length();if (o >= 65531 && (o = 0, this._setLength(0)), 0 === o) this._promise0 = n, this._receiver0 = r, "function" == typeof t && (this._fulfillmentHandler0 = null === i ? t : f.domainBind(i, t)), "function" == typeof e && (this._rejectionHandler0 = null === i ? e : f.domainBind(i, e));else {
	            var s = 4 * o - 4;this[s + 2] = n, this[s + 3] = r, "function" == typeof t && (this[s + 0] = null === i ? t : f.domainBind(i, t)), "function" == typeof e && (this[s + 1] = null === i ? e : f.domainBind(i, e));
	          }return this._setLength(o + 1), o;
	        }, i.prototype._proxy = function (t, e) {
	          this._addCallbacks(void 0, void 0, e, t, null);
	        }, i.prototype._resolveCallback = function (t, e) {
	          if (0 === (117506048 & this._bitField)) {
	            if (t === this) return this._rejectCallback(l(), !1);var n = j(t, this);if (!(n instanceof i)) return this._fulfill(t);e && this._propagateFrom(n, 2);var r = n._target();if (r === this) return void this._reject(l());var o = r._bitField;if (0 === (50397184 & o)) {
	              var s = this._length();s > 0 && r._migrateCallback0(this);for (var a = 1; s > a; ++a) {
	                r._migrateCallbackAt(this, a);
	              }this._setFollowing(), this._setLength(0), this._setFollowee(r);
	            } else if (0 !== (33554432 & o)) this._fulfill(r._value());else if (0 !== (16777216 & o)) this._reject(r._reason());else {
	              var c = new g("late cancellation observer");r._attachExtraTrace(c), this._reject(c);
	            }
	          }
	        }, i.prototype._rejectCallback = function (t, e, n) {
	          var r = f.ensureErrorObject(t),
	              i = r === t;if (!i && !n && x.warnings()) {
	            var o = "a promise was rejected with a non-error: " + f.classString(t);this._warn(o, !0);
	          }this._attachExtraTrace(r, e ? i : !1), this._reject(t);
	        }, i.prototype._resolveFromExecutor = function (t) {
	          var e = this;this._captureStackTrace(), this._pushContext();var n = !0,
	              r = this._execute(t, function (t) {
	            e._resolveCallback(t);
	          }, function (t) {
	            e._rejectCallback(t, n);
	          });n = !1, this._popContext(), void 0 !== r && e._rejectCallback(r, !0);
	        }, i.prototype._settlePromiseFromHandler = function (t, e, n, r) {
	          var i = r._bitField;if (0 === (65536 & i)) {
	            r._pushContext();var o;e === w ? n && "number" == typeof n.length ? o = O(t).apply(this._boundValue(), n) : (o = S, o.e = new m("cannot .spread() a non-array: " + f.classString(n))) : o = O(t).call(e, n);var s = r._popContext();i = r._bitField, 0 === (65536 & i) && (o === C ? r._reject(n) : o === S ? r._rejectCallback(o.e, !1) : (x.checkForgottenReturns(o, s, "", r, this), r._resolveCallback(o)));
	          }
	        }, i.prototype._target = function () {
	          for (var t = this; t._isFollowing();) {
	            t = t._followee();
	          }return t;
	        }, i.prototype._followee = function () {
	          return this._rejectionHandler0;
	        }, i.prototype._setFollowee = function (t) {
	          this._rejectionHandler0 = t;
	        }, i.prototype._settlePromise = function (t, e, r, o) {
	          var s = t instanceof i,
	              a = this._bitField,
	              c = 0 !== (134217728 & a);0 !== (65536 & a) ? (s && t._invokeInternalOnCancel(), r instanceof T && r.isFinallyHandler() ? (r.cancelPromise = t, O(e).call(r, o) === S && t._reject(S.e)) : e === u ? t._fulfill(u.call(r)) : r instanceof n ? r._promiseCancelled(t) : s || t instanceof E ? t._cancel() : r.cancel()) : "function" == typeof e ? s ? (c && t._setAsyncGuaranteed(), this._settlePromiseFromHandler(e, r, o, t)) : e.call(r, o, t) : r instanceof n ? r._isResolved() || (0 !== (33554432 & a) ? r._promiseFulfilled(o, t) : r._promiseRejected(o, t)) : s && (c && t._setAsyncGuaranteed(), 0 !== (33554432 & a) ? t._fulfill(o) : t._reject(o));
	        }, i.prototype._settlePromiseLateCancellationObserver = function (t) {
	          var e = t.handler,
	              n = t.promise,
	              r = t.receiver,
	              o = t.value;"function" == typeof e ? n instanceof i ? this._settlePromiseFromHandler(e, r, o, n) : e.call(r, o, n) : n instanceof i && n._reject(o);
	        }, i.prototype._settlePromiseCtx = function (t) {
	          this._settlePromise(t.promise, t.handler, t.receiver, t.value);
	        }, i.prototype._settlePromise0 = function (t, e, n) {
	          var r = this._promise0,
	              i = this._receiverAt(0);this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(r, t, i, e);
	        }, i.prototype._clearCallbackDataAtIndex = function (t) {
	          var e = 4 * t - 4;this[e + 2] = this[e + 3] = this[e + 0] = this[e + 1] = void 0;
	        }, i.prototype._fulfill = function (t) {
	          var e = this._bitField;if (!((117506048 & e) >>> 16)) {
	            if (t === this) {
	              var n = l();return this._attachExtraTrace(n), this._reject(n);
	            }this._setFulfilled(), this._rejectionHandler0 = t, (65535 & e) > 0 && (0 !== (134217728 & e) ? this._settlePromises() : v.settlePromises(this));
	          }
	        }, i.prototype._reject = function (t) {
	          var e = this._bitField;if (!((117506048 & e) >>> 16)) return this._setRejected(), this._fulfillmentHandler0 = t, this._isFinal() ? v.fatalError(t, f.isNode) : void ((65535 & e) > 0 ? v.settlePromises(this) : this._ensurePossibleRejectionHandled());
	        }, i.prototype._fulfillPromises = function (t, e) {
	          for (var n = 1; t > n; n++) {
	            var r = this._fulfillmentHandlerAt(n),
	                i = this._promiseAt(n),
	                o = this._receiverAt(n);this._clearCallbackDataAtIndex(n), this._settlePromise(i, r, o, e);
	          }
	        }, i.prototype._rejectPromises = function (t, e) {
	          for (var n = 1; t > n; n++) {
	            var r = this._rejectionHandlerAt(n),
	                i = this._promiseAt(n),
	                o = this._receiverAt(n);this._clearCallbackDataAtIndex(n), this._settlePromise(i, r, o, e);
	          }
	        }, i.prototype._settlePromises = function () {
	          var t = this._bitField,
	              e = 65535 & t;if (e > 0) {
	            if (0 !== (16842752 & t)) {
	              var n = this._fulfillmentHandler0;this._settlePromise0(this._rejectionHandler0, n, t), this._rejectPromises(e, n);
	            } else {
	              var r = this._rejectionHandler0;this._settlePromise0(this._fulfillmentHandler0, r, t), this._fulfillPromises(e, r);
	            }this._setLength(0);
	          }this._clearCancellationData();
	        }, i.prototype._settledValue = function () {
	          var t = this._bitField;return 0 !== (33554432 & t) ? this._rejectionHandler0 : 0 !== (16777216 & t) ? this._fulfillmentHandler0 : void 0;
	        }, i.defer = i.pending = function () {
	          x.deprecated("Promise.defer", "new Promise");var t = new i(b);return { promise: t, resolve: o, reject: s };
	        }, f.notEnumerableProp(i, "_makeSelfResolutionError", l), t("./method")(i, b, j, p, x), t("./bind")(i, b, j, x), t("./cancel")(i, E, p, x), t("./direct_resolve")(i), t("./synchronous_inspection")(i), t("./join")(i, E, j, b, v, c), i.Promise = i, i.version = "3.4.7", t("./map.js")(i, E, p, j, b, x), t("./call_get.js")(i), t("./using.js")(i, p, j, F, b, x), t("./timers.js")(i, b, x), t("./generators.js")(i, p, b, j, n, x), t("./nodeify.js")(i), t("./promisify.js")(i, b), t("./props.js")(i, E, j, p), t("./race.js")(i, b, j, p), t("./reduce.js")(i, E, p, j, b, x), t("./settle.js")(i, E, x), t("./some.js")(i, E, p), t("./filter.js")(i, b), t("./each.js")(i, b), t("./any.js")(i), f.toFastProperties(i), f.toFastProperties(i.prototype), a({ a: 1 }), a({ b: 2 }), a({ c: 3 }), a(1), a(function () {}), a(void 0), a(!1), a(new i(b)), x.setBounds(d.firstLineError, f.lastLineError), i;
	      };
	    }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36 }], 23: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i, o) {
	        function s(t) {
	          switch (t) {case -2:
	              return [];case -3:
	              return {};}
	        }function a(t) {
	          var r = this._promise = new e(n);t instanceof e && r._propagateFrom(t, 3), r._setOnCancel(this), this._values = t, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
	        }var c = t("./util");c.isArray;return c.inherits(a, o), a.prototype.length = function () {
	          return this._length;
	        }, a.prototype.promise = function () {
	          return this._promise;
	        }, a.prototype._init = function l(t, n) {
	          var o = r(this._values, this._promise);if (o instanceof e) {
	            o = o._target();var a = o._bitField;if (this._values = o, 0 === (50397184 & a)) return this._promise._setAsyncGuaranteed(), o._then(l, this._reject, void 0, this, n);if (0 === (33554432 & a)) return 0 !== (16777216 & a) ? this._reject(o._reason()) : this._cancel();o = o._value();
	          }if (o = c.asArray(o), null === o) {
	            var u = i("expecting an array or an iterable object but got " + c.classString(o)).reason();return void this._promise._rejectCallback(u, !1);
	          }return 0 === o.length ? void (-5 === n ? this._resolveEmptyArray() : this._resolve(s(n))) : void this._iterate(o);
	        }, a.prototype._iterate = function (t) {
	          var n = this.getActualLength(t.length);this._length = n, this._values = this.shouldCopyValues() ? new Array(n) : this._values;for (var i = this._promise, o = !1, s = null, a = 0; n > a; ++a) {
	            var c = r(t[a], i);c instanceof e ? (c = c._target(), s = c._bitField) : s = null, o ? null !== s && c.suppressUnhandledRejections() : null !== s ? 0 === (50397184 & s) ? (c._proxy(this, a), this._values[a] = c) : o = 0 !== (33554432 & s) ? this._promiseFulfilled(c._value(), a) : 0 !== (16777216 & s) ? this._promiseRejected(c._reason(), a) : this._promiseCancelled(a) : o = this._promiseFulfilled(c, a);
	          }o || i._setAsyncGuaranteed();
	        }, a.prototype._isResolved = function () {
	          return null === this._values;
	        }, a.prototype._resolve = function (t) {
	          this._values = null, this._promise._fulfill(t);
	        }, a.prototype._cancel = function () {
	          !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel());
	        }, a.prototype._reject = function (t) {
	          this._values = null, this._promise._rejectCallback(t, !1);
	        }, a.prototype._promiseFulfilled = function (t, e) {
	          this._values[e] = t;var n = ++this._totalResolved;return n >= this._length ? (this._resolve(this._values), !0) : !1;
	        }, a.prototype._promiseCancelled = function () {
	          return this._cancel(), !0;
	        }, a.prototype._promiseRejected = function (t) {
	          return this._totalResolved++, this._reject(t), !0;
	        }, a.prototype._resultCancelled = function () {
	          if (!this._isResolved()) {
	            var t = this._values;if (this._cancel(), t instanceof e) t.cancel();else for (var n = 0; n < t.length; ++n) {
	              t[n] instanceof e && t[n].cancel();
	            }
	          }
	        }, a.prototype.shouldCopyValues = function () {
	          return !0;
	        }, a.prototype.getActualLength = function (t) {
	          return t;
	        }, a;
	      };
	    }, { "./util": 36 }], 24: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n) {
	        function r(t) {
	          return !C.test(t);
	        }function i(t) {
	          try {
	            return t.__isPromisified__ === !0;
	          } catch (e) {
	            return !1;
	          }
	        }function o(t, e, n) {
	          var r = f.getDataPropertyOrDefault(t, e + n, b);return r ? i(r) : !1;
	        }function s(t, e, n) {
	          for (var r = 0; r < t.length; r += 2) {
	            var i = t[r];if (n.test(i)) for (var o = i.replace(n, ""), s = 0; s < t.length; s += 2) {
	              if (t[s] === o) throw new m("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", e));
	            }
	          }
	        }function a(t, e, n, r) {
	          for (var a = f.inheritedDataKeys(t), c = [], l = 0; l < a.length; ++l) {
	            var u = a[l],
	                p = t[u],
	                h = r === j ? !0 : j(u, p, t);"function" != typeof p || i(p) || o(t, u, e) || !r(u, p, t, h) || c.push(u, p);
	          }return s(c, e, n), c;
	        }function c(t, r, i, o, s, a) {
	          function c() {
	            var i = r;r === h && (i = this);var o = new e(n);o._captureStackTrace();var s = "string" == typeof u && this !== l ? this[u] : t,
	                c = _(o, a);try {
	              s.apply(i, d(arguments, c));
	            } catch (p) {
	              o._rejectCallback(v(p), !0, !0);
	            }return o._isFateSealed() || o._setAsyncGuaranteed(), o;
	          }var l = function () {
	            return this;
	          }(),
	              u = t;return "string" == typeof u && (t = o), f.notEnumerableProp(c, "__isPromisified__", !0), c;
	        }function l(t, e, n, r, i) {
	          for (var o = new RegExp(E(e) + "$"), s = a(t, e, o, n), c = 0, l = s.length; l > c; c += 2) {
	            var u = s[c],
	                p = s[c + 1],
	                _ = u + e;if (r === k) t[_] = k(u, h, u, p, e, i);else {
	              var d = r(p, function () {
	                return k(u, h, u, p, e, i);
	              });f.notEnumerableProp(d, "__isPromisified__", !0), t[_] = d;
	            }
	          }return f.toFastProperties(t), t;
	        }function u(t, e, n) {
	          return k(t, e, void 0, t, null, n);
	        }var p,
	            h = {},
	            f = t("./util"),
	            _ = t("./nodeback"),
	            d = f.withAppended,
	            v = f.maybeWrapAsError,
	            y = f.canEvaluate,
	            m = t("./errors").TypeError,
	            g = "Async",
	            b = { __isPromisified__: !0 },
	            w = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"],
	            C = new RegExp("^(?:" + w.join("|") + ")$"),
	            j = function j(t) {
	          return f.isIdentifier(t) && "_" !== t.charAt(0) && "constructor" !== t;
	        },
	            E = function E(t) {
	          return t.replace(/([$])/, "\\$");
	        },
	            k = y ? p : c;e.promisify = function (t, e) {
	          if ("function" != typeof t) throw new m("expecting a function but got " + f.classString(t));if (i(t)) return t;e = Object(e);var n = void 0 === e.context ? h : e.context,
	              o = !!e.multiArgs,
	              s = u(t, n, o);return f.copyDescriptors(t, s, r), s;
	        }, e.promisifyAll = function (t, e) {
	          if ("function" != typeof t && "object" != (typeof t === "undefined" ? "undefined" : (0, _typeof3.default)(t))) throw new m("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");e = Object(e);var n = !!e.multiArgs,
	              r = e.suffix;"string" != typeof r && (r = g);var i = e.filter;"function" != typeof i && (i = j);var o = e.promisifier;if ("function" != typeof o && (o = k), !f.isIdentifier(r)) throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");for (var s = f.inheritedDataKeys(t), a = 0; a < s.length; ++a) {
	            var c = t[s[a]];"constructor" !== s[a] && f.isClass(c) && (l(c.prototype, r, i, o, n), l(c, r, i, o, n));
	          }return l(t, r, i, o, n);
	        };
	      };
	    }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i) {
	        function o(t) {
	          var e,
	              n = !1;if (void 0 !== a && t instanceof a) e = p(t), n = !0;else {
	            var r = u.keys(t),
	                i = r.length;e = new Array(2 * i);for (var o = 0; i > o; ++o) {
	              var s = r[o];e[o] = t[s], e[o + i] = s;
	            }
	          }this.constructor$(e), this._isMap = n, this._init$(void 0, -3);
	        }function s(t) {
	          var n,
	              s = r(t);return l(s) ? (n = s instanceof e ? s._then(e.props, void 0, void 0, void 0, void 0) : new o(s).promise(), s instanceof e && n._propagateFrom(s, 2), n) : i("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
	        }var a,
	            c = t("./util"),
	            l = c.isObject,
	            u = t("./es5");"function" == typeof _map2.default && (a = _map2.default);var p = function () {
	          function t(t, r) {
	            this[e] = t, this[e + n] = r, e++;
	          }var e = 0,
	              n = 0;return function (r) {
	            n = r.size, e = 0;var i = new Array(2 * r.size);return r.forEach(t, i), i;
	          };
	        }(),
	            h = function h(t) {
	          for (var e = new a(), n = t.length / 2 | 0, r = 0; n > r; ++r) {
	            var i = t[n + r],
	                o = t[r];e.set(i, o);
	          }return e;
	        };c.inherits(o, n), o.prototype._init = function () {}, o.prototype._promiseFulfilled = function (t, e) {
	          this._values[e] = t;var n = ++this._totalResolved;if (n >= this._length) {
	            var r;if (this._isMap) r = h(this._values);else {
	              r = {};for (var i = this.length(), o = 0, s = this.length(); s > o; ++o) {
	                r[this._values[o + i]] = this._values[o];
	              }
	            }return this._resolve(r), !0;
	          }return !1;
	        }, o.prototype.shouldCopyValues = function () {
	          return !1;
	        }, o.prototype.getActualLength = function (t) {
	          return t >> 1;
	        }, e.prototype.props = function () {
	          return s(this);
	        }, e.props = function (t) {
	          return s(t);
	        };
	      };
	    }, { "./es5": 13, "./util": 36 }], 26: [function (t, e, n) {
	      "use strict";
	      function r(t, e, n, r, i) {
	        for (var o = 0; i > o; ++o) {
	          n[o + r] = t[o + e], t[o + e] = void 0;
	        }
	      }function i(t) {
	        this._capacity = t, this._length = 0, this._front = 0;
	      }i.prototype._willBeOverCapacity = function (t) {
	        return this._capacity < t;
	      }, i.prototype._pushOne = function (t) {
	        var e = this.length();this._checkCapacity(e + 1);var n = this._front + e & this._capacity - 1;this[n] = t, this._length = e + 1;
	      }, i.prototype.push = function (t, e, n) {
	        var r = this.length() + 3;if (this._willBeOverCapacity(r)) return this._pushOne(t), this._pushOne(e), void this._pushOne(n);var i = this._front + r - 3;this._checkCapacity(r);var o = this._capacity - 1;this[i + 0 & o] = t, this[i + 1 & o] = e, this[i + 2 & o] = n, this._length = r;
	      }, i.prototype.shift = function () {
	        var t = this._front,
	            e = this[t];return this[t] = void 0, this._front = t + 1 & this._capacity - 1, this._length--, e;
	      }, i.prototype.length = function () {
	        return this._length;
	      }, i.prototype._checkCapacity = function (t) {
	        this._capacity < t && this._resizeTo(this._capacity << 1);
	      }, i.prototype._resizeTo = function (t) {
	        var e = this._capacity;this._capacity = t;var n = this._front,
	            i = this._length,
	            o = n + i & e - 1;r(this, 0, this, e, o);
	      }, e.exports = i;
	    }, {}], 27: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i) {
	        function o(t, o) {
	          var c = r(t);if (c instanceof e) return a(c);if (t = s.asArray(t), null === t) return i("expecting an array or an iterable object but got " + s.classString(t));var l = new e(n);void 0 !== o && l._propagateFrom(o, 3);for (var u = l._fulfill, p = l._reject, h = 0, f = t.length; f > h; ++h) {
	            var _ = t[h];(void 0 !== _ || h in t) && e.cast(_)._then(u, p, void 0, l, null);
	          }return l;
	        }var s = t("./util"),
	            a = function a(t) {
	          return t.then(function (e) {
	            return o(e, t);
	          });
	        };e.race = function (t) {
	          return o(t, void 0);
	        }, e.prototype.race = function () {
	          return o(this, void 0);
	        };
	      };
	    }, { "./util": 36 }], 28: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i, o, s) {
	        function a(t, n, r, i) {
	          this.constructor$(t);var s = h();this._fn = null === s ? n : f.domainBind(s, n), void 0 !== r && (r = e.resolve(r), r._attachCancellationCallback(this)), this._initialValue = r, this._currentCancellable = null, i === o ? this._eachValues = Array(this._length) : 0 === i ? this._eachValues = null : this._eachValues = void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
	        }function c(t, e) {
	          this.isFulfilled() ? e._resolve(t) : e._reject(t);
	        }function l(t, e, n, i) {
	          if ("function" != typeof e) return r("expecting a function but got " + f.classString(e));var o = new a(t, e, n, i);return o.promise();
	        }function u(t) {
	          this.accum = t, this.array._gotAccum(t);var n = i(this.value, this.array._promise);return n instanceof e ? (this.array._currentCancellable = n, n._then(p, void 0, void 0, this, void 0)) : p.call(this, n);
	        }function p(t) {
	          var n = this.array,
	              r = n._promise,
	              i = _(n._fn);r._pushContext();var o;o = void 0 !== n._eachValues ? i.call(r._boundValue(), t, this.index, this.length) : i.call(r._boundValue(), this.accum, t, this.index, this.length), o instanceof e && (n._currentCancellable = o);var a = r._popContext();return s.checkForgottenReturns(o, a, void 0 !== n._eachValues ? "Promise.each" : "Promise.reduce", r), o;
	        }var h = e._getDomain,
	            f = t("./util"),
	            _ = f.tryCatch;f.inherits(a, n), a.prototype._gotAccum = function (t) {
	          void 0 !== this._eachValues && null !== this._eachValues && t !== o && this._eachValues.push(t);
	        }, a.prototype._eachComplete = function (t) {
	          return null !== this._eachValues && this._eachValues.push(t), this._eachValues;
	        }, a.prototype._init = function () {}, a.prototype._resolveEmptyArray = function () {
	          this._resolve(void 0 !== this._eachValues ? this._eachValues : this._initialValue);
	        }, a.prototype.shouldCopyValues = function () {
	          return !1;
	        }, a.prototype._resolve = function (t) {
	          this._promise._resolveCallback(t), this._values = null;
	        }, a.prototype._resultCancelled = function (t) {
	          return t === this._initialValue ? this._cancel() : void (this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof e && this._currentCancellable.cancel(), this._initialValue instanceof e && this._initialValue.cancel()));
	        }, a.prototype._iterate = function (t) {
	          this._values = t;var n,
	              r,
	              i = t.length;if (void 0 !== this._initialValue ? (n = this._initialValue, r = 0) : (n = e.resolve(t[0]), r = 1), this._currentCancellable = n, !n.isRejected()) for (; i > r; ++r) {
	            var o = { accum: null, value: t[r], index: r, length: i, array: this };n = n._then(u, void 0, void 0, o, void 0);
	          }void 0 !== this._eachValues && (n = n._then(this._eachComplete, void 0, void 0, this, void 0)), n._then(c, c, void 0, n, this);
	        }, e.prototype.reduce = function (t, e) {
	          return l(this, t, e, null);
	        }, e.reduce = function (t, e, n, r) {
	          return l(t, e, n, r);
	        };
	      };
	    }, { "./util": 36 }], 29: [function (t, e, n) {
	      "use strict";
	      var r,
	          i = t("./util"),
	          o = function o() {
	        throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
	      },
	          s = i.getNativePromise();if (i.isNode && "undefined" == typeof MutationObserver) {
	        var a = global.setImmediate,
	            c = process.nextTick;r = i.isRecentNode ? function (t) {
	          a.call(global, t);
	        } : function (t) {
	          c.call(process, t);
	        };
	      } else if ("function" == typeof s && "function" == typeof s.resolve) {
	        var l = s.resolve();r = function r(t) {
	          l.then(t);
	        };
	      } else r = "undefined" == typeof MutationObserver || "undefined" != typeof window && window.navigator && (window.navigator.standalone || window.cordova) ? "undefined" != typeof _setImmediate3.default ? function (t) {
	        (0, _setImmediate3.default)(t);
	      } : "undefined" != typeof setTimeout ? function (t) {
	        setTimeout(t, 0);
	      } : o : function () {
	        var t = document.createElement("div"),
	            e = { attributes: !0 },
	            n = !1,
	            r = document.createElement("div"),
	            i = new MutationObserver(function () {
	          t.classList.toggle("foo"), n = !1;
	        });i.observe(r, e);var o = function o() {
	          n || (n = !0, r.classList.toggle("foo"));
	        };return function (n) {
	          var r = new MutationObserver(function () {
	            r.disconnect(), n();
	          });r.observe(t, e), o();
	        };
	      }();e.exports = r;
	    }, { "./util": 36 }], 30: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r) {
	        function i(t) {
	          this.constructor$(t);
	        }var o = e.PromiseInspection,
	            s = t("./util");s.inherits(i, n), i.prototype._promiseResolved = function (t, e) {
	          this._values[t] = e;var n = ++this._totalResolved;return n >= this._length ? (this._resolve(this._values), !0) : !1;
	        }, i.prototype._promiseFulfilled = function (t, e) {
	          var n = new o();return n._bitField = 33554432, n._settledValueField = t, this._promiseResolved(e, n);
	        }, i.prototype._promiseRejected = function (t, e) {
	          var n = new o();return n._bitField = 16777216, n._settledValueField = t, this._promiseResolved(e, n);
	        }, e.settle = function (t) {
	          return r.deprecated(".settle()", ".reflect()"), new i(t).promise();
	        }, e.prototype.settle = function () {
	          return e.settle(this);
	        };
	      };
	    }, { "./util": 36 }], 31: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r) {
	        function i(t) {
	          this.constructor$(t), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
	        }function o(t, e) {
	          if ((0 | e) !== e || 0 > e) return r("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");var n = new i(t),
	              o = n.promise();return n.setHowMany(e), n.init(), o;
	        }var s = t("./util"),
	            a = t("./errors").RangeError,
	            c = t("./errors").AggregateError,
	            l = s.isArray,
	            u = {};s.inherits(i, n), i.prototype._init = function () {
	          if (this._initialized) {
	            if (0 === this._howMany) return void this._resolve([]);this._init$(void 0, -5);var t = l(this._values);!this._isResolved() && t && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
	          }
	        }, i.prototype.init = function () {
	          this._initialized = !0, this._init();
	        }, i.prototype.setUnwrap = function () {
	          this._unwrap = !0;
	        }, i.prototype.howMany = function () {
	          return this._howMany;
	        }, i.prototype.setHowMany = function (t) {
	          this._howMany = t;
	        }, i.prototype._promiseFulfilled = function (t) {
	          return this._addFulfilled(t), this._fulfilled() === this.howMany() ? (this._values.length = this.howMany(), 1 === this.howMany() && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0) : !1;
	        }, i.prototype._promiseRejected = function (t) {
	          return this._addRejected(t), this._checkOutcome();
	        }, i.prototype._promiseCancelled = function () {
	          return this._values instanceof e || null == this._values ? this._cancel() : (this._addRejected(u), this._checkOutcome());
	        }, i.prototype._checkOutcome = function () {
	          if (this.howMany() > this._canPossiblyFulfill()) {
	            for (var t = new c(), e = this.length(); e < this._values.length; ++e) {
	              this._values[e] !== u && t.push(this._values[e]);
	            }return t.length > 0 ? this._reject(t) : this._cancel(), !0;
	          }return !1;
	        }, i.prototype._fulfilled = function () {
	          return this._totalResolved;
	        }, i.prototype._rejected = function () {
	          return this._values.length - this.length();
	        }, i.prototype._addRejected = function (t) {
	          this._values.push(t);
	        }, i.prototype._addFulfilled = function (t) {
	          this._values[this._totalResolved++] = t;
	        }, i.prototype._canPossiblyFulfill = function () {
	          return this.length() - this._rejected();
	        }, i.prototype._getRangeError = function (t) {
	          var e = "Input array must contain at least " + this._howMany + " items but contains only " + t + " items";return new a(e);
	        }, i.prototype._resolveEmptyArray = function () {
	          this._reject(this._getRangeError(0));
	        }, e.some = function (t, e) {
	          return o(t, e);
	        }, e.prototype.some = function (t) {
	          return o(this, t);
	        }, e._SomePromiseArray = i;
	      };
	    }, { "./errors": 12, "./util": 36 }], 32: [function (t, e, n) {
	      "use strict";
	      e.exports = function (t) {
	        function e(t) {
	          void 0 !== t ? (t = t._target(), this._bitField = t._bitField, this._settledValueField = t._isFateSealed() ? t._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
	        }e.prototype._settledValue = function () {
	          return this._settledValueField;
	        };var n = e.prototype.value = function () {
	          if (!this.isFulfilled()) throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue();
	        },
	            r = e.prototype.error = e.prototype.reason = function () {
	          if (!this.isRejected()) throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue();
	        },
	            i = e.prototype.isFulfilled = function () {
	          return 0 !== (33554432 & this._bitField);
	        },
	            o = e.prototype.isRejected = function () {
	          return 0 !== (16777216 & this._bitField);
	        },
	            s = e.prototype.isPending = function () {
	          return 0 === (50397184 & this._bitField);
	        },
	            a = e.prototype.isResolved = function () {
	          return 0 !== (50331648 & this._bitField);
	        };e.prototype.isCancelled = function () {
	          return 0 !== (8454144 & this._bitField);
	        }, t.prototype.__isCancelled = function () {
	          return 65536 === (65536 & this._bitField);
	        }, t.prototype._isCancelled = function () {
	          return this._target().__isCancelled();
	        }, t.prototype.isCancelled = function () {
	          return 0 !== (8454144 & this._target()._bitField);
	        }, t.prototype.isPending = function () {
	          return s.call(this._target());
	        }, t.prototype.isRejected = function () {
	          return o.call(this._target());
	        }, t.prototype.isFulfilled = function () {
	          return i.call(this._target());
	        }, t.prototype.isResolved = function () {
	          return a.call(this._target());
	        }, t.prototype.value = function () {
	          return n.call(this._target());
	        }, t.prototype.reason = function () {
	          var t = this._target();return t._unsetRejectionIsUnhandled(), r.call(t);
	        }, t.prototype._value = function () {
	          return this._settledValue();
	        }, t.prototype._reason = function () {
	          return this._unsetRejectionIsUnhandled(), this._settledValue();
	        }, t.PromiseInspection = e;
	      };
	    }, {}], 33: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n) {
	        function r(t, r) {
	          if (u(t)) {
	            if (t instanceof e) return t;var i = o(t);if (i === l) {
	              r && r._pushContext();var c = e.reject(i.e);return r && r._popContext(), c;
	            }if ("function" == typeof i) {
	              if (s(t)) {
	                var c = new e(n);return t._then(c._fulfill, c._reject, void 0, c, null), c;
	              }return a(t, i, r);
	            }
	          }return t;
	        }function i(t) {
	          return t.then;
	        }function o(t) {
	          try {
	            return i(t);
	          } catch (e) {
	            return l.e = e, l;
	          }
	        }function s(t) {
	          try {
	            return p.call(t, "_promise0");
	          } catch (e) {
	            return !1;
	          }
	        }function a(t, r, i) {
	          function o(t) {
	            a && (a._resolveCallback(t), a = null);
	          }function s(t) {
	            a && (a._rejectCallback(t, p, !0), a = null);
	          }var a = new e(n),
	              u = a;i && i._pushContext(), a._captureStackTrace(), i && i._popContext();var p = !0,
	              h = c.tryCatch(r).call(t, o, s);return p = !1, a && h === l && (a._rejectCallback(h.e, !0, !0), a = null), u;
	        }var c = t("./util"),
	            l = c.errorObj,
	            u = c.isObject,
	            p = {}.hasOwnProperty;return r;
	      };
	    }, { "./util": 36 }], 34: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r) {
	        function i(t) {
	          this.handle = t;
	        }function o(t) {
	          return clearTimeout(this.handle), t;
	        }function s(t) {
	          throw clearTimeout(this.handle), t;
	        }var a = t("./util"),
	            c = e.TimeoutError;i.prototype._resultCancelled = function () {
	          clearTimeout(this.handle);
	        };var l = function l(t) {
	          return u(+this).thenReturn(t);
	        },
	            u = e.delay = function (t, o) {
	          var s, a;return void 0 !== o ? (s = e.resolve(o)._then(l, null, null, t, void 0), r.cancellation() && o instanceof e && s._setOnCancel(o)) : (s = new e(n), a = setTimeout(function () {
	            s._fulfill();
	          }, +t), r.cancellation() && s._setOnCancel(new i(a)), s._captureStackTrace()), s._setAsyncGuaranteed(), s;
	        };e.prototype.delay = function (t) {
	          return u(t, this);
	        };var p = function p(t, e, n) {
	          var r;r = "string" != typeof e ? e instanceof Error ? e : new c("operation timed out") : new c(e), a.markAsOriginatingFromRejection(r), t._attachExtraTrace(r), t._reject(r), null != n && n.cancel();
	        };e.prototype.timeout = function (t, e) {
	          t = +t;var n,
	              a,
	              c = new i(setTimeout(function () {
	            n.isPending() && p(n, e, a);
	          }, t));return r.cancellation() ? (a = this.then(), n = a._then(o, s, void 0, c, void 0), n._setOnCancel(c)) : n = this._then(o, s, void 0, c, void 0), n;
	        };
	      };
	    }, { "./util": 36 }], 35: [function (t, e, n) {
	      "use strict";
	      e.exports = function (e, n, r, i, o, s) {
	        function a(t) {
	          setTimeout(function () {
	            throw t;
	          }, 0);
	        }function c(t) {
	          var e = r(t);return e !== t && "function" == typeof t._isDisposable && "function" == typeof t._getDisposer && t._isDisposable() && e._setDisposable(t._getDisposer()), e;
	        }function l(t, n) {
	          function i() {
	            if (s >= l) return u._fulfill();var o = c(t[s++]);if (o instanceof e && o._isDisposable()) {
	              try {
	                o = r(o._getDisposer().tryDispose(n), t.promise);
	              } catch (p) {
	                return a(p);
	              }if (o instanceof e) return o._then(i, a, null, null, null);
	            }i();
	          }var s = 0,
	              l = t.length,
	              u = new e(o);return i(), u;
	        }function u(t, e, n) {
	          this._data = t, this._promise = e, this._context = n;
	        }function p(t, e, n) {
	          this.constructor$(t, e, n);
	        }function h(t) {
	          return u.isDisposer(t) ? (this.resources[this.index]._setDisposable(t), t.promise()) : t;
	        }function f(t) {
	          this.length = t, this.promise = null, this[t - 1] = null;
	        }var _ = t("./util"),
	            d = t("./errors").TypeError,
	            v = t("./util").inherits,
	            y = _.errorObj,
	            m = _.tryCatch,
	            g = {};u.prototype.data = function () {
	          return this._data;
	        }, u.prototype.promise = function () {
	          return this._promise;
	        }, u.prototype.resource = function () {
	          return this.promise().isFulfilled() ? this.promise().value() : g;
	        }, u.prototype.tryDispose = function (t) {
	          var e = this.resource(),
	              n = this._context;void 0 !== n && n._pushContext();var r = e !== g ? this.doDispose(e, t) : null;return void 0 !== n && n._popContext(), this._promise._unsetDisposable(), this._data = null, r;
	        }, u.isDisposer = function (t) {
	          return null != t && "function" == typeof t.resource && "function" == typeof t.tryDispose;
	        }, v(p, u), p.prototype.doDispose = function (t, e) {
	          var n = this.data();return n.call(t, t, e);
	        }, f.prototype._resultCancelled = function () {
	          for (var t = this.length, n = 0; t > n; ++n) {
	            var r = this[n];r instanceof e && r.cancel();
	          }
	        }, e.using = function () {
	          var t = arguments.length;if (2 > t) return n("you must pass at least 2 arguments to Promise.using");var i = arguments[t - 1];if ("function" != typeof i) return n("expecting a function but got " + _.classString(i));var o,
	              a = !0;2 === t && Array.isArray(arguments[0]) ? (o = arguments[0], t = o.length, a = !1) : (o = arguments, t--);for (var c = new f(t), p = 0; t > p; ++p) {
	            var d = o[p];if (u.isDisposer(d)) {
	              var v = d;d = d.promise(), d._setDisposable(v);
	            } else {
	              var g = r(d);g instanceof e && (d = g._then(h, null, null, { resources: c, index: p }, void 0));
	            }c[p] = d;
	          }for (var b = new Array(c.length), p = 0; p < b.length; ++p) {
	            b[p] = e.resolve(c[p]).reflect();
	          }var w = e.all(b).then(function (t) {
	            for (var e = 0; e < t.length; ++e) {
	              var n = t[e];if (n.isRejected()) return y.e = n.error(), y;if (!n.isFulfilled()) return void w.cancel();t[e] = n.value();
	            }C._pushContext(), i = m(i);var r = a ? i.apply(void 0, t) : i(t),
	                o = C._popContext();return s.checkForgottenReturns(r, o, "Promise.using", C), r;
	          }),
	              C = w.lastly(function () {
	            var t = new e.PromiseInspection(w);return l(c, t);
	          });return c.promise = C, C._setOnCancel(c), C;
	        }, e.prototype._setDisposable = function (t) {
	          this._bitField = 131072 | this._bitField, this._disposer = t;
	        }, e.prototype._isDisposable = function () {
	          return (131072 & this._bitField) > 0;
	        }, e.prototype._getDisposer = function () {
	          return this._disposer;
	        }, e.prototype._unsetDisposable = function () {
	          this._bitField = -131073 & this._bitField, this._disposer = void 0;
	        }, e.prototype.disposer = function (t) {
	          if ("function" == typeof t) return new p(t, this, i());throw new d();
	        };
	      };
	    }, { "./errors": 12, "./util": 36 }], 36: [function (t, e, n) {
	      "use strict";
	      function r() {
	        try {
	          var t = P;return P = null, t.apply(this, arguments);
	        } catch (e) {
	          return T.e = e, T;
	        }
	      }function i(t) {
	        return P = t, r;
	      }function o(t) {
	        return null == t || t === !0 || t === !1 || "string" == typeof t || "number" == typeof t;
	      }function s(t) {
	        return "function" == typeof t || "object" == (typeof t === "undefined" ? "undefined" : (0, _typeof3.default)(t)) && null !== t;
	      }function a(t) {
	        return o(t) ? new Error(v(t)) : t;
	      }function c(t, e) {
	        var n,
	            r = t.length,
	            i = new Array(r + 1);for (n = 0; r > n; ++n) {
	          i[n] = t[n];
	        }return i[n] = e, i;
	      }function l(t, e, n) {
	        if (!F.isES5) return {}.hasOwnProperty.call(t, e) ? t[e] : void 0;var r = (0, _getOwnPropertyDescriptor2.default)(t, e);return null != r ? null == r.get && null == r.set ? r.value : n : void 0;
	      }function u(t, e, n) {
	        if (o(t)) return t;var r = { value: n, configurable: !0, enumerable: !1, writable: !0 };return F.defineProperty(t, e, r), t;
	      }function p(t) {
	        throw t;
	      }function h(t) {
	        try {
	          if ("function" == typeof t) {
	            var e = F.names(t.prototype),
	                n = F.isES5 && e.length > 1,
	                r = e.length > 0 && !(1 === e.length && "constructor" === e[0]),
	                i = A.test(t + "") && F.names(t).length > 0;if (n || r || i) return !0;
	          }return !1;
	        } catch (o) {
	          return !1;
	        }
	      }function f(t) {
	        function e() {}e.prototype = t;for (var n = 8; n--;) {
	          new e();
	        }return t;
	      }function _(t) {
	        return D.test(t);
	      }function d(t, e, n) {
	        for (var r = new Array(t), i = 0; t > i; ++i) {
	          r[i] = e + i + n;
	        }return r;
	      }function v(t) {
	        try {
	          return t + "";
	        } catch (e) {
	          return "[no string representation]";
	        }
	      }function y(t) {
	        return null !== t && "object" == (typeof t === "undefined" ? "undefined" : (0, _typeof3.default)(t)) && "string" == typeof t.message && "string" == typeof t.name;
	      }function m(t) {
	        try {
	          u(t, "isOperational", !0);
	        } catch (e) {}
	      }function g(t) {
	        return null == t ? !1 : t instanceof Error.__BluebirdErrorTypes__.OperationalError || t.isOperational === !0;
	      }function b(t) {
	        return y(t) && F.propertyIsWritable(t, "stack");
	      }function w(t) {
	        return {}.toString.call(t);
	      }function C(t, e, n) {
	        for (var r = F.names(t), i = 0; i < r.length; ++i) {
	          var o = r[i];if (n(o)) try {
	            F.defineProperty(e, o, F.getDescriptor(t, o));
	          } catch (s) {}
	        }
	      }function j(t) {
	        return N ? process.env[t] : void 0;
	      }function E() {
	        if ("function" == typeof _promise2.default) try {
	          var t = new _promise2.default(function () {});if ("[object Promise]" === {}.toString.call(t)) return _promise2.default;
	        } catch (e) {}
	      }function k(t, e) {
	        return t.bind(e);
	      }var F = t("./es5"),
	          x = "undefined" == typeof navigator,
	          T = { e: {} },
	          P,
	          R = "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : void 0 !== this ? this : null,
	          S = function S(t, e) {
	        function n() {
	          this.constructor = t, this.constructor$ = e;for (var n in e.prototype) {
	            r.call(e.prototype, n) && "$" !== n.charAt(n.length - 1) && (this[n + "$"] = e.prototype[n]);
	          }
	        }var r = {}.hasOwnProperty;return n.prototype = e.prototype, t.prototype = new n(), t.prototype;
	      },
	          O = function () {
	        var t = [Array.prototype, Object.prototype, Function.prototype],
	            e = function e(_e2) {
	          for (var n = 0; n < t.length; ++n) {
	            if (t[n] === _e2) return !0;
	          }return !1;
	        };if (F.isES5) {
	          var n = _getOwnPropertyNames2.default;return function (t) {
	            for (var r = [], i = (0, _create2.default)(null); null != t && !e(t);) {
	              var o;try {
	                o = n(t);
	              } catch (s) {
	                return r;
	              }for (var a = 0; a < o.length; ++a) {
	                var c = o[a];if (!i[c]) {
	                  i[c] = !0;var l = (0, _getOwnPropertyDescriptor2.default)(t, c);null != l && null == l.get && null == l.set && r.push(c);
	                }
	              }t = F.getPrototypeOf(t);
	            }return r;
	          };
	        }var r = {}.hasOwnProperty;return function (n) {
	          if (e(n)) return [];var i = [];t: for (var o in n) {
	            if (r.call(n, o)) i.push(o);else {
	              for (var s = 0; s < t.length; ++s) {
	                if (r.call(t[s], o)) continue t;
	              }i.push(o);
	            }
	          }return i;
	        };
	      }(),
	          A = /this\s*\.\s*\S+\s*=/,
	          D = /^[a-z$_][a-z$_0-9]*$/i,
	          V = function () {
	        return "stack" in new Error() ? function (t) {
	          return b(t) ? t : new Error(v(t));
	        } : function (t) {
	          if (b(t)) return t;try {
	            throw new Error(v(t));
	          } catch (e) {
	            return e;
	          }
	        };
	      }(),
	          I = function I(t) {
	        return F.isArray(t) ? t : null;
	      };if ("undefined" != typeof _symbol2.default && _iterator2.default) {
	        var L = "function" == typeof _from2.default ? function (t) {
	          return (0, _from2.default)(t);
	        } : function (t) {
	          for (var e, n = [], r = (0, _getIterator3.default)(t); !(e = r.next()).done;) {
	            n.push(e.value);
	          }return n;
	        };I = function I(t) {
	          return F.isArray(t) ? t : null != t && "function" == typeof t[_iterator2.default] ? L(t) : null;
	        };
	      }var H = "undefined" != typeof process && "[object process]" === w(process).toLowerCase(),
	          N = "undefined" != typeof process && "undefined" != typeof process.env,
	          B = { isClass: h, isIdentifier: _, inheritedDataKeys: O, getDataPropertyOrDefault: l, thrower: p, isArray: F.isArray, asArray: I, notEnumerableProp: u, isPrimitive: o, isObject: s, isError: y, canEvaluate: x, errorObj: T, tryCatch: i, inherits: S, withAppended: c, maybeWrapAsError: a, toFastProperties: f, filledRange: d, toString: v, canAttachTrace: b, ensureErrorObject: V, originatesFromRejection: g, markAsOriginatingFromRejection: m, classString: w, copyDescriptors: C, hasDevTools: "undefined" != typeof chrome && chrome && "function" == typeof chrome.loadTimes, isNode: H, hasEnvVariables: N, env: j, global: R, getNativePromise: E, domainBind: k };B.isRecentNode = B.isNode && function () {
	        var t = process.versions.node.split(".").map(Number);return 0 === t[0] && t[1] > 10 || t[0] > 0;
	      }(), B.isNode && B.toFastProperties(process);try {
	        throw new Error();
	      } catch (U) {
	        B.lastLineError = U;
	      }e.exports = B;
	    }, { "./es5": 13 }] }, {}, [4])(4);
	}), "undefined" != typeof window && null !== window ? window.P = window.Promise : "undefined" != typeof self && null !== self && (self.P = self.Promise);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76), (function() { return this; }())))

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(139), __esModule: true };

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48);
	__webpack_require__(4);
	module.exports = __webpack_require__(140);

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(17)
	  , get      = __webpack_require__(58);
	module.exports = __webpack_require__(12).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(142), __esModule: true };

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(143);
	module.exports = __webpack_require__(12).Array.from;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(13)
	  , $export        = __webpack_require__(10)
	  , toObject       = __webpack_require__(47)
	  , call           = __webpack_require__(56)
	  , isArrayIter    = __webpack_require__(57)
	  , toLength       = __webpack_require__(37)
	  , createProperty = __webpack_require__(144)
	  , getIterFn      = __webpack_require__(58);
	
	$export($export.S + $export.F * !__webpack_require__(65)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(16)
	  , createDesc      = __webpack_require__(24);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(146), __esModule: true };

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(48);
	module.exports = __webpack_require__(147).f('iterator');

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(45);

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(149), __esModule: true };

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(150);
	__webpack_require__(3);
	__webpack_require__(161);
	__webpack_require__(162);
	module.exports = __webpack_require__(12).Symbol;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(11)
	  , has            = __webpack_require__(26)
	  , DESCRIPTORS    = __webpack_require__(20)
	  , $export        = __webpack_require__(10)
	  , redefine       = __webpack_require__(25)
	  , META           = __webpack_require__(151).KEY
	  , $fails         = __webpack_require__(21)
	  , shared         = __webpack_require__(40)
	  , setToStringTag = __webpack_require__(44)
	  , uid            = __webpack_require__(41)
	  , wks            = __webpack_require__(45)
	  , wksExt         = __webpack_require__(147)
	  , wksDefine      = __webpack_require__(152)
	  , keyOf          = __webpack_require__(153)
	  , enumKeys       = __webpack_require__(154)
	  , isArray        = __webpack_require__(157)
	  , anObject       = __webpack_require__(17)
	  , toIObject      = __webpack_require__(33)
	  , toPrimitive    = __webpack_require__(23)
	  , createDesc     = __webpack_require__(24)
	  , _create        = __webpack_require__(29)
	  , gOPNExt        = __webpack_require__(158)
	  , $GOPD          = __webpack_require__(160)
	  , $DP            = __webpack_require__(16)
	  , $keys          = __webpack_require__(31)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(159).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(156).f  = $propertyIsEnumerable;
	  __webpack_require__(155).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(9)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(15)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(41)('meta')
	  , isObject = __webpack_require__(18)
	  , has      = __webpack_require__(26)
	  , setDesc  = __webpack_require__(16).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(21)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(11)
	  , core           = __webpack_require__(12)
	  , LIBRARY        = __webpack_require__(9)
	  , wksExt         = __webpack_require__(147)
	  , defineProperty = __webpack_require__(16).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(31)
	  , toIObject = __webpack_require__(33);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(31)
	  , gOPS    = __webpack_require__(155)
	  , pIE     = __webpack_require__(156);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 155 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 156 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(35);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(33)
	  , gOPN      = __webpack_require__(159).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(32)
	  , hiddenKeys = __webpack_require__(42).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(156)
	  , createDesc     = __webpack_require__(24)
	  , toIObject      = __webpack_require__(33)
	  , toPrimitive    = __webpack_require__(23)
	  , has            = __webpack_require__(26)
	  , IE8_DOM_DEFINE = __webpack_require__(19)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(20) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(152)('asyncIterator');

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(152)('observable');

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(164), __esModule: true };

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(165);
	module.exports = __webpack_require__(12).setImmediate;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(10)
	  , $task   = __webpack_require__(60);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(167), __esModule: true };

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(4);
	__webpack_require__(48);
	__webpack_require__(168);
	__webpack_require__(174);
	module.exports = __webpack_require__(12).Map;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(169);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(170)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(16).f
	  , create      = __webpack_require__(29)
	  , redefineAll = __webpack_require__(63)
	  , ctx         = __webpack_require__(13)
	  , anInstance  = __webpack_require__(54)
	  , defined     = __webpack_require__(7)
	  , forOf       = __webpack_require__(55)
	  , $iterDefine = __webpack_require__(8)
	  , step        = __webpack_require__(51)
	  , setSpecies  = __webpack_require__(64)
	  , DESCRIPTORS = __webpack_require__(20)
	  , fastKey     = __webpack_require__(151).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(11)
	  , $export        = __webpack_require__(10)
	  , meta           = __webpack_require__(151)
	  , fails          = __webpack_require__(21)
	  , hide           = __webpack_require__(15)
	  , redefineAll    = __webpack_require__(63)
	  , forOf          = __webpack_require__(55)
	  , anInstance     = __webpack_require__(54)
	  , isObject       = __webpack_require__(18)
	  , setToStringTag = __webpack_require__(44)
	  , dP             = __webpack_require__(16).f
	  , each           = __webpack_require__(171)(0)
	  , DESCRIPTORS    = __webpack_require__(20);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(13)
	  , IObject  = __webpack_require__(34)
	  , toObject = __webpack_require__(47)
	  , toLength = __webpack_require__(37)
	  , asc      = __webpack_require__(172);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(173);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(18)
	  , isArray  = __webpack_require__(157)
	  , SPECIES  = __webpack_require__(45)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(10);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(175)('Map')});

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(53)
	  , from    = __webpack_require__(176);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(55);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(178), __esModule: true };

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(179);
	module.exports = __webpack_require__(12).Object.getPrototypeOf;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(47)
	  , $getPrototypeOf = __webpack_require__(46);
	
	__webpack_require__(180)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(10)
	  , core    = __webpack_require__(12)
	  , fails   = __webpack_require__(21);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(182), __esModule: true };

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(183);
	var $Object = __webpack_require__(12).Object;
	module.exports = function getOwnPropertyNames(it){
	  return $Object.getOwnPropertyNames(it);
	};

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(180)('getOwnPropertyNames', function(){
	  return __webpack_require__(158).f;
	});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(185), __esModule: true };

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(186);
	module.exports = __webpack_require__(12).Object.keys;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(47)
	  , $keys    = __webpack_require__(31);
	
	__webpack_require__(180)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(188), __esModule: true };

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(189);
	var $Object = __webpack_require__(12).Object;
	module.exports = function getOwnPropertyDescriptor(it, key){
	  return $Object.getOwnPropertyDescriptor(it, key);
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(33)
	  , $getOwnPropertyDescriptor = __webpack_require__(160).f;
	
	__webpack_require__(180)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(191), __esModule: true };

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(192);
	var $Object = __webpack_require__(12).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(10);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(20), 'Object', {defineProperty: __webpack_require__(16).f});

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(194), __esModule: true };

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(195);
	module.exports = __webpack_require__(12).Object.freeze;

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(18)
	  , meta     = __webpack_require__(151).onFreeze;
	
	__webpack_require__(180)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(197), __esModule: true };

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(198);
	var $Object = __webpack_require__(12).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(10)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(29)});

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(145);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(148);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 200 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var SEARCH_BAR_SELECTOR = '#search-bar';
	var SEARCH_DOPPLE_SELECTOR = '.c-search-bar__dopple';
	var PLAYLIST_RESULTS_SELECTOR = '#search-results .c-search__playlist-results';
	var SONG_RESULTS_SELECTOR = '#search-results .c-search__song-results';
	
	var _songsMatching = function _songsMatching(searchKey) {
	    var searchKeyExp = new RegExp(searchKey, 'i');
	    return SONGS.filter(function (song) {
	        return searchKeyExp.test(song.artist) || searchKeyExp.test(song.title);
	    });
	};
	
	var _playlistsMatching = function _playlistsMatching(searchKey) {
	    var searchKeyExp = new RegExp(searchKey, 'i');
	    return PLAYLISTS.filter(function (playlist) {
	        return searchKeyExp.test(playlist.name);
	    });
	};
	
	var _bindEvents = function _bindEvents() {
	    var activeClass = 'c--active';
	    var $searchBar = $(SEARCH_BAR_SELECTOR);
	    var $searchDopple = $(SEARCH_DOPPLE_SELECTOR);
	    var $songResults = $(SONG_RESULTS_SELECTOR);
	    var $playlistResults = $(PLAYLIST_RESULTS_SELECTOR);
	
	    $searchBar.on('input', function (e) {
	        $songResults.html('');
	        $playlistResults.html('');
	        if ($searchBar.val().length === 0) {
	            return;
	        }
	        var matchingSongs = _songsMatching($searchBar.val());
	        var matchingPlaylists = _playlistsMatching($searchBar.val());
	
	        matchingSongs.forEach(function (song) {
	            $songResults.append(UTILS.songElementFor(song)[0]);
	        });
	        matchingPlaylists.forEach(function (playlist) {
	            $playlistResults.append(UTILS.playlistElementFor(playlist)[0]);
	        });
	    });
	
	    $searchBar.on('blur', function (e) {
	        if ($searchBar.val().length === 0) {
	            $searchBar.removeClass(activeClass);
	            return;
	        }
	        $searchBar.addClass(activeClass);
	    });
	
	    $searchDopple.on('click', function (e) {
	        e.stopPropagation();
	        $searchBar.focus();
	    });
	};
	
	var SearchUI = function SearchUI() {
	    _bindEvents();
	};
	
	exports.default = SearchUI;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _events = __webpack_require__(66);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _request = __webpack_require__(67);
	
	var _request2 = _interopRequireDefault(_request);
	
	var _socket = __webpack_require__(71);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	var _navBar = __webpack_require__(127);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LOGIN_BUTTON_SELECTOR = '.js-login-button';
	var LOGIN_FORM_SELECTOR = '.js-login-form';
	
	var _redirectToApp = function _redirectToApp() {
	    var hiddenClass = 'u-hidden';
	    var $loginPage = $('#login-page');
	    var $playlistApp = $('#playlist-app');
	
	    $playlistApp.removeClass(hiddenClass);
	    $loginPage.addClass(hiddenClass);
	
	    _navBar.NavBar.setTabActive($('.c-nav-bar__tab[data-tab="playlists"]'), true);
	};
	
	var _bindEvents = function _bindEvents() {
	    var $body = $('body');
	    var submitFormHandler = function submitFormHandler(e) {
	        e.preventDefault();
	        var loginInfo = {
	            username: $('.js-username-input').val(),
	            password: $('.js-password-input').val()
	        };
	        _request2.default.submitLogin(loginInfo).then(function (data) {
	            // Listen for real-time updates
	            _socket2.default.connect();
	            $body.trigger(_events2.default.names.SIGNED_IN);
	            $body.trigger(_events2.default.names.PLAYLISTS_UPDATE_NEEDED);
	        }).catch(function (err) {
	            return console.log(err);
	        });
	    };
	
	    $(LOGIN_FORM_SELECTOR).on('submit', submitFormHandler);
	    $(LOGIN_BUTTON_SELECTOR).on('click', submitFormHandler);
	
	    $body.on(_events2.default.names.SIGNED_IN, _redirectToApp);
	};
	
	var LoginUI = function LoginUI() {
	    _bindEvents();
	};
	
	exports.default = LoginUI;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZmZkNmE0ODFiYWZiODNjZTA0ZTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9qcy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2pzL2dsb2JhbC9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9qcy9nbG9iYWwvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2pzL2dsb2JhbC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2pzL2dsb2JhbC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNldXJpL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9+L2RlYnVnL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vZGVidWcvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tY2xpZW50L34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZGVidWcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9qc29uMy9saWIvanNvbjMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLXBhcnNlci9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtY29ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hhcy1iaW5hcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtYmluYXJ5L34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYWZ0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi93dGYtOC93dGYtOC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VuZ2luZS5pby1jbGllbnQvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlcXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZW5naW5lLmlvLWNsaWVudC9+L2RlYnVnL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L34vZGVidWcvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly8vd3MgKGlnbm9yZWQpIiwid2VicGFjazovLy8uL34vaW5kZXhvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3BhcnNlanNvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tldC5pby1jbGllbnQvfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3RvLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb21wb25lbnQtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2pzL2NvbXBvbmVudHMvbmF2LWJhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2pzL2NvbXBvbmVudHMvb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2pzL2NvbXBvbmVudHMvcGxheWxpc3Qtc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9qcy9jb21wb25lbnRzL3VzZXItc2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9qcy91aS9saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAvanMvdWkvcGxheWxpc3RzLmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAvanMvY29tcG9uZW50cy9hZGQtcGxheWxpc3QtZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAvanMvdmVuZG9yL2JsdWViaXJkLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQtaW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3NldC1pbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2ZyZWV6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAvanMvdWkvc2VhcmNoLmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAvanMvdWkvbG9naW4uanMiXSwibmFtZXMiOlsiX2luaXRpYWxTdGF0ZSIsImlzTG9naW5QYWdlIiwidGVzdCIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJoaWRkZW5DbGFzcyIsIiRsb2dpblBhZ2UiLCIkIiwiJHBsYXlsaXN0QXBwIiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsIl9iaW5kRXZlbnRzIiwiJGJvZHkiLCJvbiIsIm5hbWVzIiwiUExBWUxJU1RTX1VQREFURV9ORUVERUQiLCJnZXRNdXNpY0RhdGEiLCJ0aGVuIiwicGxheWxpc3RzIiwid2luZG93IiwiUExBWUxJU1RTIiwidHJpZ2dlciIsIlBMQVlMSVNUU19VUERBVEVEIiwiUExBWUxJU1RfU0VMRUNUT1JfVVBEQVRFX05FRURFRCIsImxvYWRNdXNpYyIsImFsbCIsIm11c2ljRGF0YSIsIlNPTkdTIiwiU09OR1NfVVBEQVRFRCIsIkFwcCIsIlVUSUxTIiwiRXZlbnRzIiwiTVVTSUNfTE9BREVEIiwiUExBWUxJU1RfQURERUQiLCJQTEFZTElTVF9TT05HX0FEREVEIiwiUExBWUxJU1RfU09OR19ERUxFVEVEIiwiU0lHTkVEX0lOIiwiZXZlbnQiLCJwYXlsb2FkIiwiUmVxdWVzdCIsImtleSIsInJlc29sdmUiLCJyZWplY3QiLCJnZXQiLCJkYXRhIiwic3RhdHVzIiwieGhyIiwiY29uc29sZSIsImVycm9yIiwiZ2V0VXNlcnMiLCJ1c2VycyIsImFkZE5ld1BsYXlsaXN0IiwicGxheWxpc3QiLCJwb3N0IiwiYWRkU29uZ1RvUGxheWxpc3QiLCJzb25nSWQiLCJwbGF5bGlzdElkIiwiYWpheCIsInVybCIsImNvbnRlbnRUeXBlIiwidHlwZSIsInNvbmciLCJzdWNjZXNzIiwicmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCIsInN1Ym1pdExvZ2luIiwiZ3JhbnRVc2VyUGxheWxpc3RQZXJtaXNzaW9uIiwidXNlcklkIiwidXNlciIsIlV0aWxzIiwiZ2V0T2JqV2l0aElkIiwiYXJyIiwiaWQiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJvYmpJZCIsInBhcnNlSW50IiwibWF0Y2hlcyIsImZpbHRlciIsIm9iaiIsInNvbmdFbGVtZW50Rm9yIiwic29uZ09iaiIsInNvbmdFbENsYXNzIiwic29uZ0VsSFRNTCIsInRpdGxlIiwiYXJ0aXN0IiwiYXR0ciIsImh0bWwiLCJwbGF5bGlzdEVsZW1lbnRGb3IiLCJwbGF5bGlzdE9iaiIsInBsYXlsaXN0RWxDbGFzcyIsInBsYXlsaXN0RWxIVE1MIiwibmFtZSIsInNvbmdJZEludCIsInNvbmdzIiwiaW5jbHVkZXMiLCJwdXNoIiwiY3VycmVudFNvbmdJZCIsIlNvY2tldCIsImV2ZW50cyIsImxvZyIsIm1lc3NhZ2UiLCJjb25uZWN0Iiwic29ja2V0IiwiX3NvY2tldEV2ZW50SGFuZGxlciIsImpzb25EYXRhIiwiSlNPTiIsInBhcnNlIiwiTmF2QmFyIiwic2V0VGFiVmlld0FjdGl2ZSIsIiR0YWJWaWV3IiwiYWN0aXZlQ2xhc3MiLCJzZXRUYWJBY3RpdmUiLCIkdGFiIiwicHVzaFN0YXRlIiwidGFiIiwiYWN0aXZlVGFiVmlld1NlbGVjdG9yIiwiX2hpZ2hsaWdodFRhYiIsImhpc3RvcnkiLCJlIiwic3RvcFByb3BhZ2F0aW9uIiwiaGlkZSIsIiRzZWxlY3RlZFRhYiIsIl9zZWxlY3RJbml0aWFsVGFiIiwicGF0aE1hdGNoZXNUYWIiLCJSZWdFeHAiLCJOYXZCYXJVSSIsIk9WRVJMQVlfU0VMRUNUT1IiLCJWSVNJQkxFX0NMQVNTIiwiSElEREVOX0NMQVNTIiwiT3ZlcmxheSIsInNob3ciLCJ0YXJnZXQiLCJfT3ZlcmxheVVJIiwiTElTVF9TRUxfU0VMRUNUT1IiLCJQTEFZTElTVF9MSVNUX1NFTEVDVE9SIiwiUGxheWxpc3RTZWxlY3RvciIsInNob3dTZWxlY3Rpb25Gb3IiLCIkcGxheWxpc3RTZWwiLCJhZGRQbGF5bGlzdCIsIiRwbGF5bGlzdExpc3QiLCIkc2VsZWN0b3JFbCIsInNlbGVjdG9yQ2xhc3MiLCJ0ZXh0IiwiYXBwZW5kIiwiX2FkZFBsYXlsaXN0cyIsImlzQXJyYXkiLCJmb3JFYWNoIiwiJGxpc3RTZWxDbG9zZUJ0biIsInNlbGVjdGVkU29uZ0lkIiwic2VsZWN0ZWRQbGF5bGlzdElkIiwiY2F0Y2giLCJlcnIiLCJQbGF5bGlzdFNlbGVjdG9yVUkiLCJVU0VSX0xJU1RfU0VMRUNUT1IiLCJVc2VyU2VsZWN0b3IiLCJfYWRkVXNlcnMiLCIkdXNlclNlbGVjdG9yIiwiYWRkVXNlciIsInVzZXJPYmoiLCIkdXNlckxpc3QiLCIkdXNlclNlbENsb3NlQnRuIiwiVXNlclNlbGVjdG9yVUkiLCJUSVRMRV9TT1JUX0tFWSIsIkFSVElTVF9TT1JUX0tFWSIsIlRJVExFX1NPUlRFRF9TT05HUyIsIkFSVElTVF9TT1JURURfU09OR1MiLCJfZ2V0U29uZ3NTb3J0ZWRCeSIsInNvcnRLZXkiLCJjb21wYXJhdG9yIiwiYSIsImIiLCJleGNsdXNpb25SZWdFeCIsImluQXNjZW5kaW5nT3JkZXIiLCJyZXBsYWNlIiwic29ydGVkU29uZ3MiLCJzb3J0IiwiX2xvYWRTb25nc1NvcnRlZEJ5IiwibGlicmFyeSIsIiRzb25nRWwiLCJjbG9zZXN0IiwiJHNlbGVjdGVkQnRuIiwiTGlicmFyeVVJIiwiUGxheWxpc3RzIiwiYWRkIiwiJHBsYXlsaXN0IiwiJHBsYXlsaXN0RWwiLCJfbG9hZFBsYXlsaXN0cyIsIiRwbGF5bGlzdERldGFpbFZpZXciLCIkc2VsZWN0ZWRQbGF5bGlzdCIsIiRwbGF5bGlzdEhlYWRlciIsIiRwbGF5bGlzdFNvbmdMaXN0IiwicGxheWxpc3REZXRhaWxzSWQiLCJyZW1vdmUiLCIkcGxheWxpc3REZXRhaWxzIiwiaGFzQ2xhc3MiLCJQbGF5bGlzdHNVSSIsIkFERF9CVE5fU0VMRUNUT1IiLCJDQU5DRUxfQlROX1NFTEVDVE9SIiwiRk9STV9DT05UQUlORVJfU0VMRUNUT1IiLCJGT1JNX1NFTEVDVE9SIiwiTkFNRV9JTlBVVF9TRUxFQ1RPUiIsIkFkZFBsYXlsaXN0Rm9ybSIsImZvY3VzIiwiJG5hbWVJbnB1dCIsImRpc21pc3NGb3JtSGFuZGxlciIsInZhbCIsImZvcm1TdWJtaXNzaW9uSGFuZGxlciIsInByZXZlbnREZWZhdWx0IiwiQWRkUGxheWxpc3RGb3JtVUkiLCJ0IiwiZXhwb3J0cyIsIm1vZHVsZSIsImdsb2JhbCIsInNlbGYiLCJQcm9taXNlIiwibiIsInIiLCJpIiwicyIsImMiLCJfZGVyZXFfIiwibyIsImwiLCJFcnJvciIsImNvZGUiLCJ1IiwiY2FsbCIsInByb21pc2UiLCJzZXRIb3dNYW55Iiwic2V0VW53cmFwIiwiaW5pdCIsIl9Tb21lUHJvbWlzZUFycmF5IiwiYW55IiwicHJvdG90eXBlIiwiX2N1c3RvbVNjaGVkdWxlciIsIl9pc1RpY2tVc2VkIiwiX2xhdGVRdWV1ZSIsIl9ub3JtYWxRdWV1ZSIsIl9oYXZlRHJhaW5lZFF1ZXVlcyIsIl90cmFtcG9saW5lRW5hYmxlZCIsImRyYWluUXVldWVzIiwiX2RyYWluUXVldWVzIiwiX3NjaGVkdWxlIiwiX3F1ZXVlVGljayIsIl9wdXNoT25lIiwicCIsInNldFNjaGVkdWxlciIsImhhc0N1c3RvbVNjaGVkdWxlciIsImVuYWJsZVRyYW1wb2xpbmUiLCJkaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5IiwiaGFzRGV2VG9vbHMiLCJoYXZlSXRlbXNRdWV1ZWQiLCJmYXRhbEVycm9yIiwicHJvY2VzcyIsInN0ZGVyciIsIndyaXRlIiwic3RhY2siLCJleGl0IiwidGhyb3dMYXRlciIsImFyZ3VtZW50cyIsInNldFRpbWVvdXQiLCJpbnZva2VMYXRlciIsImludm9rZSIsInNldHRsZVByb21pc2VzIiwiX3NldHRsZVByb21pc2VzIiwiX2RyYWluUXVldWUiLCJzaGlmdCIsIl9yZXNldCIsImZpcnN0TGluZUVycm9yIiwiX3JlamVjdCIsInByb21pc2VSZWplY3Rpb25RdWV1ZWQiLCJiaW5kaW5nUHJvbWlzZSIsIl90aGVuIiwiX2JpdEZpZWxkIiwiX3Jlc29sdmVDYWxsYmFjayIsImJpbmQiLCJfcHJvcGFnYXRlRnJvbSIsInByb3BhZ2F0ZUZyb21GdW5jdGlvbiIsIl9ib3VuZFZhbHVlIiwiYm91bmRWYWx1ZUZ1bmN0aW9uIiwiX3RhcmdldCIsIl9zZXRCb3VuZFRvIiwiaCIsIl9zZXRPbkNhbmNlbCIsIl9ib3VuZFRvIiwiX2lzQm91bmQiLCJub0NvbmZsaWN0IiwiY2xhc3NTdHJpbmciLCJ0b1N0cmluZyIsIlR5cGVFcnJvciIsInBvcCIsImFwcGx5IiwiTWF0aCIsIm1heCIsImNhbkV2YWx1YXRlIiwiaXNJZGVudGlmaWVyIiwic2xpY2UiLCJ0cnlDYXRjaCIsImVycm9yT2JqIiwiX2FzeW5jIiwiY2FuY2VsIiwiY2FuY2VsbGF0aW9uIiwiX3dhcm4iLCJfaXNDYW5jZWxsYWJsZSIsIl9jYW5jZWxCeSIsIl9pc0ZvbGxvd2luZyIsIl9mb2xsb3dlZSIsIl9jYW5jZWxCcmFuY2hlZCIsIl9jYW5jZWxsYXRpb25QYXJlbnQiLCJfc2V0V2lsbEJlQ2FuY2VsbGVkIiwiX2JyYW5jaEhhc0NhbmNlbGxlZCIsIl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsIiwiX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCIsIl9pbnZva2VPbkNhbmNlbCIsIl9jYW5jZWwiLCJfc2V0Q2FuY2VsbGVkIiwiX2NhbmNlbFByb21pc2VzIiwiX2xlbmd0aCIsIl91bnNldE9uQ2FuY2VsIiwiX29uQ2FuY2VsRmllbGQiLCJpc1BlbmRpbmciLCJfaXNDYW5jZWxsZWQiLCJpc0NhbmNlbGxhYmxlIiwiaXNDYW5jZWxsZWQiLCJfZG9JbnZva2VPbkNhbmNlbCIsIl9hdHRhY2hFeHRyYVRyYWNlIiwiX3Jlc3VsdENhbmNlbGxlZCIsIl9vbkNhbmNlbCIsIl9pbnZva2VJbnRlcm5hbE9uQ2FuY2VsIiwiaXNPYmplY3QiLCJmIiwiXyIsImQiLCJrZXlzIiwiX3RyYWNlIiwiQ2FwdHVyZWRUcmFjZSIsIl9wcm9taXNlQ3JlYXRlZCIsIl9wdXNoQ29udGV4dCIsIl9wb3BDb250ZXh0IiwiX3BlZWtDb250ZXh0IiwiY3JlYXRlIiwiZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyIsImFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzIiwiSCIsIl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayIsImlzRnVsZmlsbGVkIiwidmFsdWUiLCJTIiwiTiIsIl9wYXJlbnQiLCJhdHRhY2hFeHRyYVRyYWNlIiwiX19zdGFja0NsZWFuZWRfXyIsImoiLCJub3RFbnVtZXJhYmxlUHJvcCIsImpvaW4iLCJXIiwiX3JldHVybmVkTm9uVW5kZWZpbmVkIiwic3BsaXQiLCJ3IiwiVSIsIm1hdGNoIiwiTSIsInYiLCJ5Iiwib3QiLCJ3YXJuaW5ncyIsIkwiLCJsb25nU3RhY2tUcmFjZXMiLCJFIiwibSIsImciLCJzcGxpY2UiLCJxIiwibnQiLCJjaGFyQXQiLCJDIiwiUSIsIlN0cmluZyIsIkQiLCJrIiwiSSIsInR0IiwiRiIsIngiLCJzdWJzdHIiLCJUIiwiaXQiLCJQIiwicnQiLCJmaWxlTmFtZSIsImxpbmUiLCJSIiwiQiIsIl9wcm9taXNlc0NyZWF0ZWQiLCJ1bmN5Y2xlIiwiTyIsIkEiLCJWIiwiX2dldERvbWFpbiIsIldhcm5pbmciLCJjYW5BdHRhY2hUcmFjZSIsIkciLCJlbnYiLCJ6IiwiWCIsInN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucyIsIl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQiLCJfc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQiLCJfbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uIiwiX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCIsIl9zZXRSZXR1cm5lZE5vblVuZGVmaW5lZCIsIl9pc1JlamVjdGlvblVuaGFuZGxlZCIsIl9zZXR0bGVkVmFsdWUiLCJfc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCIsIl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQiLCJfaXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCIsIl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkIiwib25Qb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiIsImRvbWFpbkJpbmQiLCJvblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQiLCJLIiwiX2NhcHR1cmVTdGFja1RyYWNlIiwiaGFzTG9uZ1N0YWNrVHJhY2VzIiwiSiIsIkN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInRvTG93ZXJDYXNlIiwiZGV0YWlsIiwiY2FuY2VsYWJsZSIsIkV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsIlkiLCJpc05vZGUiLCJlbWl0IiwiWiIsInByb21pc2VDcmVhdGVkIiwicHJvbWlzZUZ1bGZpbGxlZCIsInByb21pc2VSZWplY3RlZCIsInByb21pc2VSZXNvbHZlZCIsInByb21pc2VDYW5jZWxsZWQiLCJwcm9taXNlQ2hhaW5lZCIsImNoaWxkIiwid2FybmluZyIsInVuaGFuZGxlZFJlamVjdGlvbiIsInJlYXNvbiIsInJlamVjdGlvbkhhbmRsZWQiLCJjb25maWciLCJPYmplY3QiLCJ3Rm9yZ290dGVuUmV0dXJuIiwiX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSIsIl9leGVjdXRlIiwiZXQiLCJtb25pdG9yaW5nIiwiX2ZpcmVFdmVudCIsImluaGVyaXRzIiwic3RhY2tUcmFjZUxpbWl0IiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJpbmRleE9mIiwid2FybiIsImlzVFRZIiwiY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zIiwic2V0Qm91bmRzIiwiZGVwcmVjYXRlZCIsImZpcmVEb21FdmVudCIsImZpcmVHbG9iYWxFdmVudCIsInRoZW5SZXR1cm4iLCJ0aGVuVGhyb3ciLCJjYXRjaFRocm93IiwiY2F1Z2h0IiwiY2F0Y2hSZXR1cm4iLCJyZWR1Y2UiLCJlYWNoIiwibWFwU2VyaWVzIiwiY29uc3RydWN0b3IiLCJjYXVzZSIsImlzT3BlcmF0aW9uYWwiLCJmcmVlemUiLCJSYW5nZUVycm9yIiwiQXJyYXkiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsIl9fQmx1ZWJpcmRFcnJvclR5cGVzX18iLCJDYW5jZWxsYXRpb25FcnJvciIsIlRpbWVvdXRFcnJvciIsIk9wZXJhdGlvbmFsRXJyb3IiLCJSZWplY3Rpb25FcnJvciIsIkFnZ3JlZ2F0ZUVycm9yIiwiZ2V0RGVzY3JpcHRvciIsImdldFByb3RvdHlwZU9mIiwiaXNFUzUiLCJwcm9wZXJ0eUlzV3JpdGFibGUiLCJzZXQiLCJoYXNPd25Qcm9wZXJ0eSIsIm1hcCIsImhhbmRsZXIiLCJjYWxsZWQiLCJjYW5jZWxQcm9taXNlIiwiZmluYWxseUhhbmRsZXIiLCJpc0ZpbmFsbHlIYW5kbGVyIiwiaXNSZWplY3RlZCIsIl9wYXNzVGhyb3VnaCIsImxhc3RseSIsInRhcCIsIl9maW5hbGx5UHJvbWlzZSIsIl9wcm9taXNlIiwiX3N0YWNrIiwiX2dlbmVyYXRvckZ1bmN0aW9uIiwiX3JlY2VpdmVyIiwiX2dlbmVyYXRvciIsIl95aWVsZEhhbmRsZXJzIiwiY29uY2F0IiwiX3lpZWxkZWRQcm9taXNlIiwiX2NhbmNlbGxhdGlvblBoYXNlIiwiX2lzUmVzb2x2ZWQiLCJfY2xlYW51cCIsIl9mdWxmaWxsIiwiX3Byb21pc2VDYW5jZWxsZWQiLCJjb3JvdXRpbmUiLCJyZXR1cm5TZW50aW5lbCIsIl9jb250aW51ZSIsIl9wcm9taXNlRnVsZmlsbGVkIiwibmV4dCIsIl9wcm9taXNlUmVqZWN0ZWQiLCJfcnVuIiwiX3JlamVjdENhbGxiYWNrIiwiZG9uZSIsIl9wcm94eSIsIl92YWx1ZSIsIl9yZWFzb24iLCJ5aWVsZEhhbmRsZXIiLCJhZGRZaWVsZEhhbmRsZXIiLCJzcGF3biIsInNwcmVhZCIsImNvbnN0cnVjdG9yJCIsIl9jYWxsYmFjayIsIl9wcmVzZXJ2ZWRWYWx1ZXMiLCJfbGltaXQiLCJfaW5GbGlnaHQiLCJfcXVldWUiLCJfYXN5bmNJbml0IiwiY29uY3VycmVuY3kiLCJpc0Zpbml0ZSIsIl9pbml0JCIsIl9pbml0IiwiX3ZhbHVlcyIsIl90b3RhbFJlc29sdmVkIiwiX2ZpbHRlciIsIl9yZXNvbHZlIiwicHJlc2VydmVkVmFsdWVzIiwibWV0aG9kIiwiX3Jlc29sdmVGcm9tU3luY1ZhbHVlIiwiYXR0ZW1wdCIsIm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbiIsIm1heWJlV3JhcEFzRXJyb3IiLCJhc0NhbGxiYWNrIiwibm9kZWlmeSIsIl9mdWxmaWxsbWVudEhhbmRsZXIwIiwiX3JlamVjdGlvbkhhbmRsZXIwIiwiX3Byb21pc2UwIiwiX3JlY2VpdmVyMCIsIl9yZXNvbHZlRnJvbUV4ZWN1dG9yIiwiUHJvbWlzZUluc3BlY3Rpb24iLCJkb21haW4iLCJyZWZsZWN0IiwiX3NldElzRmluYWwiLCJ0b0pTT04iLCJmdWxmaWxsbWVudFZhbHVlIiwicmVqZWN0aW9uUmVhc29uIiwib3JpZ2luYXRlc0Zyb21SZWplY3Rpb24iLCJnZXROZXdMaWJyYXJ5Q29weSIsImlzIiwiZnJvbU5vZGUiLCJmcm9tQ2FsbGJhY2siLCJtdWx0aUFyZ3MiLCJfaXNGYXRlU2VhbGVkIiwiX3NldEFzeW5jR3VhcmFudGVlZCIsImNhc3QiLCJfc2V0RnVsZmlsbGVkIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJfc2V0dGxlUHJvbWlzZUN0eCIsIl9zZXR0bGVQcm9taXNlTGF0ZUNhbmNlbGxhdGlvbk9ic2VydmVyIiwicmVjZWl2ZXIiLCJfYWRkQ2FsbGJhY2tzIiwiX3NldExlbmd0aCIsIl9zZXRSZWplY3RlZCIsIl9zZXRGb2xsb3dpbmciLCJfaXNGaW5hbCIsIl91bnNldENhbmNlbGxlZCIsIl9yZWNlaXZlckF0IiwiX3Byb21pc2VBdCIsIl9mdWxmaWxsbWVudEhhbmRsZXJBdCIsIl9yZWplY3Rpb25IYW5kbGVyQXQiLCJfbWlncmF0ZUNhbGxiYWNrMCIsIl9taWdyYXRlQ2FsbGJhY2tBdCIsIl9zZXRGb2xsb3dlZSIsImVuc3VyZUVycm9yT2JqZWN0IiwiX3NldHRsZVByb21pc2VGcm9tSGFuZGxlciIsIl9zZXR0bGVQcm9taXNlIiwiX3NldHRsZVByb21pc2UwIiwiX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleCIsIl9mdWxmaWxsUHJvbWlzZXMiLCJfcmVqZWN0UHJvbWlzZXMiLCJkZWZlciIsInBlbmRpbmciLCJ2ZXJzaW9uIiwidG9GYXN0UHJvcGVydGllcyIsImxhc3RMaW5lRXJyb3IiLCJhc0FycmF5IiwiX3Jlc29sdmVFbXB0eUFycmF5IiwiX2l0ZXJhdGUiLCJnZXRBY3R1YWxMZW5ndGgiLCJzaG91bGRDb3B5VmFsdWVzIiwiX19pc1Byb21pc2lmaWVkX18iLCJnZXREYXRhUHJvcGVydHlPckRlZmF1bHQiLCJpbmhlcml0ZWREYXRhS2V5cyIsIndpdGhBcHBlbmRlZCIsInByb21pc2lmeSIsImNvbnRleHQiLCJjb3B5RGVzY3JpcHRvcnMiLCJwcm9taXNpZnlBbGwiLCJzdWZmaXgiLCJwcm9taXNpZmllciIsImlzQ2xhc3MiLCJfaXNNYXAiLCJwcm9wcyIsInNpemUiLCJfY2FwYWNpdHkiLCJfZnJvbnQiLCJfd2lsbEJlT3ZlckNhcGFjaXR5IiwiX2NoZWNrQ2FwYWNpdHkiLCJfcmVzaXplVG8iLCJyYWNlIiwiX2ZuIiwiX2luaXRpYWxWYWx1ZSIsIl9jdXJyZW50Q2FuY2VsbGFibGUiLCJfZWFjaFZhbHVlcyIsImFjY3VtIiwiYXJyYXkiLCJfZ290QWNjdW0iLCJpbmRleCIsIl9lYWNoQ29tcGxldGUiLCJfcmVzdWx0Q2FuY2VsbGVkJCIsImdldE5hdGl2ZVByb21pc2UiLCJNdXRhdGlvbk9ic2VydmVyIiwic2V0SW1tZWRpYXRlIiwibmV4dFRpY2siLCJpc1JlY2VudE5vZGUiLCJuYXZpZ2F0b3IiLCJzdGFuZGFsb25lIiwiY29yZG92YSIsImNyZWF0ZUVsZW1lbnQiLCJhdHRyaWJ1dGVzIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJfcHJvbWlzZVJlc29sdmVkIiwiX3NldHRsZWRWYWx1ZUZpZWxkIiwic2V0dGxlIiwiX2hvd01hbnkiLCJfdW53cmFwIiwiX2luaXRpYWxpemVkIiwiX2NhblBvc3NpYmx5RnVsZmlsbCIsIl9nZXRSYW5nZUVycm9yIiwiaG93TWFueSIsIl9hZGRGdWxmaWxsZWQiLCJfZnVsZmlsbGVkIiwiX2FkZFJlamVjdGVkIiwiX2NoZWNrT3V0Y29tZSIsIl9yZWplY3RlZCIsInNvbWUiLCJpc1Jlc29sdmVkIiwiX19pc0NhbmNlbGxlZCIsImhhbmRsZSIsImNsZWFyVGltZW91dCIsImRlbGF5IiwidGltZW91dCIsIl9pc0Rpc3Bvc2FibGUiLCJfZ2V0RGlzcG9zZXIiLCJfc2V0RGlzcG9zYWJsZSIsInRyeURpc3Bvc2UiLCJfZGF0YSIsIl9jb250ZXh0IiwiaXNEaXNwb3NlciIsInJlc291cmNlcyIsInJlc291cmNlIiwiZG9EaXNwb3NlIiwiX3Vuc2V0RGlzcG9zYWJsZSIsInVzaW5nIiwiX2Rpc3Bvc2VyIiwiZGlzcG9zZXIiLCJGdW5jdGlvbiIsInRocm93ZXIiLCJpc1ByaW1pdGl2ZSIsImlzRXJyb3IiLCJmaWxsZWRSYW5nZSIsImNocm9tZSIsImxvYWRUaW1lcyIsImhhc0VudlZhcmlhYmxlcyIsInZlcnNpb25zIiwibm9kZSIsIk51bWJlciIsIlNFQVJDSF9CQVJfU0VMRUNUT1IiLCJTRUFSQ0hfRE9QUExFX1NFTEVDVE9SIiwiUExBWUxJU1RfUkVTVUxUU19TRUxFQ1RPUiIsIlNPTkdfUkVTVUxUU19TRUxFQ1RPUiIsIl9zb25nc01hdGNoaW5nIiwic2VhcmNoS2V5Iiwic2VhcmNoS2V5RXhwIiwiX3BsYXlsaXN0c01hdGNoaW5nIiwiJHNlYXJjaEJhciIsIiRzZWFyY2hEb3BwbGUiLCIkc29uZ1Jlc3VsdHMiLCIkcGxheWxpc3RSZXN1bHRzIiwibWF0Y2hpbmdTb25ncyIsIm1hdGNoaW5nUGxheWxpc3RzIiwiU2VhcmNoVUkiLCJMT0dJTl9CVVRUT05fU0VMRUNUT1IiLCJMT0dJTl9GT1JNX1NFTEVDVE9SIiwiX3JlZGlyZWN0VG9BcHAiLCJzdWJtaXRGb3JtSGFuZGxlciIsImxvZ2luSW5mbyIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJMb2dpblVJIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFD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OztBQUVBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esd0NBQXVDLG9CQUFvQixFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7Ozs7OztBQ2hMQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuSkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLGFBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5aUJBOzs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTJGOztBQUUzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2p1QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcERBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRyxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRyxZQUFZOztBQUVmO0FBQ0E7QUFDQTtBQUNBLE1BQUssWUFBWTtBQUNqQjtBQUNBOzs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMEIsaURBQWlEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDREQUEyRDtBQUMzRDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxVQUFVO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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VUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O21DQzNCQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBLE1BQUs7QUFDTCw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7Ozs7Ozs7OztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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QUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0T0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLFlBQVk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTLE9BQU87QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxZQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHlDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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YXNCLFNBQXRCLEVBQWlDZ3JCLGNBQWpDO0FBQ0gsRUFyQkQ7O0FBdUJBLEtBQU1LLFVBQVUsU0FBVkEsT0FBVSxHQUFXO0FBQ3ZCOXNCO0FBQ0gsRUFGRDs7bUJBSWU4c0IsTyIsImZpbGUiOiJtdXNpYy1hcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBmZmQ2YTQ4MWJhZmI4M2NlMDRlNSIsIi8vIEdsb2JhbFxuaW1wb3J0IEV2ZW50cyBmcm9tICcuL2dsb2JhbC9ldmVudHMnXG5pbXBvcnQgUmVxdWVzdCBmcm9tICcuL2dsb2JhbC9yZXF1ZXN0J1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vZ2xvYmFsL3V0aWxzJ1xuaW1wb3J0IFNvY2tldCBmcm9tICcuL2dsb2JhbC9zb2NrZXQnXG5cbi8vIENvbXBvbmVudHNcbmltcG9ydCB7IE5hdkJhclVJIH0gZnJvbSAnLi9jb21wb25lbnRzL25hdi1iYXInXG5pbXBvcnQgeyBQbGF5bGlzdFNlbGVjdG9yVUkgfSBmcm9tICcuL2NvbXBvbmVudHMvcGxheWxpc3Qtc2VsZWN0b3InXG5pbXBvcnQgeyBVc2VyU2VsZWN0b3JVSSB9IGZyb20gJy4vY29tcG9uZW50cy91c2VyLXNlbGVjdG9yJ1xuXG5cbi8vIFVJXG5pbXBvcnQgTGlicmFyeVVJIGZyb20gJy4vdWkvbGlicmFyeSdcbmltcG9ydCBQbGF5bGlzdHNVSSBmcm9tICcuL3VpL3BsYXlsaXN0cydcbmltcG9ydCBTZWFyY2hVSSBmcm9tICcuL3VpL3NlYXJjaCdcbmltcG9ydCBMb2dpblVJIGZyb20gICcuL3VpL2xvZ2luJ1xuXG5jb25zdCBfaW5pdGlhbFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgaXNMb2dpblBhZ2UgPSAvXlxcL2xvZ2luJC8udGVzdChsb2NhdGlvbi5wYXRobmFtZSlcbiAgICBjb25zdCBoaWRkZW5DbGFzcyA9ICd1LWhpZGRlbidcbiAgICBjb25zdCAkbG9naW5QYWdlID0gJCgnI2xvZ2luLXBhZ2UnKVxuICAgIGNvbnN0ICRwbGF5bGlzdEFwcCA9ICQoJyNwbGF5bGlzdC1hcHAnKVxuXG4gICAgaWYgKGlzTG9naW5QYWdlKSB7XG4gICAgICAgICRsb2dpblBhZ2UucmVtb3ZlQ2xhc3MoaGlkZGVuQ2xhc3MpXG4gICAgICAgICRwbGF5bGlzdEFwcC5hZGRDbGFzcyhoaWRkZW5DbGFzcylcbiAgICB9IGVsc2Uge1xuICAgICAgICAkcGxheWxpc3RBcHAucmVtb3ZlQ2xhc3MoaGlkZGVuQ2xhc3MpXG4gICAgICAgICRsb2dpblBhZ2UuYWRkQ2xhc3MoaGlkZGVuQ2xhc3MpXG4gICAgfVxufVxuXG5jb25zdCBfYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0ICRib2R5ID0gJCgnYm9keScpXG4gICAgJGJvZHkub24oRXZlbnRzLm5hbWVzLlBMQVlMSVNUU19VUERBVEVfTkVFREVELCAoKSA9PiB7XG4gICAgICAgIFJlcXVlc3QuZ2V0TXVzaWNEYXRhKCdwbGF5bGlzdHMnKS50aGVuKGZ1bmN0aW9uKHBsYXlsaXN0cykge1xuICAgICAgICAgICAgd2luZG93LlBMQVlMSVNUUyA9IHBsYXlsaXN0c1xuICAgICAgICAgICAgJGJvZHkudHJpZ2dlcihFdmVudHMubmFtZXMuUExBWUxJU1RTX1VQREFURUQpXG4gICAgICAgICAgICAkYm9keS50cmlnZ2VyKEV2ZW50cy5uYW1lcy5QTEFZTElTVF9TRUxFQ1RPUl9VUERBVEVfTkVFREVEKVxuICAgICAgICB9KVxuICAgIH0pXG59XG5cbmNvbnN0IGxvYWRNdXNpYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIFJlcXVlc3QuZ2V0TXVzaWNEYXRhKCdwbGF5bGlzdHMnKSxcbiAgICAgICAgUmVxdWVzdC5nZXRNdXNpY0RhdGEoJ3NvbmdzJylcbiAgICBdKS50aGVuKGZ1bmN0aW9uKG11c2ljRGF0YSkge1xuICAgICAgICBjb25zdCAkYm9keSA9ICQoJ2JvZHknKVxuICAgICAgICB3aW5kb3cuUExBWUxJU1RTID0gbXVzaWNEYXRhWzBdXG4gICAgICAgIHdpbmRvdy5TT05HUyA9IG11c2ljRGF0YVsxXVxuICAgICAgICAkYm9keS50cmlnZ2VyKEV2ZW50cy5uYW1lcy5TT05HU19VUERBVEVEKVxuICAgICAgICAkYm9keS50cmlnZ2VyKEV2ZW50cy5uYW1lcy5QTEFZTElTVFNfVVBEQVRFRClcbiAgICAgICAgJGJvZHkudHJpZ2dlcihFdmVudHMubmFtZXMuUExBWUxJU1RfU0VMRUNUT1JfVVBEQVRFX05FRURFRClcbiAgICB9KVxufVxuXG5jb25zdCBBcHAgPSAgZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LlVUSUxTID0gVXRpbHNcbiAgICBfYmluZEV2ZW50cygpXG5cbiAgICAvLyBMb2FkIFVJIGNvbXBvbmVudHMgLyBiaW5kIGV2ZW50c1xuICAgIE5hdkJhclVJKClcbiAgICBMb2dpblVJKClcbiAgICBMaWJyYXJ5VUkoKVxuICAgIFBsYXlsaXN0c1VJKClcbiAgICBTZWFyY2hVSSgpXG4gICAgUGxheWxpc3RTZWxlY3RvclVJKClcbiAgICBVc2VyU2VsZWN0b3JVSSgpXG4gICAgX2luaXRpYWxTdGF0ZSgpXG5cbiAgICBsb2FkTXVzaWMoKVxufVxuXG5BcHAoKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwcC9qcy9hcHAuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICwgQlJFQUsgICAgICAgPSB7fVxuICAsIFJFVFVSTiAgICAgID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUil7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIFNQRUNJRVMgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXtcbiAgICBpZihzYWZlICYmIHRhcmdldFtrZXldKXRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgRXZlbnRzID0ge31cbmNvbnN0ICRib2R5ID0gJCgnYm9keScpXG5cbkV2ZW50cy5uYW1lcyA9IHtcbiAgICBNVVNJQ19MT0FERUQ6ICdAQG11c2ljL0xPQURFRCcsXG4gICAgUExBWUxJU1RTX1VQREFURV9ORUVERUQ6ICdAQHBsYXlsaXN0cy9VUERBVEVfTkVFREVEJyxcbiAgICBQTEFZTElTVF9TRUxFQ1RPUl9VUERBVEVfTkVFREVEOiAnQEBwbGF5bGlzdC1zZWxlY3Rvci9VUERBVEVfTkVFREVEJyxcbiAgICBQTEFZTElTVFNfVVBEQVRFRDogJ0BAcGxheWxpc3RzL1VQREFURUQnLFxuICAgIFBMQVlMSVNUX0FEREVEOiAnQEBwbGF5bGlzdC9BRERFRCcsXG4gICAgUExBWUxJU1RfU09OR19BRERFRDogJ0BAcGxheWxpc3QvU09OR19BRERFRCcsXG4gICAgUExBWUxJU1RfU09OR19ERUxFVEVEOiAnQEBwbGF5bGlzdC9TT05HX0RFTEVURUQnLFxuICAgIFNJR05FRF9JTjogJ0BAdXNlci9TSUdORURfSU4nLFxuICAgIFNPTkdTX1VQREFURUQ6ICdAQHNvbmdzL1VQREFURUQnXG59XG5cbkV2ZW50cy50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICAkYm9keS50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkKVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcHAvanMvZ2xvYmFsL2V2ZW50cy5qcyIsImNvbnN0IFJlcXVlc3QgPSB7fVxuXG5SZXF1ZXN0LmdldE11c2ljRGF0YSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAkLmdldChgL2FwaS8ke2tleX1gLCAoZGF0YSwgc3RhdHVzLCB4aHIpID0+IHtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcmV0cmlldmUgJHtrZXl9YClcbiAgICAgICAgICAgICAgICByZWplY3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhW2tleV0pXG4gICAgICAgIH0pXG4gICAgfSlcbn1cblxuUmVxdWVzdC5nZXRVc2VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICQuZ2V0KCcvYXBpL3VzZXJzJywgKGRhdGEsIHN0YXR1cywgeGhyKSA9PiB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJldHJpZXZlICR7a2V5fWApXG4gICAgICAgICAgICAgICAgcmVqZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YS51c2VycylcbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5SZXF1ZXN0LmFkZE5ld1BsYXlsaXN0ID0gZnVuY3Rpb24ocGxheWxpc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAkLnBvc3QoJy9hcGkvcGxheWxpc3RzLycsIHBsYXlsaXN0LCAoZGF0YSwgc3RhdHVzLCB4aHIpID0+IHtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZWplY3QoYFsgUmVxdWVzdCBdIEZhaWxlZCB0byBhZGQgbmV3IHBsYXlsaXN0OiAke3N0YXR1c31gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKVxuICAgICAgICB9LCAnanNvbicpXG4gICAgfSlcbn1cblxuUmVxdWVzdC5hZGRTb25nVG9QbGF5bGlzdCA9IGZ1bmN0aW9uKHNvbmdJZCwgcGxheWxpc3RJZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGBhcGkvcGxheWxpc3RzLyR7cGxheWxpc3RJZH1gLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHtzb25nOiBzb25nSWR9KSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IChkYXRhLCBzdGF0dXMsIHhocikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGBbIFJlcXVlc3QgXSBGYWlsZWQgdG8gYWRkIHNvbmcgdG8gcGxheWxpc3Q6ICR7c3RhdHVzfWApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGBbIFJlcXVlc3QgXSBGYWlsZWQgdG8gYWRkIHNvbmcgdG8gcGxheWxpc3Q6ICR7c3RhdHVzfWApXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG59XG5cblJlcXVlc3QucmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCA9IGZ1bmN0aW9uKHNvbmdJZCwgcGxheWxpc3RJZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGAvcGxheWxpc3RzLyR7cGxheWxpc3RJZH1gLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIHR5cGU6ICdERUxFVEUnLFxuICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe3Nvbmc6IHNvbmdJZH0pLFxuICAgICAgICAgICAgc3VjY2VzczogKGRhdGEsIHN0YXR1cywgeGhyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoYFsgUmVxdWVzdCBdIEZhaWxlZCB0byByZW1vdmUgc29uZyBmcm9tIHBsYXlsaXN0OiAke3N0YXR1c31gKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5SZXF1ZXN0LnN1Ym1pdExvZ2luID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6ICcvbG9naW4nLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc3VjY2VzczogKGRhdGEsIHN0YXR1cywgeGhyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoYFsgUmVxdWVzdCBdIExvZ2luIEZhaWxlZGApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChgWyBSZXF1ZXN0IF0gTG9naW4gRmFpbGVkYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KVxuICAgIH0pXG59XG5cblJlcXVlc3QuZ3JhbnRVc2VyUGxheWxpc3RQZXJtaXNzaW9uID0gZnVuY3Rpb24oe3VzZXJJZCwgcGxheWxpc3RJZH0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiBgL2FwaS9wbGF5bGlzdHMvJHtwbGF5bGlzdElkfS91c2Vyc2AsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe3VzZXI6IHVzZXJJZH0pLFxuICAgICAgICAgICAgc3VjY2VzczogKGRhdGEsIHN0YXR1cywgeGhyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoYFsgUmVxdWVzdCBdIEZhaWxlZCB0byBncmFudCBwZXJtaXNzaW9uYClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGBbIFJlcXVlc3QgXSBGYWlsZWQgdG8gZ3JhbnQgcGVybWlzc2lvbmApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZXF1ZXN0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBwL2pzL2dsb2JhbC9yZXF1ZXN0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpXG4gICwgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHtzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgVXRpbHMgPSB7fVxuXG5VdGlscy5nZXRPYmpXaXRoSWQgPSBmdW5jdGlvbihhcnIsIGlkKSB7XG4gICAgaWYgKCFhcnIgfHwgYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIGNvbnN0IG9iaklkID0gcGFyc2VJbnQoaWQpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBhcnIuZmlsdGVyKG9iaiA9PiBvYmouaWQgPT09IG9iaklkKVxuXG4gICAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoID4gMCA/IG1hdGNoZXNbMF0gOiB1bmRlZmluZWRcbn1cblxuVXRpbHMuc29uZ0VsZW1lbnRGb3IgPSBmdW5jdGlvbihzb25nT2JqKSB7XG4gICAgY29uc3Qgc29uZ0VsQ2xhc3MgPSAnYy10YWJsZS1ncmlkX19pdGVtIGMtbGlicmFyeV9faXRlbSdcbiAgICBjb25zdCBzb25nRWxIVE1MID0gYDxkaXYgY2xhc3M9XCJjLWxpYnJhcnlfX2l0ZW0tY29udGVudCBjLXRhYmxlLWdyaWRfX2l0ZW0tY29udGVudFwiPjxpbWcgY2xhc3M9XCJjLWxpYnJhcnlfX2l0ZW0tYXJ0XCIgc3JjPVwiYXNzZXRzL3NvbmctYXJ0LTIwMC5qcGdcIiBhbHQ9XCJBbGJ1bSBBcnRcIj48ZGl2IGNsYXNzPVwiYy1saWJyYXJ5X19pdGVtLXRleHQgdS1mbGV4LWNvbCB1LS1taWRkbGVcIj48aDQ+ICR7c29uZ09iai50aXRsZX0gPC9oND48aDU+ICR7c29uZ09iai5hcnRpc3R9IDwvaDU+PC9kaXY+PGRpdiBjbGFzcz1cImMtbGlicmFyeV9faXRlbS1kaXNjbG9zdXJlXCI+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgbmFtZT1cIlBsYXlcIiBjbGFzcz1cImpzLXBsYXkgYy1idXR0b24gYy0tZGlzY2xvc3VyZSBnbHlwaGljb24gZ2x5cGhpY29uLXBsYXlcIj48L2J1dHRvbj48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBuYW1lPVwiQWRkIFRvIFBsYXlsaXN0XCIgY2xhc3M9XCJqcy1hZGQtdG8tcGxheWxpc3QgYy1idXR0b24gYy0tZGlzY2xvc3VyZSBnbHlwaGljb24gZ2x5cGhpY29uLXBsdXMtc2lnblwiPjwvYnV0dG9uPjxidXR0b24gdHlwZT1cImJ1dHRvblwiIG5hbWU9XCJSZW1vdmUgZnJvbSBQbGF5bGlzdFwiIGNsYXNzPVwianMtcmVtb3ZlLWZyb20tcGxheWxpc3QgYy1yZW1vdmUtZnJvbS1wbGF5bGlzdCBjLWJ1dHRvbiBjLS1kaXNjbG9zdXJlIGdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlXCI+PC9idXR0b24+PC9kaXY+PC9kaXY+YFxuXG4gICAgcmV0dXJuICQoJzxkaXY+PC9kaXY+JylcbiAgICAgICAgLmFkZENsYXNzKHNvbmdFbENsYXNzKVxuICAgICAgICAuYXR0cignZGF0YS1pZCcsIHNvbmdPYmouaWQpXG4gICAgICAgIC5odG1sKHNvbmdFbEhUTUwpXG59XG5cblV0aWxzLnBsYXlsaXN0RWxlbWVudEZvciA9IGZ1bmN0aW9uKHBsYXlsaXN0T2JqKSB7XG4gICAgY29uc3QgcGxheWxpc3RFbENsYXNzID0gJ2MtdGFibGUtZ3JpZF9faXRlbSBjLXBsYXlsaXN0X19pdGVtJ1xuICAgIGNvbnN0IHBsYXlsaXN0RWxIVE1MID0gYDxkaXYgY2xhc3M9XCJjLXBsYXlsaXN0X19pdGVtLWNvbnRlbnQgYy10YWJsZS1ncmlkX19pdGVtLWNvbnRlbnRcIj48aW1nIGNsYXNzPVwiYy1wbGF5bGlzdF9faXRlbS1hcnRcIiBzcmM9XCJhc3NldHMvcGxheWxpc3QtYXJ0LTIwMC5qcGdcIiBhbHQ9XCJQbGF5bGlzdCBBcnRcIj48ZGl2IGNsYXNzPVwiYy1wbGF5bGlzdF9faXRlbS10ZXh0IHUtZmxleC1jb2wgdS0tbWlkZGxlXCI+PGg0PiAke3BsYXlsaXN0T2JqLm5hbWV9IDwvaDQ+PC9kaXY+PGRpdiBjbGFzcz1cImMtcGxheWxpc3RfX2l0ZW0tZGlzY2xvc3VyZVwiPjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XCI+PC9zcGFuPjwvZGl2PjwvZGl2PmBcblxuICAgIHJldHVybiAkKCc8ZGl2PjwvZGl2PicpXG4gICAgICAgIC5hZGRDbGFzcyhwbGF5bGlzdEVsQ2xhc3MpXG4gICAgICAgIC5hdHRyKCdkYXRhLWlkJywgcGxheWxpc3RPYmouaWQpXG4gICAgICAgIC5odG1sKHBsYXlsaXN0RWxIVE1MKVxufVxuXG5VdGlscy5hZGRTb25nVG9QbGF5bGlzdCA9IGZ1bmN0aW9uKHNvbmdJZCwgcGxheWxpc3RPYmopIHtcbiAgICBjb25zdCBzb25nSWRJbnQgPSBwYXJzZUludChzb25nSWQpXG4gICAgaWYgKCEhcGxheWxpc3RPYmogJiYgIXBsYXlsaXN0T2JqLnNvbmdzLmluY2x1ZGVzKHNvbmdJZEludCkpIHtcbiAgICAgICAgcGxheWxpc3RPYmouc29uZ3MucHVzaChzb25nSWRJbnQpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5VdGlscy5yZW1vdmVTb25nRnJvbVBsYXlsaXN0ID0gZnVuY3Rpb24oc29uZ0lkLCBwbGF5bGlzdE9iaikge1xuICAgIGNvbnN0IHNvbmdJZEludCA9IHBhcnNlSW50KHNvbmdJZClcbiAgICBpZiAoIXBsYXlsaXN0T2JqLnNvbmdzLmluY2x1ZGVzKHNvbmdJZCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcGxheWxpc3RPYmouc29uZ3MgPSBwbGF5bGlzdE9iai5zb25ncy5maWx0ZXIoKGN1cnJlbnRTb25nSWQpID0+IGN1cnJlbnRTb25nSWQgIT09IHNvbmdJZEludClcbn1cblxuZXhwb3J0IGRlZmF1bHQgVXRpbHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcHAvanMvZ2xvYmFsL3V0aWxzLmpzIiwiaW1wb3J0IGlvIGZyb20gJ3NvY2tldC5pby1jbGllbnQnXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vZXZlbnRzJ1xuXG5jb25zdCBTb2NrZXQgPSB7fVxuXG5Tb2NrZXQuZXZlbnRzID0ge1xuICAgIFBMQVlMSVNUX1NPTkdfQURERUQ6ICdAQHBsYXlsaXN0L1NPTkdfQURERUQnLFxuICAgIFBMQVlMSVNUX1NPTkdfREVMRVRFRDogJ0BAcGxheWxpc3QvU09OR19ERUxFVEVEJ1xufTtcblxuU29ja2V0LmxvZyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBjb25zb2xlLmxvZyhgWyBTT0NLRVQgXSAke21lc3NhZ2V9YCk7XG59XG5cblNvY2tldC5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zb2NrZXQgPSBpby5jb25uZWN0KCcvJylcbiAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHRoaXMubG9nKGBDb25uZWN0ZWQuYCkpXG4gICAgdGhpcy5zb2NrZXQub24oJ2V2ZW50JywgX3NvY2tldEV2ZW50SGFuZGxlcilcbn1cblxuY29uc3QgX3NvY2tldEV2ZW50SGFuZGxlciA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgY29uc3QgcGxheWxpc3RPYmogPSBqc29uRGF0YS5wbGF5bGlzdFxuICAgICAgICA/IFVUSUxTLmdldE9ialdpdGhJZChQTEFZTElTVFMsIGpzb25EYXRhLnBsYXlsaXN0KVxuICAgICAgICA6IG51bGxcblxuICAgIFNvY2tldC5sb2coYCR7anNvbkRhdGEuZXZlbnR9IHRyaWdnZXJlZC5gKVxuXG4gICAgc3dpdGNoKGpzb25EYXRhLmV2ZW50KSB7XG4gICAgICAgIGNhc2UgU29ja2V0LmV2ZW50cy5QTEFZTElTVF9TT05HX0FEREVEOlxuICAgICAgICAgICAgaWYgKCFVVElMUy5hZGRTb25nVG9QbGF5bGlzdChqc29uRGF0YS5zb25nLCBwbGF5bGlzdE9iaikpIHJldHVyblxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoRXZlbnRzLm5hbWVzLlBMQVlMSVNUX1NPTkdfQURERUQsIHtwbGF5bGlzdElkOiBqc29uRGF0YS5wbGF5bGlzdCwgc29uZ0lkOiBqc29uRGF0YS5zb25nfSlcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgU29ja2V0LmV2ZW50cy5QTEFZTElTVF9TT05HX0RFTEVURUQ6XG4gICAgICAgICAgICBVVElMUy5yZW1vdmVTb25nRnJvbVBsYXlsaXN0KGpzb25EYXRhLnNvbmcsIHBsYXlsaXN0T2JqKVxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoRXZlbnRzLm5hbWVzLlBMQVlMSVNUX1NPTkdfREVMRVRFRCwge3BsYXlsaXN0SWQ6IGpzb25EYXRhLnBsYXlsaXN0LCBzb25nSWQ6IGpzb25EYXRhLnNvbmd9KVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU29ja2V0XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwcC9qcy9nbG9iYWwvc29ja2V0LmpzIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAgKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cbiAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cyAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9wdHMucXVlcnkpIHtcbiAgICBvcHRzLnF1ZXJ5ID0gZW5jb2RlUXVlcnlTdHJpbmcob3B0cy5xdWVyeSk7XG4gIH1cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG4vKipcbiAqICBIZWxwZXIgbWV0aG9kIHRvIHBhcnNlIHF1ZXJ5IG9iamVjdHMgdG8gc3RyaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IHF1ZXJ5XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVRdWVyeVN0cmluZyAob2JqKSB7XG4gIHZhciBzdHIgPSBbXTtcbiAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICBzdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW3BdKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHIuam9pbignJicpO1xufVxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsICh1cmksIGxvYykge1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBQYXJzZXMgYW4gVVJJXHJcbiAqXHJcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XHJcblxyXG52YXIgcGFydHMgPSBbXHJcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcclxuXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XHJcbiAgICB2YXIgc3JjID0gc3RyLFxyXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxyXG4gICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxyXG4gICAgICAgIHVyaSA9IHt9LFxyXG4gICAgICAgIGkgPSAxNDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG4gICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XHJcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XHJcbiAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1cmk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZXVyaS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1jbGllbnQvfi9kZWJ1Zy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnLmRlYnVnID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nXG4gICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvW1xcXFxeJCs/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2V0LmlvLWNsaWVudC9+L2RlYnVnL2RlYnVnLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwXG52YXIgbSA9IHMgKiA2MFxudmFyIGggPSBtICogNjBcbnZhciBkID0gaCAqIDI0XG52YXIgeSA9IGQgKiAzNjUuMjVcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWxcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgP1xuXHRcdFx0Zm10TG9uZyh2YWwpIDpcblx0XHRcdGZtdFNob3J0KHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKClcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZFxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbVxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogc1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCdcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCdcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSdcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncydcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnXG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnXG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWVcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2V0LmlvLWNsaWVudC9+L21zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIganNvbiA9IHJlcXVpcmUoJ2pzb24zJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBuc3AgPSBmYWxzZTtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHN0ciArPSBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG4gICAgc3RyICs9ICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG4gICAgbnNwID0gdHJ1ZTtcbiAgICBzdHIgKz0gb2JqLm5zcDtcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBpZiAobnNwKSB7XG4gICAgICBzdHIgKz0gJywnO1xuICAgICAgbnNwID0gZmFsc2U7XG4gICAgfVxuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuICAgIHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIHAgPSB7fTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGxvb2sgdXAgdHlwZVxuICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHAgPSB0cnlQYXJzZShwLCBzdHIuc3Vic3RyKGkpKTtcbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHAsIHN0cikge1xuICB0cnkge1xuICAgIHAuZGF0YSA9IGpzb24ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcDsgXG59O1xuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoZGF0YSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZWJ1Zy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZWJ1Zy9kZWJ1Zy5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanNvbjMvbGliL2pzb24zLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICBmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cbiAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgIHJldHVybiBidWY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1wYXJzZXIvfi9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogSUU2KyBoYXNPd25Qcm9wZXJ0eVxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlciAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RpbmcgPSBbXTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IHBhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5lbmdpbmUuaWQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZm4sIG9wdHMpIHtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuZW1pdEFsbCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlKCkgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24gKG5zcCwgb3B0cykge1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZW5naW5lLmlkO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2bmV0IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZyAoKSB7XG4gICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbiAoZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcblxuICB2YXIgc3Vic0xlbmd0aCA9IHRoaXMuc3Vicy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpO1xuICAgIHN1Yi5kZXN0cm95KCk7XG4gIH1cblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ29uY2xvc2UnKTtcblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaW5kZXgnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlanNvbiA9IHJlcXVpcmUoJ3BhcnNlanNvbicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuICAgIDogKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgID8gbG9jYXRpb24ucG9ydFxuICAgICAgOiAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG4gIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG4gIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG4gIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG4gIH1cblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSAhIW9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwpIHtcbiAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubG9jYWxBZGRyZXNzKSB7XG4gICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBvbiBoYW5kc2hha2VcbiAgdGhpcy5pZCA9IG51bGw7XG4gIHRoaXMudXBncmFkZXMgPSBudWxsO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuXG4gIC8vIHNldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogdGhpcy5wYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBmb3JjZUpTT05QOiB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IHRoaXMuanNvbnAsXG4gICAgZm9yY2VCYXNlNjQ6IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuICAgIHBvbGljeVBvcnQ6IHRoaXMucG9saWN5UG9ydCxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgcGZ4OiB0aGlzLnBmeCxcbiAgICBrZXk6IHRoaXMua2V5LFxuICAgIHBhc3NwaHJhc2U6IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiB0aGlzLmNlcnQsXG4gICAgY2E6IHRoaXMuY2EsXG4gICAgY2lwaGVyczogdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICBmb3JjZU5vZGU6IHRoaXMuZm9yY2VOb2RlLFxuICAgIGxvY2FsQWRkcmVzczogdGhpcy5sb2NhbEFkZHJlc3NcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9PSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICB0cnkge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pO1xuICB2YXIgZmFpbGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuICgpIHtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT09IG1zZy50eXBlICYmICdwcm9iZScgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCAoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlICgpIHtcbiAgICBvbmVycm9yKCd0cmFuc3BvcnQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSAoKSB7XG4gICAgb25lcnJvcignc29ja2V0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlICh0bykge1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGF0YSkge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UgKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlICgpIHtcbiAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKV0oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhcy1jb3JzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUiAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdCAob3B0cykge1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJyovKicpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY2xlYW51cCh0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoZnJvbUVycm9yKSB7XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICB9XG5cbiAgaWYgKGZyb21FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpLnNwbGl0KCc7JylbMF07XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2UgfHwgdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHZhciB1aThBcnIgPSBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSk7XG4gICAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IHVpOEFyci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKHVpOEFycltpZHhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChvblBhdXNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UgKCkge1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgICgnaHR0cCcgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnd3RmLTgnKTtcblxudmFyIGJhc2U2NGVuY29kZXI7XG5pZiAoZ2xvYmFsICYmIGdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHV0ZjhlbmNvZGUpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWJhc2U2NGVuY29kZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJydcbiAgICAsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKCc6JyAhPSBjaHIpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXJyLnR5cGUgPT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgICBpICs9IG47XG4gICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gIH1cblxuICBpZiAobGVuZ3RoICE9ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgdmFyIG51bWJlclRvb0xvbmcgPSBmYWxzZTtcbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICBudW1iZXJUb29Mb25nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgaWYobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIEdldHMgdGhlIGtleXMgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuICB2YXIgYXJyID0gW107XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICAgICAgaWYgKG9iai50b0pTT04gJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhcy1iaW5hcnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGFzLWJpbmFyeS9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWZ0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3d0ZjggdjEuMC4wIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gd3RmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlLlxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIHRoZSBmaXJzdCBieXRlLlxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0dmFyIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBXVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gd3RmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHd0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMS4wLjAnLFxuXHRcdCdlbmNvZGUnOiB3dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB3dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gd3RmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHd0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB3dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwod3RmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHd0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC53dGY4ID0gd3RmODtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93dGYtOC93dGYtOC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbigpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcblxuICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gIHZhciBsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzEpXTtcbiAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMildO1xuICAgICAgZW5jb2RlZDQgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSszKV07XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jsb2IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcclxuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgdmFyIHN0ciA9ICcnO1xyXG5cclxuICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcclxuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHFzXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xyXG4gIHZhciBxcnkgPSB7fTtcclxuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XHJcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcclxuICB9XHJcbiAgcmV0dXJuIHFyeTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlcXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG4gIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcbiAgZm4ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGZuO1xuICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veWVhc3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9+L2RlYnVnL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWcuZGVidWcgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmdcbiAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9bXFxcXF4kKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L34vZGVidWcvZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwXG52YXIgbSA9IHMgKiA2MFxudmFyIGggPSBtICogNjBcbnZhciBkID0gaCAqIDI0XG52YXIgeSA9IGQgKiAzNjUuMjVcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWxcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbClcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgP1xuXHRcdFx0Zm10TG9uZyh2YWwpIDpcblx0XHRcdGZtdFNob3J0KHZhbClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArIEpTT04uc3RyaW5naWZ5KHZhbCkpXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKVxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKClcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZFxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbVxuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogc1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCdcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCdcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSdcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncydcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnXG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnXG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWVcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9+L21zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJywgZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpZiAoaW5zZXJ0QXQpIHtcbiAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgfSBlbHNlIHtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJyArIHNlbGYuaWZyYW1lSWQgKyAnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG52YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbnZhciBOb2RlV2ViU29ja2V0O1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQgJiYgIW9wdHMuZm9yY2VOb2RlO1xuICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgV2ViU29ja2V0ID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkICgwKTtcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPSB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyB3cyAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2luZGV4b2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogSlNPTiBwYXJzZS5cclxuICpcclxuICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcclxudmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XHJcbnZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XHJcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XHJcbnZhciBydHJpbUxlZnQgPSAvXlxccysvO1xyXG52YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XHJcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XHJcblxyXG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxyXG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcclxuICB9XHJcblxyXG4gIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcclxuICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXHJcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xyXG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XHJcbiAgfVxyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZWpzb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBoYXNCaW4gPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBjb25uZWN0aW5nOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDEsXG4gIHBpbmc6IDEsXG4gIHBvbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0IChpbywgbnNwLCBvcHRzKSB7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgaWYgKG9wdHMgJiYgb3B0cy5xdWVyeSkge1xuICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB9XG4gIGlmICh0aGlzLmlvLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuc3ViRXZlbnRzKCk7XG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgZW1pdGAuXG4gKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuICBpZiAoaGFzQmluKGFyZ3MpKSB7IHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UOyB9IC8vIGJpbmFyeVxuICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXJUeXBlLCBkYXRhOiBhcmdzIH07XG5cbiAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICBkZWxldGUgdGhpcy5mbGFncztcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiB0aGlzLnF1ZXJ5fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFja2V0KHt0eXBlOiBwYXJzZXIuQ09OTkVDVH0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5pZDtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAocGFja2V0Lm5zcCAhPT0gdGhpcy5uc3ApIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgdmFyIHR5cGUgPSBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0s7XG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFjaykge1xuICAgIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcbiAgdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfHwge307XG4gIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1jbGllbnQvbGliL3NvY2tldC5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NrZXQuaW8tY2xpZW50L34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RvLWFycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvbXBvbmVudC1iaW5kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFja28yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi9vdmVybGF5J1xuXG5jb25zdCBOYXZCYXIgPSB7fVxuXG5OYXZCYXIuc2V0VGFiVmlld0FjdGl2ZSA9IGZ1bmN0aW9uKCR0YWJWaWV3KSB7XG4gICAgY29uc3QgYWN0aXZlQ2xhc3MgPSAnYy0tYWN0aXZlJ1xuXG4gICAgJCgnLnQtdGFiJykucmVtb3ZlQ2xhc3MoYWN0aXZlQ2xhc3MpXG4gICAgJHRhYlZpZXcuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpXG59XG5cbk5hdkJhci5zZXRUYWJBY3RpdmUgPSBmdW5jdGlvbigkdGFiLCBwdXNoU3RhdGUpIHtcbiAgICBjb25zdCB0YWIgPSAkdGFiLmRhdGEoJ3RhYicpXG4gICAgY29uc3QgYWN0aXZlVGFiVmlld1NlbGVjdG9yID0gYCMke3RhYn0tdGFiLWNvbnRlbnRgXG5cbiAgICBfaGlnaGxpZ2h0VGFiKCR0YWIpXG4gICAgTmF2QmFyLnNldFRhYlZpZXdBY3RpdmUoJChhY3RpdmVUYWJWaWV3U2VsZWN0b3IpKVxuXG4gICAgaWYgKHB1c2hTdGF0ZSkge1xuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7J3RhYic6IHRhYn0sIHRhYiwgJy8nICsgdGFiKVxuICAgIH1cbn1cblxuY29uc3QgX2JpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5jLW5hdi1iYXJfX3RhYicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICBPdmVybGF5LmhpZGUoKVxuXG4gICAgICAgIGNvbnN0ICRzZWxlY3RlZFRhYiA9ICQodGhpcylcbiAgICAgICAgTmF2QmFyLnNldFRhYkFjdGl2ZSgkc2VsZWN0ZWRUYWIsIHRydWUpXG4gICAgfSlcbn1cblxuY29uc3QgX2hpZ2hsaWdodFRhYiA9IGZ1bmN0aW9uKCR0YWIpIHtcbiAgICBjb25zdCBhY3RpdmVDbGFzcyA9ICdjLS1hY3RpdmUnXG4gICAgY29uc3QgdGFiID0gJHRhYi5kYXRhKCd0YWInKVxuICAgIGNvbnN0IGFjdGl2ZVRhYlZpZXdTZWxlY3RvciA9IGAjJHt0YWJ9LXRhYi1jb250ZW50YFxuXG4gICAgJCgnLmMtbmF2LWJhcl9fdGFiJykucmVtb3ZlQ2xhc3MoYWN0aXZlQ2xhc3MpXG4gICAgJHRhYi5hZGRDbGFzcyhhY3RpdmVDbGFzcylcbn1cblxuY29uc3QgX3NlbGVjdEluaXRpYWxUYWIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBwYXRoTWF0Y2hlc1RhYiA9IGZ1bmN0aW9uKHRhYikge1xuICAgICAgICByZXR1cm4gKG5ldyBSZWdFeHAoJ14vJyArIHRhYiArICcoKC9cXFxcLiopfCMpPycpKS50ZXN0KGxvY2F0aW9uLnBhdGhuYW1lKVxuICAgIH1cblxuICAgIGlmIChwYXRoTWF0Y2hlc1RhYignbGlicmFyeScpKSB7XG4gICAgICAgIE5hdkJhci5zZXRUYWJBY3RpdmUoJCgnLmMtbmF2LWJhcl9fdGFiW2RhdGEtdGFiPWxpYnJhcnldJykpXG4gICAgfSBlbHNlIGlmIChwYXRoTWF0Y2hlc1RhYignc2VhcmNoJykpIHtcbiAgICAgICAgTmF2QmFyLnNldFRhYkFjdGl2ZSgkKCcuYy1uYXYtYmFyX190YWJbZGF0YS10YWI9c2VhcmNoXScpKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIE5hdkJhci5zZXRUYWJBY3RpdmUoJCgnLmMtbmF2LWJhcl9fdGFiW2RhdGEtdGFiPXBsYXlsaXN0c10nKSlcbiAgICB9XG59XG5cbmNvbnN0IE5hdkJhclVJID0gZnVuY3Rpb24oKSB7XG4gICAgX2JpbmRFdmVudHMoKVxuICAgIF9zZWxlY3RJbml0aWFsVGFiKClcbn1cblxuZXhwb3J0IHsgTmF2QmFyLCBOYXZCYXJVSSB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBwL2pzL2NvbXBvbmVudHMvbmF2LWJhci5qcyIsImNvbnN0IE9WRVJMQVlfU0VMRUNUT1IgPSAnLmMtb3ZlcmxheSdcbmNvbnN0IFZJU0lCTEVfQ0xBU1MgPSAnYy0tdmlzaWJsZSdcbmNvbnN0IEhJRERFTl9DTEFTUyA9ICd1LWhpZGRlbidcblxuY29uc3QgT3ZlcmxheSA9IHt9XG5cbk92ZXJsYXkuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICQoT1ZFUkxBWV9TRUxFQ1RPUikuYWRkQ2xhc3MoVklTSUJMRV9DTEFTUylcbn1cblxuT3ZlcmxheS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgJChPVkVSTEFZX1NFTEVDVE9SKS5yZW1vdmVDbGFzcyhWSVNJQkxFX0NMQVNTKVxuICAgICQoJy5qcy1vdmVybGF5LW1vZGFsJykuYWRkQ2xhc3MoSElEREVOX0NMQVNTKVxufVxuXG5jb25zdCBfYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICQoJ2JvZHknKS5vbignY2xpY2snLCBPVkVSTEFZX1NFTEVDVE9SLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgaWYgKHRoaXMgPT09IGUudGFyZ2V0KSB7XG4gICAgICAgICAgICBPdmVybGF5LmhpZGUoKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuY29uc3QgX092ZXJsYXlVSSA9IGZ1bmN0aW9uKCkge1xuICAgIF9iaW5kRXZlbnRzKClcbn1cblxuX092ZXJsYXlVSSgpXG5cbmV4cG9ydCBkZWZhdWx0IE92ZXJsYXlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcHAvanMvY29tcG9uZW50cy9vdmVybGF5LmpzIiwiaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9nbG9iYWwvZXZlbnRzJ1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnLi4vZ2xvYmFsL3JlcXVlc3QnXG5cbmltcG9ydCBPdmVybGF5IGZyb20gJy4vb3ZlcmxheSdcblxuY29uc3QgTElTVF9TRUxfU0VMRUNUT1IgPSAnLmpzLXBsYXlsaXN0LXNlbGVjdG9yJ1xuY29uc3QgUExBWUxJU1RfTElTVF9TRUxFQ1RPUiA9ICcjcGxheWxpc3QtbGlzdC1zZWxlY3RvcidcbmNvbnN0IEhJRERFTl9DTEFTUyA9ICd1LWhpZGRlbidcblxuY29uc3QgUGxheWxpc3RTZWxlY3RvciA9IHt9XG5cblBsYXlsaXN0U2VsZWN0b3Iuc2hvd1NlbGVjdGlvbkZvciA9IGZ1bmN0aW9uKHNvbmdJZCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdGhlIGNvbnRlbnQgYmVoaW5kIHRoZSBvdmVybGF5IHRvIGJlIHNjcm9sbGFibGVcbiAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ3Utbm8tc2Nyb2xsJylcbiAgICBPdmVybGF5LnNob3coKVxuXG4gICAgY29uc3QgJHBsYXlsaXN0U2VsID0gJChMSVNUX1NFTF9TRUxFQ1RPUilcbiAgICAkcGxheWxpc3RTZWwucmVtb3ZlQ2xhc3MoSElEREVOX0NMQVNTKS5kYXRhKCdzb25nLWlkJywgc29uZ0lkKVxufVxuXG5QbGF5bGlzdFNlbGVjdG9yLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ3Utbm8tc2Nyb2xsJylcbiAgICBPdmVybGF5LmhpZGUoKVxufVxuXG5QbGF5bGlzdFNlbGVjdG9yLmFkZFBsYXlsaXN0ID0gZnVuY3Rpb24ocGxheWxpc3RPYmopIHtcbiAgICBjb25zdCAkcGxheWxpc3RMaXN0ID0gJChQTEFZTElTVF9MSVNUX1NFTEVDVE9SKVxuICAgIGNvbnN0ICRzZWxlY3RvckVsID0gJCgnPGxpPjwvbGk+JylcbiAgICBjb25zdCBzZWxlY3RvckNsYXNzID0gJ2MtbGlzdC1zZWxlY3Rvcl9faXRlbSdcblxuICAgICRzZWxlY3RvckVsXG4gICAgICAgIC5hZGRDbGFzcyhzZWxlY3RvckNsYXNzKVxuICAgICAgICAudGV4dChwbGF5bGlzdE9iai5uYW1lKVxuICAgICAgICAuZGF0YSgnaWQnLCBwbGF5bGlzdE9iai5pZClcblxuICAgICRwbGF5bGlzdExpc3QuYXBwZW5kKCRzZWxlY3RvckVsWzBdKVxufVxuXG5jb25zdCBfYWRkUGxheWxpc3RzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkLmlzQXJyYXkoUExBWUxJU1RTKSB8fCBQTEFZTElTVFMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCAkcGxheWxpc3RMaXN0ID0gJChQTEFZTElTVF9MSVNUX1NFTEVDVE9SKVxuICAgICRwbGF5bGlzdExpc3QuaHRtbCgnJylcbiAgICBQTEFZTElTVFMuZm9yRWFjaChQbGF5bGlzdFNlbGVjdG9yLmFkZFBsYXlsaXN0KVxufVxuXG5jb25zdCBfYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0ICRib2R5ID0gJCgnYm9keScpXG4gICAgY29uc3QgJHBsYXlsaXN0U2VsID0gJChMSVNUX1NFTF9TRUxFQ1RPUilcbiAgICBjb25zdCAkbGlzdFNlbENsb3NlQnRuID0gJCgnLmpzLXBsYXlsaXN0LXNlbGVjdG9yIC5jLWxpc3Qtc2VsZWN0b3JfX2Nsb3NlLWJ1dHRvbicpXG5cbiAgICAkbGlzdFNlbENsb3NlQnRuLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICBQbGF5bGlzdFNlbGVjdG9yLmhpZGUoKVxuICAgIH0pXG5cbiAgICAkYm9keS5vbignY2xpY2snLCAnLmpzLXBsYXlsaXN0LXNlbGVjdG9yIC5jLWxpc3Qtc2VsZWN0b3JfX2l0ZW0nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRTb25nSWQgPSAkcGxheWxpc3RTZWwuZGF0YSgnc29uZy1pZCcpXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUGxheWxpc3RJZCA9ICQodGhpcykuZGF0YSgnaWQnKVxuICAgICAgICBjb25zdCBwbGF5bGlzdE9iaiA9IFVUSUxTLmdldE9ialdpdGhJZChQTEFZTElTVFMsIHNlbGVjdGVkUGxheWxpc3RJZClcbiAgICAgICAgaWYgKCFwbGF5bGlzdE9iai5zb25ncy5pbmNsdWRlcyhwYXJzZUludChzZWxlY3RlZFNvbmdJZCkpKSB7XG4gICAgICAgICAgICBSZXF1ZXN0LmFkZFNvbmdUb1BsYXlsaXN0KHNlbGVjdGVkU29uZ0lkLCBzZWxlY3RlZFBsYXlsaXN0SWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIFVUSUxTLmFkZFNvbmdUb1BsYXlsaXN0KHNlbGVjdGVkU29uZ0lkLCBwbGF5bGlzdE9iailcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgUGxheWxpc3RTZWxlY3Rvci5oaWRlKClcbiAgICB9KVxuXG4gICAgJGJvZHkub24oRXZlbnRzLm5hbWVzLlBMQVlMSVNUX0FEREVELCBmdW5jdGlvbihlLCBwbGF5bGlzdE9iaikge1xuICAgICAgICBQbGF5bGlzdFNlbGVjdG9yLmFkZFBsYXlsaXN0KHBsYXlsaXN0T2JqKVxuICAgIH0pXG5cbiAgICAkYm9keS5vbihFdmVudHMubmFtZXMuUExBWUxJU1RfU0VMRUNUT1JfVVBEQVRFX05FRURFRCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIF9hZGRQbGF5bGlzdHMoKVxuICAgIH0pXG59XG5cbmNvbnN0IFBsYXlsaXN0U2VsZWN0b3JVSSA9IGZ1bmN0aW9uKCkge1xuICAgIF9iaW5kRXZlbnRzKClcbn1cblxuZXhwb3J0IHsgUGxheWxpc3RTZWxlY3RvciwgUGxheWxpc3RTZWxlY3RvclVJIH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcHAvanMvY29tcG9uZW50cy9wbGF5bGlzdC1zZWxlY3Rvci5qcyIsImltcG9ydCBFdmVudHMgZnJvbSAnLi4vZ2xvYmFsL2V2ZW50cydcbmltcG9ydCBSZXF1ZXN0IGZyb20gJy4uL2dsb2JhbC9yZXF1ZXN0J1xuXG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuL292ZXJsYXknXG5cbmNvbnN0IExJU1RfU0VMX1NFTEVDVE9SID0gJy5qcy11c2VyLXNlbGVjdG9yJ1xuY29uc3QgVVNFUl9MSVNUX1NFTEVDVE9SID0gJyN1c2VyLWxpc3Qtc2VsZWN0b3InXG5jb25zdCBISURERU5fQ0xBU1MgPSAndS1oaWRkZW4nXG5cbmNvbnN0IFVzZXJTZWxlY3RvciA9IHt9XG5cblVzZXJTZWxlY3Rvci5zaG93U2VsZWN0aW9uRm9yID0gZnVuY3Rpb24ocGxheWxpc3RJZCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdGhlIGNvbnRlbnQgYmVoaW5kIHRoZSBvdmVybGF5IHRvIGJlIHNjcm9sbGFibGVcbiAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ3Utbm8tc2Nyb2xsJylcbiAgICBPdmVybGF5LnNob3coKVxuICAgIFJlcXVlc3QuZ2V0VXNlcnMoKS50aGVuKGZ1bmN0aW9uKHVzZXJzKSB7XG4gICAgICAgIF9hZGRVc2Vycyh1c2VycylcbiAgICB9KVxuICAgIGNvbnN0ICR1c2VyU2VsZWN0b3IgPSAkKExJU1RfU0VMX1NFTEVDVE9SKVxuICAgICR1c2VyU2VsZWN0b3IucmVtb3ZlQ2xhc3MoSElEREVOX0NMQVNTKS5kYXRhKCdwbGF5bGlzdC1pZCcsIHBsYXlsaXN0SWQpXG59XG5cblVzZXJTZWxlY3Rvci5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCd1LW5vLXNjcm9sbCcpXG4gICAgT3ZlcmxheS5oaWRlKClcbn1cblxuVXNlclNlbGVjdG9yLmFkZFVzZXIgPSBmdW5jdGlvbih1c2VyT2JqKSB7XG4gICAgY29uc3QgJHVzZXJMaXN0ID0gJChVU0VSX0xJU1RfU0VMRUNUT1IpXG4gICAgY29uc3QgJHNlbGVjdG9yRWwgPSAkKCc8bGk+PC9saT4nKVxuICAgIGNvbnN0IHNlbGVjdG9yQ2xhc3MgPSAnYy1saXN0LXNlbGVjdG9yX19pdGVtJ1xuXG4gICAgJHNlbGVjdG9yRWxcbiAgICAgICAgLmFkZENsYXNzKHNlbGVjdG9yQ2xhc3MpXG4gICAgICAgIC50ZXh0KHVzZXJPYmoubmFtZSlcbiAgICAgICAgLmRhdGEoJ2lkJywgdXNlck9iai5pZClcblxuICAgICR1c2VyTGlzdC5hcHBlbmQoJHNlbGVjdG9yRWxbMF0pXG59XG5cbmNvbnN0IF9hZGRVc2VycyA9IGZ1bmN0aW9uKHVzZXJzKSB7XG4gICAgaWYgKCEkLmlzQXJyYXkodXNlcnMpIHx8IHVzZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgJHVzZXJMaXN0ID0gJChVU0VSX0xJU1RfU0VMRUNUT1IpXG4gICAgJHVzZXJMaXN0Lmh0bWwoJycpXG4gICAgdXNlcnMuZm9yRWFjaChVc2VyU2VsZWN0b3IuYWRkVXNlcilcbn1cblxuY29uc3QgX2JpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCAkYm9keSA9ICQoJ2JvZHknKVxuICAgIGNvbnN0ICR1c2VyU2VsZWN0b3IgPSAkKExJU1RfU0VMX1NFTEVDVE9SKVxuICAgIGNvbnN0ICR1c2VyU2VsQ2xvc2VCdG4gPSAkKCcuanMtdXNlci1zZWxlY3RvciAuYy1saXN0LXNlbGVjdG9yX19jbG9zZS1idXR0b24nKVxuXG4gICAgJHVzZXJTZWxDbG9zZUJ0bi5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgVXNlclNlbGVjdG9yLmhpZGUoKVxuICAgIH0pXG5cbiAgICAkYm9keS5vbignY2xpY2snLCAnLmpzLXVzZXItc2VsZWN0b3IgLmMtbGlzdC1zZWxlY3Rvcl9faXRlbScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICBjb25zdCBzZWxlY3RlZFBsYXlsaXN0SWQgPSAkdXNlclNlbGVjdG9yLmRhdGEoJ3BsYXlsaXN0LWlkJylcbiAgICAgICAgY29uc3QgdXNlcklkID0gJCh0aGlzKS5kYXRhKCdpZCcpXG5cbiAgICAgICAgUmVxdWVzdC5ncmFudFVzZXJQbGF5bGlzdFBlcm1pc3Npb24oe1xuICAgICAgICAgICAgdXNlcklkOiB1c2VySWQsXG4gICAgICAgICAgICBwbGF5bGlzdElkOiBzZWxlY3RlZFBsYXlsaXN0SWRcbiAgICAgICAgfSlcbiAgICAgICAgLy8gY29uc3QgcGxheWxpc3RPYmogPSBVVElMUy5nZXRPYmpXaXRoSWQoUExBWUxJU1RTLCBzZWxlY3RlZFBsYXlsaXN0SWQpXG4gICAgICAgIC8vIGlmICghcGxheWxpc3RPYmouc29uZ3MuaW5jbHVkZXMocGFyc2VJbnQoc2VsZWN0ZWRTb25nSWQpKSkge1xuICAgICAgICAvLyAgICAgUmVxdWVzdC5hZGRTb25nVG9QbGF5bGlzdChzZWxlY3RlZFNvbmdJZCwgc2VsZWN0ZWRQbGF5bGlzdElkKVxuICAgICAgICAvLyAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyAgICAgICAgICAgICBVVElMUy5hZGRTb25nVG9QbGF5bGlzdChzZWxlY3RlZFNvbmdJZCwgcGxheWxpc3RPYmopXG4gICAgICAgIC8vICAgICAgICAgfSlcbiAgICAgICAgLy8gICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycilcbiAgICAgICAgLy8gICAgICAgICB9KVxuICAgICAgICAvLyB9XG4gICAgICAgIFVzZXJTZWxlY3Rvci5oaWRlKClcbiAgICB9KVxufVxuXG5jb25zdCBVc2VyU2VsZWN0b3JVSSA9IGZ1bmN0aW9uKCkge1xuICAgIF9iaW5kRXZlbnRzKClcbn1cblxuZXhwb3J0IHsgVXNlclNlbGVjdG9yLCBVc2VyU2VsZWN0b3JVSSB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBwL2pzL2NvbXBvbmVudHMvdXNlci1zZWxlY3Rvci5qcyIsImltcG9ydCB7IFBsYXlsaXN0U2VsZWN0b3IgfSBmcm9tICcuLi9jb21wb25lbnRzL3BsYXlsaXN0LXNlbGVjdG9yJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9nbG9iYWwvZXZlbnRzJ1xuXG5jb25zdCBUSVRMRV9TT1JUX0tFWSA9ICd0aXRsZSdcbmNvbnN0IEFSVElTVF9TT1JUX0tFWSA9ICdhcnRpc3QnXG5cbmxldCBUSVRMRV9TT1JURURfU09OR1MgPSB1bmRlZmluZWRcbmxldCBBUlRJU1RfU09SVEVEX1NPTkdTID0gdW5kZWZpbmVkXG5cbmNvbnN0IF9nZXRTb25nc1NvcnRlZEJ5ID0gZnVuY3Rpb24oc29ydEtleSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBleGNsdXNpb25SZWdFeCA9IG5ldyBSZWdFeHAoJ15UaGUoXFxcXHMpKycsICdpJylcbiAgICAgICAgY29uc3QgaW5Bc2NlbmRpbmdPcmRlciA9IGFbc29ydEtleV0ucmVwbGFjZShleGNsdXNpb25SZWdFeCwgJycpIDw9IGJbc29ydEtleV0ucmVwbGFjZShleGNsdXNpb25SZWdFeCwgJycpXG4gICAgICAgIHJldHVybiBpbkFzY2VuZGluZ09yZGVyID8gLTEgOiAxXG4gICAgfVxuXG4gICAgc3dpdGNoIChzb3J0S2V5KSB7XG4gICAgICAgIGNhc2UgVElUTEVfU09SVF9LRVk6XG4gICAgICAgICAgICBpZiAoIVRJVExFX1NPUlRFRF9TT05HUykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZFNvbmdzID0gU09OR1Muc29ydChjb21wYXJhdG9yKVxuICAgICAgICAgICAgICAgIFRJVExFX1NPUlRFRF9TT05HUyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc29ydGVkU29uZ3MpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRJVExFX1NPUlRFRF9TT05HU1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCFBUlRJU1RfU09SVEVEX1NPTkdTKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkU29uZ3MgPSBTT05HUy5zb3J0KGNvbXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgQVJUSVNUX1NPUlRFRF9TT05HUyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc29ydGVkU29uZ3MpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFSVElTVF9TT1JURURfU09OR1NcbiAgICB9XG59XG5cbmNvbnN0IF9sb2FkU29uZ3NTb3J0ZWRCeSA9IGZ1bmN0aW9uKHNvcnRLZXkpIHtcbiAgICBpZiAoISQuaXNBcnJheShTT05HUykgfHwgU09OR1MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICAkKCcjbGlicmFyeScpLmh0bWwoJycpXG4gICAgY29uc3Qgc29ydGVkU29uZ3MgPSBfZ2V0U29uZ3NTb3J0ZWRCeShzb3J0S2V5KVxuXG4gICAgc29ydGVkU29uZ3MuZm9yRWFjaCgoc29uZ09iaikgPT4ge1xuICAgICAgICBsaWJyYXJ5LmFwcGVuZChVVElMUy5zb25nRWxlbWVudEZvcihzb25nT2JqKVswXSlcbiAgICB9KVxufVxuXG5jb25zdCBfYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGFjdGl2ZUNsYXNzID0gJ2MtLWFjdGl2ZSdcbiAgICBjb25zdCAkYm9keSA9ICQoJ2JvZHknKVxuXG4gICAgJGJvZHkub24oJ2NsaWNrJywgJy5qcy1hZGQtdG8tcGxheWxpc3QnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgICAgICBjb25zdCAkc29uZ0VsID0gJCh0aGlzKS5jbG9zZXN0KCcuYy1saWJyYXJ5X19pdGVtJylcbiAgICAgICAgUGxheWxpc3RTZWxlY3Rvci5zaG93U2VsZWN0aW9uRm9yKCRzb25nRWwuZGF0YSgnaWQnKSlcbiAgICB9KVxuXG4gICAgJCgnLmpzLWxpYnJhcnktc29ydC1idXR0b24nKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgICAgICAvLyBTZXQgYnV0dG9uIGFjdGl2ZVxuICAgICAgICBjb25zdCAkc2VsZWN0ZWRCdG4gPSAkKHRoaXMpXG4gICAgICAgICQoJy5qcy1saWJyYXJ5LXNvcnQtYnV0dG9uJykucmVtb3ZlQ2xhc3MoYWN0aXZlQ2xhc3MpXG4gICAgICAgICRzZWxlY3RlZEJ0bi5hZGRDbGFzcyhhY3RpdmVDbGFzcylcblxuICAgICAgICBfbG9hZFNvbmdzU29ydGVkQnkoJHNlbGVjdGVkQnRuLmRhdGEoJ2tleScpKVxuICAgIH0pXG5cbiAgICAkYm9keS5vbihFdmVudHMubmFtZXMuU09OR1NfVVBEQVRFRCwgZnVuY3Rpb24oZSkge1xuICAgICAgICBfbG9hZFNvbmdzU29ydGVkQnkoQVJUSVNUX1NPUlRfS0VZKVxuICAgIH0pXG59XG5cbmNvbnN0IExpYnJhcnlVSSA9IGZ1bmN0aW9uKCkge1xuICAgIF9iaW5kRXZlbnRzKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlicmFyeVVJXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBwL2pzL3VpL2xpYnJhcnkuanMiLCJpbXBvcnQgRXZlbnRzIGZyb20gJy4uL2dsb2JhbC9ldmVudHMnXG5pbXBvcnQgUmVxdWVzdCBmcm9tICcuLi9nbG9iYWwvcmVxdWVzdCdcblxuaW1wb3J0IHsgTmF2QmFyIH0gZnJvbSAnLi4vY29tcG9uZW50cy9uYXYtYmFyJ1xuaW1wb3J0IHsgQWRkUGxheWxpc3RGb3JtLCBBZGRQbGF5bGlzdEZvcm1VSSB9IGZyb20gJy4uL2NvbXBvbmVudHMvYWRkLXBsYXlsaXN0LWZvcm0nXG5pbXBvcnQgeyBVc2VyU2VsZWN0b3IgfSBmcm9tICcuLi9jb21wb25lbnRzL3VzZXItc2VsZWN0b3InXG5cbmNvbnN0IFBsYXlsaXN0cyA9IHt9XG5cblBsYXlsaXN0cy5hZGQgPSBmdW5jdGlvbihwbGF5bGlzdE9iaikge1xuICAgIGNvbnN0ICRwbGF5bGlzdCA9ICQoJyNwbGF5bGlzdHMnKVxuICAgIGNvbnN0ICRwbGF5bGlzdEVsID0gVVRJTFMucGxheWxpc3RFbGVtZW50Rm9yKHBsYXlsaXN0T2JqKVxuICAgICRwbGF5bGlzdC5hcHBlbmQoJHBsYXlsaXN0RWxbMF0pXG59XG5cbmNvbnN0IF9sb2FkUGxheWxpc3RzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkLmlzQXJyYXkoUExBWUxJU1RTKSB8fCBQTEFZTElTVFMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBDbGVhciBhbGwgcGxheWxpc3RzXG4gICAgJCgnI3BsYXlsaXN0cycpLmh0bWwoJycpXG4gICAgUExBWUxJU1RTLmZvckVhY2goUGxheWxpc3RzLmFkZCk7XG59XG5cbmNvbnN0IF9iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgJGJvZHkgPSAkKCdib2R5JylcblxuICAgICRib2R5Lm9uKCdjbGljaycsICcuYy1wbGF5bGlzdF9faXRlbScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgICAgIGNvbnN0ICRwbGF5bGlzdERldGFpbFZpZXcgPSAkKCcjcGxheWxpc3QtZGV0YWlscycpXG4gICAgICAgIGNvbnN0ICRzZWxlY3RlZFBsYXlsaXN0ID0gJCh0aGlzKVxuICAgICAgICBjb25zdCBwbGF5bGlzdElkID0gJHNlbGVjdGVkUGxheWxpc3QuZGF0YSgnaWQnKVxuICAgICAgICBjb25zdCBwbGF5bGlzdE9iaiA9IFVUSUxTLmdldE9ialdpdGhJZChQTEFZTElTVFMsIHBsYXlsaXN0SWQpXG5cbiAgICAgICAgY29uc3QgJHBsYXlsaXN0SGVhZGVyID0gJCgnLmMtcGxheWxpc3QtZGV0YWlsc19faGVhZGluZy1jb250YWluZXIgaDEnKVxuICAgICAgICBjb25zdCAkcGxheWxpc3RTb25nTGlzdCA9ICQoJyNwbGF5bGlzdC1zb25nLWxpc3QnKS5odG1sKCcnKVxuXG4gICAgICAgICRwbGF5bGlzdEhlYWRlci50ZXh0KHBsYXlsaXN0T2JqLm5hbWUpXG4gICAgICAgICRwbGF5bGlzdERldGFpbFZpZXcuZGF0YSgncGxheWxpc3QtaWQnLCBwbGF5bGlzdElkKVxuXG4gICAgICAgIHBsYXlsaXN0T2JqLnNvbmdzLmZvckVhY2goKHNvbmdJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgJHNvbmdFbCA9IFVUSUxTLnNvbmdFbGVtZW50Rm9yKFVUSUxTLmdldE9ialdpdGhJZChTT05HUywgc29uZ0lkKSlcbiAgICAgICAgICAgICRwbGF5bGlzdFNvbmdMaXN0LmFwcGVuZCgkc29uZ0VsWzBdKVxuICAgICAgICB9KVxuICAgICAgICBOYXZCYXIuc2V0VGFiVmlld0FjdGl2ZSgkcGxheWxpc3REZXRhaWxWaWV3KVxuICAgIH0pXG5cbiAgICAkYm9keS5vbignY2xpY2snLCAnI3BsYXlsaXN0LWJ1dHRvbicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgQWRkUGxheWxpc3RGb3JtLnNob3coKVxuICAgIH0pXG5cbiAgICAkYm9keS5vbignY2xpY2snLCAnI3VzZXItYnV0dG9uJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBjb25zdCBwbGF5bGlzdERldGFpbHNJZCA9ICQoJyNwbGF5bGlzdC1kZXRhaWxzJykuZGF0YSgncGxheWxpc3QtaWQnKVxuICAgICAgICBVc2VyU2VsZWN0b3Iuc2hvd1NlbGVjdGlvbkZvcihwbGF5bGlzdERldGFpbHNJZClcbiAgICB9KVxuXG4gICAgJGJvZHkub24oJ2NsaWNrJywgJyNwbGF5bGlzdC1zb25nLWxpc3QgLmpzLXJlbW92ZS1mcm9tLXBsYXlsaXN0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBjb25zdCAkc29uZ0VsID0gJCh0aGlzKS5jbG9zZXN0KCcuYy1saWJyYXJ5X19pdGVtJylcbiAgICAgICAgY29uc3Qgc29uZ0lkID0gJHNvbmdFbC5kYXRhKCdpZCcpXG4gICAgICAgIGNvbnN0IHBsYXlsaXN0SWQgPSAkKCcjcGxheWxpc3QtZGV0YWlscycpLmRhdGEoJ3BsYXlsaXN0LWlkJylcblxuICAgICAgICBSZXF1ZXN0LnJlbW92ZVNvbmdGcm9tUGxheWxpc3Qoc29uZ0lkLCBwbGF5bGlzdElkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxheWxpc3RPYmogPSBVVElMUy5nZXRPYmpXaXRoSWQoUExBWUxJU1RTLCBwbGF5bGlzdElkKVxuICAgICAgICAgICAgICAgIFVUSUxTLnJlbW92ZVNvbmdGcm9tUGxheWxpc3Qoc29uZ0lkLCBwbGF5bGlzdE9iailcbiAgICAgICAgICAgICAgICAkc29uZ0VsLnJlbW92ZSgpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycilcbiAgICAgICAgICAgIH0pXG4gICAgfSlcblxuICAgICRib2R5Lm9uKEV2ZW50cy5uYW1lcy5QTEFZTElTVF9BRERFRCwgZnVuY3Rpb24oZSwgcGxheWxpc3RPYmopIHtcbiAgICAgICAgUGxheWxpc3RzLmFkZChwbGF5bGlzdE9iailcbiAgICB9KVxuXG4gICAgJGJvZHkub24oRXZlbnRzLm5hbWVzLlBMQVlMSVNUU19VUERBVEVELCBfbG9hZFBsYXlsaXN0cylcblxuICAgICRib2R5Lm9uKEV2ZW50cy5uYW1lcy5QTEFZTElTVF9TT05HX0FEREVELCBmdW5jdGlvbihlLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0ICRwbGF5bGlzdERldGFpbHMgPSAkKCcjcGxheWxpc3QtZGV0YWlscycpXG4gICAgICAgIGNvbnN0IHBsYXlsaXN0RGV0YWlsc0lkID0gJHBsYXlsaXN0RGV0YWlscy5kYXRhKCdwbGF5bGlzdC1pZCcpXG5cbiAgICAgICAgLy8gT25seSB1cGRhdGUgVUkgaWYgcGxheWxpc3QgaXMgYmVpbmcgdmlld2VkXG4gICAgICAgIGlmIChwYXlsb2FkLnBsYXlsaXN0SWQgIT0gcGxheWxpc3REZXRhaWxzSWQgfHwgISRwbGF5bGlzdERldGFpbHMuaGFzQ2xhc3MoJ2MtLWFjdGl2ZScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCAkc29uZ0VsID0gVVRJTFMuc29uZ0VsZW1lbnRGb3IoVVRJTFMuZ2V0T2JqV2l0aElkKFNPTkdTLCBwYXlsb2FkLnNvbmdJZCkpXG4gICAgICAgICQoJyNwbGF5bGlzdC1zb25nLWxpc3QnKS5hcHBlbmQoJHNvbmdFbFswXSlcbiAgICB9KVxuXG4gICAgJGJvZHkub24oRXZlbnRzLm5hbWVzLlBMQVlMSVNUX1NPTkdfREVMRVRFRCwgZnVuY3Rpb24oZSwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCAkcGxheWxpc3REZXRhaWxzID0gJCgnI3BsYXlsaXN0LWRldGFpbHMnKVxuICAgICAgICBjb25zdCBwbGF5bGlzdERldGFpbHNJZCA9ICRwbGF5bGlzdERldGFpbHMuZGF0YSgncGxheWxpc3QtaWQnKVxuXG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIFVJIGlmIHBsYXlsaXN0IGlzIGJlaW5nIHZpZXdlZFxuICAgICAgICBpZiAocGF5bG9hZC5wbGF5bGlzdElkICE9IHBsYXlsaXN0RGV0YWlsc0lkIHx8ICEkcGxheWxpc3REZXRhaWxzLmhhc0NsYXNzKCdjLS1hY3RpdmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJChgI3BsYXlsaXN0LXNvbmctbGlzdCAuYy1saWJyYXJ5X19pdGVtW2RhdGEtaWQ9JHtwYXlsb2FkLnNvbmdJZH1dYCkucmVtb3ZlKClcbiAgICB9KVxufVxuXG5jb25zdCBQbGF5bGlzdHNVSSA9IGZ1bmN0aW9uKCkge1xuICAgIEFkZFBsYXlsaXN0Rm9ybVVJKClcbiAgICBfYmluZEV2ZW50cygpXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYXlsaXN0c1VJXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBwL2pzL3VpL3BsYXlsaXN0cy5qcyIsImltcG9ydCBFdmVudHMgZnJvbSAnLi4vZ2xvYmFsL2V2ZW50cydcbmltcG9ydCBSZXF1ZXN0IGZyb20gJy4uL2dsb2JhbC9yZXF1ZXN0J1xuXG5pbXBvcnQgT3ZlcmxheSBmcm9tICcuL292ZXJsYXknXG5cbmNvbnN0IEFERF9CVE5fU0VMRUNUT1IgPSAnLmMtYWRkLXBsYXlsaXN0LWZvcm0gLmpzLWFkZCdcbmNvbnN0IENBTkNFTF9CVE5fU0VMRUNUT1IgPSAnLmMtYWRkLXBsYXlsaXN0LWZvcm0gLmpzLWNhbmNlbCdcbmNvbnN0IEZPUk1fQ09OVEFJTkVSX1NFTEVDVE9SID0gJy5jLWFkZC1wbGF5bGlzdC1mb3JtX19jb250YWluZXInXG5jb25zdCBGT1JNX1NFTEVDVE9SID0gJy5jLWFkZC1wbGF5bGlzdC1mb3JtX19jb250YWluZXIgZm9ybSdcbmNvbnN0IE5BTUVfSU5QVVRfU0VMRUNUT1IgPSAnLmpzLXBsYXlsaXN0LW5hbWUtaW5wdXQnXG5jb25zdCBISURERU5fQ0xBU1MgPSAndS1oaWRkZW4nXG5cbmNvbnN0IEFkZFBsYXlsaXN0Rm9ybSA9IHt9XG5cbkFkZFBsYXlsaXN0Rm9ybS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgY29udGVudCBiZWhpbmQgdGhlIG92ZXJsYXkgdG8gYmUgc2Nyb2xsYWJsZVxuICAgICQoJ2JvZHknKS5hZGRDbGFzcygndS1uby1zY3JvbGwnKVxuICAgIE92ZXJsYXkuc2hvdygpXG4gICAgJChGT1JNX0NPTlRBSU5FUl9TRUxFQ1RPUikucmVtb3ZlQ2xhc3MoSElEREVOX0NMQVNTKVxuICAgICQoTkFNRV9JTlBVVF9TRUxFQ1RPUikuZm9jdXMoKVxufVxuXG5BZGRQbGF5bGlzdEZvcm0uaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygndS1uby1zY3JvbGwnKVxuICAgIE92ZXJsYXkuaGlkZSgpXG59XG5cbmNvbnN0IF9iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgJG5hbWVJbnB1dCA9ICQoTkFNRV9JTlBVVF9TRUxFQ1RPUilcbiAgICBjb25zdCBkaXNtaXNzRm9ybUhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgQWRkUGxheWxpc3RGb3JtLmhpZGUoKVxuICAgICAgICAkbmFtZUlucHV0LnZhbCgnJylcbiAgICB9XG4gICAgY29uc3QgZm9ybVN1Ym1pc3Npb25IYW5kbGVyID0gYXN5bmMgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAgIGNvbnN0IHBsYXlsaXN0ID0ge1xuICAgICAgICAgICAgJ25hbWUnOiAkbmFtZUlucHV0LnZhbCgpXG4gICAgICAgIH1cblxuICAgICAgICBSZXF1ZXN0XG4gICAgICAgICAgICAuYWRkTmV3UGxheWxpc3QocGxheWxpc3QpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihwbGF5bGlzdE9iaikge1xuICAgICAgICAgICAgICAgIHBsYXlsaXN0T2JqLnNvbmdzID0gcGxheWxpc3RPYmouc29uZ3MgfHwgW11cbiAgICAgICAgICAgICAgICBQTEFZTElTVFMucHVzaChwbGF5bGlzdE9iailcbiAgICAgICAgICAgICAgICAkKCdib2R5JykudHJpZ2dlcihFdmVudHMubmFtZXMuUExBWUxJU1RfQURERUQsIHBsYXlsaXN0T2JqKVxuICAgICAgICAgICAgICAgIGRpc21pc3NGb3JtSGFuZGxlcihlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpXG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgICQoRk9STV9TRUxFQ1RPUikub24oJ3N1Ym1pdCcsIGZvcm1TdWJtaXNzaW9uSGFuZGxlcilcbiAgICAkKENBTkNFTF9CVE5fU0VMRUNUT1IpLm9uKCdjbGljaycsIGRpc21pc3NGb3JtSGFuZGxlcilcbiAgICAkKEFERF9CVE5fU0VMRUNUT1IpLm9uKCdjbGljaycsIGZvcm1TdWJtaXNzaW9uSGFuZGxlcilcbn1cblxuY29uc3QgQWRkUGxheWxpc3RGb3JtVUkgPSBmdW5jdGlvbigpIHtcbiAgICBfYmluZEV2ZW50cygpXG59XG5cbmV4cG9ydCB7IEFkZFBsYXlsaXN0Rm9ybSwgQWRkUGxheWxpc3RGb3JtVUkgfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwcC9qcy9jb21wb25lbnRzL2FkZC1wbGF5bGlzdC1mb3JtLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBAcHJlc2VydmVcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSBQZXRrYSBBbnRvbm92XG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKiBcbiAqL1xuLyoqXG4gKiBibHVlYmlyZCBidWlsZCB2ZXJzaW9uIDMuNC43XG4gKiBGZWF0dXJlcyBlbmFibGVkOiBjb3JlLCByYWNlLCBjYWxsX2dldCwgZ2VuZXJhdG9ycywgbWFwLCBub2RlaWZ5LCBwcm9taXNpZnksIHByb3BzLCByZWR1Y2UsIHNldHRsZSwgc29tZSwgdXNpbmcsIHRpbWVycywgZmlsdGVyLCBhbnksIGVhY2hcbiovXG4hZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9dCgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSx0KTtlbHNle3ZhciBlO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/ZT13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9lPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGU9c2VsZiksZS5Qcm9taXNlPXQoKX19KGZ1bmN0aW9uKCl7dmFyIHQsZSxuO3JldHVybiBmdW5jdGlvbiByKHQsZSxuKXtmdW5jdGlvbiBpKHMsYSl7aWYoIWVbc10pe2lmKCF0W3NdKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBfZGVyZXFfJiZfZGVyZXFfO2lmKCFhJiZjKXJldHVybiBjKHMsITApO2lmKG8pcmV0dXJuIG8ocywhMCk7dmFyIGw9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitzK1wiJ1wiKTt0aHJvdyBsLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsbH12YXIgdT1lW3NdPXtleHBvcnRzOnt9fTt0W3NdWzBdLmNhbGwodS5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbc11bMV1bZV07cmV0dXJuIGkobj9uOmUpfSx1LHUuZXhwb3J0cyxyLHQsZSxuKX1yZXR1cm4gZVtzXS5leHBvcnRzfWZvcih2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBfZGVyZXFfJiZfZGVyZXFfLHM9MDtzPG4ubGVuZ3RoO3MrKylpKG5bc10pO3JldHVybiBpfSh7MTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ZhciBlPW5ldyBuKHQpLHI9ZS5wcm9taXNlKCk7cmV0dXJuIGUuc2V0SG93TWFueSgxKSxlLnNldFVud3JhcCgpLGUuaW5pdCgpLHJ9dmFyIG49dC5fU29tZVByb21pc2VBcnJheTt0LmFueT1mdW5jdGlvbih0KXtyZXR1cm4gZSh0KX0sdC5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKCl7cmV0dXJuIGUodGhpcyl9fX0se31dLDI6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7dGhpcy5fY3VzdG9tU2NoZWR1bGVyPSExLHRoaXMuX2lzVGlja1VzZWQ9ITEsdGhpcy5fbGF0ZVF1ZXVlPW5ldyB1KDE2KSx0aGlzLl9ub3JtYWxRdWV1ZT1uZXcgdSgxNiksdGhpcy5faGF2ZURyYWluZWRRdWV1ZXM9ITEsdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQ9ITA7dmFyIHQ9dGhpczt0aGlzLmRyYWluUXVldWVzPWZ1bmN0aW9uKCl7dC5fZHJhaW5RdWV1ZXMoKX0sdGhpcy5fc2NoZWR1bGU9bH1mdW5jdGlvbiBpKHQsZSxuKXt0aGlzLl9sYXRlUXVldWUucHVzaCh0LGUsbiksdGhpcy5fcXVldWVUaWNrKCl9ZnVuY3Rpb24gbyh0LGUsbil7dGhpcy5fbm9ybWFsUXVldWUucHVzaCh0LGUsbiksdGhpcy5fcXVldWVUaWNrKCl9ZnVuY3Rpb24gcyh0KXt0aGlzLl9ub3JtYWxRdWV1ZS5fcHVzaE9uZSh0KSx0aGlzLl9xdWV1ZVRpY2soKX12YXIgYTt0cnl7dGhyb3cgbmV3IEVycm9yfWNhdGNoKGMpe2E9Y312YXIgbD10KFwiLi9zY2hlZHVsZVwiKSx1PXQoXCIuL3F1ZXVlXCIpLHA9dChcIi4vdXRpbFwiKTtyLnByb3RvdHlwZS5zZXRTY2hlZHVsZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fc2NoZWR1bGU7cmV0dXJuIHRoaXMuX3NjaGVkdWxlPXQsdGhpcy5fY3VzdG9tU2NoZWR1bGVyPSEwLGV9LHIucHJvdG90eXBlLmhhc0N1c3RvbVNjaGVkdWxlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jdXN0b21TY2hlZHVsZXJ9LHIucHJvdG90eXBlLmVuYWJsZVRyYW1wb2xpbmU9ZnVuY3Rpb24oKXt0aGlzLl90cmFtcG9saW5lRW5hYmxlZD0hMH0sci5wcm90b3R5cGUuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeT1mdW5jdGlvbigpe3AuaGFzRGV2VG9vbHMmJih0aGlzLl90cmFtcG9saW5lRW5hYmxlZD0hMSl9LHIucHJvdG90eXBlLmhhdmVJdGVtc1F1ZXVlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1RpY2tVc2VkfHx0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlc30sci5wcm90b3R5cGUuZmF0YWxFcnJvcj1mdW5jdGlvbih0LGUpe2U/KHByb2Nlc3Muc3RkZXJyLndyaXRlKFwiRmF0YWwgXCIrKHQgaW5zdGFuY2VvZiBFcnJvcj90LnN0YWNrOnQpK1wiXFxuXCIpLHByb2Nlc3MuZXhpdCgyKSk6dGhpcy50aHJvd0xhdGVyKHQpfSxyLnByb3RvdHlwZS50aHJvd0xhdGVyPWZ1bmN0aW9uKHQsZSl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJihlPXQsdD1mdW5jdGlvbigpe3Rocm93IGV9KSxcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2V0VGltZW91dClzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dChlKX0sMCk7ZWxzZSB0cnl7dGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKXt0KGUpfSl9Y2F0Y2gobil7dGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIil9fSxwLmhhc0RldlRvb2xzPyhyLnByb3RvdHlwZS5pbnZva2VMYXRlcj1mdW5jdGlvbih0LGUsbil7dGhpcy5fdHJhbXBvbGluZUVuYWJsZWQ/aS5jYWxsKHRoaXMsdCxlLG4pOnRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3QuY2FsbChlLG4pfSwxMDApfSl9LHIucHJvdG90eXBlLmludm9rZT1mdW5jdGlvbih0LGUsbil7dGhpcy5fdHJhbXBvbGluZUVuYWJsZWQ/by5jYWxsKHRoaXMsdCxlLG4pOnRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCl7dC5jYWxsKGUsbil9KX0sci5wcm90b3R5cGUuc2V0dGxlUHJvbWlzZXM9ZnVuY3Rpb24odCl7dGhpcy5fdHJhbXBvbGluZUVuYWJsZWQ/cy5jYWxsKHRoaXMsdCk6dGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKXt0Ll9zZXR0bGVQcm9taXNlcygpfSl9KTooci5wcm90b3R5cGUuaW52b2tlTGF0ZXI9aSxyLnByb3RvdHlwZS5pbnZva2U9byxyLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcz1zKSxyLnByb3RvdHlwZS5fZHJhaW5RdWV1ZT1mdW5jdGlvbih0KXtmb3IoO3QubGVuZ3RoKCk+MDspe3ZhciBlPXQuc2hpZnQoKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlKXt2YXIgbj10LnNoaWZ0KCkscj10LnNoaWZ0KCk7ZS5jYWxsKG4scil9ZWxzZSBlLl9zZXR0bGVQcm9taXNlcygpfX0sci5wcm90b3R5cGUuX2RyYWluUXVldWVzPWZ1bmN0aW9uKCl7dGhpcy5fZHJhaW5RdWV1ZSh0aGlzLl9ub3JtYWxRdWV1ZSksdGhpcy5fcmVzZXQoKSx0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcz0hMCx0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX2xhdGVRdWV1ZSl9LHIucHJvdG90eXBlLl9xdWV1ZVRpY2s9ZnVuY3Rpb24oKXt0aGlzLl9pc1RpY2tVc2VkfHwodGhpcy5faXNUaWNrVXNlZD0hMCx0aGlzLl9zY2hlZHVsZSh0aGlzLmRyYWluUXVldWVzKSl9LHIucHJvdG90eXBlLl9yZXNldD1mdW5jdGlvbigpe3RoaXMuX2lzVGlja1VzZWQ9ITF9LGUuZXhwb3J0cz1yLGUuZXhwb3J0cy5maXJzdExpbmVFcnJvcj1hfSx7XCIuL3F1ZXVlXCI6MjYsXCIuL3NjaGVkdWxlXCI6MjksXCIuL3V0aWxcIjozNn1dLDM6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9ITEsbz1mdW5jdGlvbih0LGUpe3RoaXMuX3JlamVjdChlKX0scz1mdW5jdGlvbih0LGUpe2UucHJvbWlzZVJlamVjdGlvblF1ZXVlZD0hMCxlLmJpbmRpbmdQcm9taXNlLl90aGVuKG8sbyxudWxsLHRoaXMsdCl9LGE9ZnVuY3Rpb24odCxlKXswPT09KDUwMzk3MTg0JnRoaXMuX2JpdEZpZWxkKSYmdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKGUudGFyZ2V0KX0sYz1mdW5jdGlvbih0LGUpe2UucHJvbWlzZVJlamVjdGlvblF1ZXVlZHx8dGhpcy5fcmVqZWN0KHQpfTt0LnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKG8pe2l8fChpPSEwLHQucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tPXIucHJvcGFnYXRlRnJvbUZ1bmN0aW9uKCksdC5wcm90b3R5cGUuX2JvdW5kVmFsdWU9ci5ib3VuZFZhbHVlRnVuY3Rpb24oKSk7dmFyIGw9bihvKSx1PW5ldyB0KGUpO3UuX3Byb3BhZ2F0ZUZyb20odGhpcywxKTt2YXIgcD10aGlzLl90YXJnZXQoKTtpZih1Ll9zZXRCb3VuZFRvKGwpLGwgaW5zdGFuY2VvZiB0KXt2YXIgaD17cHJvbWlzZVJlamVjdGlvblF1ZXVlZDohMSxwcm9taXNlOnUsdGFyZ2V0OnAsYmluZGluZ1Byb21pc2U6bH07cC5fdGhlbihlLHMsdm9pZCAwLHUsaCksbC5fdGhlbihhLGMsdm9pZCAwLHUsaCksdS5fc2V0T25DYW5jZWwobCl9ZWxzZSB1Ll9yZXNvbHZlQ2FsbGJhY2socCk7cmV0dXJuIHV9LHQucHJvdG90eXBlLl9zZXRCb3VuZFRvPWZ1bmN0aW9uKHQpe3ZvaWQgMCE9PXQ/KHRoaXMuX2JpdEZpZWxkPTIwOTcxNTJ8dGhpcy5fYml0RmllbGQsdGhpcy5fYm91bmRUbz10KTp0aGlzLl9iaXRGaWVsZD0tMjA5NzE1MyZ0aGlzLl9iaXRGaWVsZH0sdC5wcm90b3R5cGUuX2lzQm91bmQ9ZnVuY3Rpb24oKXtyZXR1cm4gMjA5NzE1Mj09PSgyMDk3MTUyJnRoaXMuX2JpdEZpZWxkKX0sdC5iaW5kPWZ1bmN0aW9uKGUsbil7cmV0dXJuIHQucmVzb2x2ZShuKS5iaW5kKGUpfX19LHt9XSw0OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcigpe3RyeXtQcm9taXNlPT09byYmKFByb21pc2U9aSl9Y2F0Y2godCl7fXJldHVybiBvfXZhciBpO1widW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlJiYoaT1Qcm9taXNlKTt2YXIgbz10KFwiLi9wcm9taXNlXCIpKCk7by5ub0NvbmZsaWN0PXIsZS5leHBvcnRzPW99LHtcIi4vcHJvbWlzZVwiOjIyfV0sNTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPU9iamVjdC5jcmVhdGU7aWYocil7dmFyIGk9cihudWxsKSxvPXIobnVsbCk7aVtcIiBzaXplXCJdPW9bXCIgc2l6ZVwiXT0wfWUuZXhwb3J0cz1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsbil7dmFyIHI7aWYobnVsbCE9dCYmKHI9dFtuXSksXCJmdW5jdGlvblwiIT10eXBlb2Ygcil7dmFyIGk9XCJPYmplY3QgXCIrYS5jbGFzc1N0cmluZyh0KStcIiBoYXMgbm8gbWV0aG9kICdcIithLnRvU3RyaW5nKG4pK1wiJ1wiO3Rocm93IG5ldyBlLlR5cGVFcnJvcihpKX1yZXR1cm4gcn1mdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMucG9wKCkscj1uKHQsZSk7cmV0dXJuIHIuYXBwbHkodCx0aGlzKX1mdW5jdGlvbiBpKHQpe3JldHVybiB0W3RoaXNdfWZ1bmN0aW9uIG8odCl7dmFyIGU9K3RoaXM7cmV0dXJuIDA+ZSYmKGU9TWF0aC5tYXgoMCxlK3QubGVuZ3RoKSksdFtlXX12YXIgcyxhPXQoXCIuL3V0aWxcIiksYz1hLmNhbkV2YWx1YXRlO2EuaXNJZGVudGlmaWVyO2UucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24odCl7dmFyIGU9W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIGUucHVzaCh0KSx0aGlzLl90aGVuKHIsdm9pZCAwLHZvaWQgMCxlLHZvaWQgMCl9LGUucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXt2YXIgZSxuPVwibnVtYmVyXCI9PXR5cGVvZiB0O2lmKG4pZT1vO2Vsc2UgaWYoYyl7dmFyIHI9cyh0KTtlPW51bGwhPT1yP3I6aX1lbHNlIGU9aTtyZXR1cm4gdGhpcy5fdGhlbihlLHZvaWQgMCx2b2lkIDAsdCx2b2lkIDApfX19LHtcIi4vdXRpbFwiOjM2fV0sNjpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scixpKXt2YXIgbz10KFwiLi91dGlsXCIpLHM9by50cnlDYXRjaCxhPW8uZXJyb3JPYmosYz1lLl9hc3luYztlLnByb3RvdHlwZVtcImJyZWFrXCJdPWUucHJvdG90eXBlLmNhbmNlbD1mdW5jdGlvbigpe2lmKCFpLmNhbmNlbGxhdGlvbigpKXJldHVybiB0aGlzLl93YXJuKFwiY2FuY2VsbGF0aW9uIGlzIGRpc2FibGVkXCIpO2Zvcih2YXIgdD10aGlzLGU9dDt0Ll9pc0NhbmNlbGxhYmxlKCk7KXtpZighdC5fY2FuY2VsQnkoZSkpe2UuX2lzRm9sbG93aW5nKCk/ZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTplLl9jYW5jZWxCcmFuY2hlZCgpO2JyZWFrfXZhciBuPXQuX2NhbmNlbGxhdGlvblBhcmVudDtpZihudWxsPT1ufHwhbi5faXNDYW5jZWxsYWJsZSgpKXt0Ll9pc0ZvbGxvd2luZygpP3QuX2ZvbGxvd2VlKCkuY2FuY2VsKCk6dC5fY2FuY2VsQnJhbmNoZWQoKTticmVha310Ll9pc0ZvbGxvd2luZygpJiZ0Ll9mb2xsb3dlZSgpLmNhbmNlbCgpLHQuX3NldFdpbGxCZUNhbmNlbGxlZCgpLGU9dCx0PW59fSxlLnByb3RvdHlwZS5fYnJhbmNoSGFzQ2FuY2VsbGVkPWZ1bmN0aW9uKCl7dGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbC0tfSxlLnByb3RvdHlwZS5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWx8fHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWw8PTB9LGUucHJvdG90eXBlLl9jYW5jZWxCeT1mdW5jdGlvbih0KXtyZXR1cm4gdD09PXRoaXM/KHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWw9MCx0aGlzLl9pbnZva2VPbkNhbmNlbCgpLCEwKToodGhpcy5fYnJhbmNoSGFzQ2FuY2VsbGVkKCksdGhpcy5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkKCk/KHRoaXMuX2ludm9rZU9uQ2FuY2VsKCksITApOiExKX0sZS5wcm90b3R5cGUuX2NhbmNlbEJyYW5jaGVkPWZ1bmN0aW9uKCl7dGhpcy5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkKCkmJnRoaXMuX2NhbmNlbCgpfSxlLnByb3RvdHlwZS5fY2FuY2VsPWZ1bmN0aW9uKCl7dGhpcy5faXNDYW5jZWxsYWJsZSgpJiYodGhpcy5fc2V0Q2FuY2VsbGVkKCksYy5pbnZva2UodGhpcy5fY2FuY2VsUHJvbWlzZXMsdGhpcyx2b2lkIDApKX0sZS5wcm90b3R5cGUuX2NhbmNlbFByb21pc2VzPWZ1bmN0aW9uKCl7dGhpcy5fbGVuZ3RoKCk+MCYmdGhpcy5fc2V0dGxlUHJvbWlzZXMoKX0sZS5wcm90b3R5cGUuX3Vuc2V0T25DYW5jZWw9ZnVuY3Rpb24oKXt0aGlzLl9vbkNhbmNlbEZpZWxkPXZvaWQgMH0sZS5wcm90b3R5cGUuX2lzQ2FuY2VsbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSYmIXRoaXMuX2lzQ2FuY2VsbGVkKCl9LGUucHJvdG90eXBlLmlzQ2FuY2VsbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSYmIXRoaXMuaXNDYW5jZWxsZWQoKX0sZS5wcm90b3R5cGUuX2RvSW52b2tlT25DYW5jZWw9ZnVuY3Rpb24odCxlKXtpZihvLmlzQXJyYXkodCkpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pdGhpcy5fZG9JbnZva2VPbkNhbmNlbCh0W25dLGUpO2Vsc2UgaWYodm9pZCAwIT09dClpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KXtpZighZSl7dmFyIHI9cyh0KS5jYWxsKHRoaXMuX2JvdW5kVmFsdWUoKSk7cj09PWEmJih0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKHIuZSksYy50aHJvd0xhdGVyKHIuZSkpfX1lbHNlIHQuX3Jlc3VsdENhbmNlbGxlZCh0aGlzKX0sZS5wcm90b3R5cGUuX2ludm9rZU9uQ2FuY2VsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fb25DYW5jZWwoKTt0aGlzLl91bnNldE9uQ2FuY2VsKCksYy5pbnZva2UodGhpcy5fZG9JbnZva2VPbkNhbmNlbCx0aGlzLHQpfSxlLnByb3RvdHlwZS5faW52b2tlSW50ZXJuYWxPbkNhbmNlbD1mdW5jdGlvbigpe3RoaXMuX2lzQ2FuY2VsbGFibGUoKSYmKHRoaXMuX2RvSW52b2tlT25DYW5jZWwodGhpcy5fb25DYW5jZWwoKSwhMCksdGhpcy5fdW5zZXRPbkNhbmNlbCgpKX0sZS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZD1mdW5jdGlvbigpe3RoaXMuY2FuY2VsKCl9fX0se1wiLi91dGlsXCI6MzZ9XSw3OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCxuLGEpe3JldHVybiBmdW5jdGlvbihjKXt2YXIgbD1hLl9ib3VuZFZhbHVlKCk7dDpmb3IodmFyIHU9MDt1PHQubGVuZ3RoOysrdSl7dmFyIHA9dFt1XTtpZihwPT09RXJyb3J8fG51bGwhPXAmJnAucHJvdG90eXBlIGluc3RhbmNlb2YgRXJyb3Ipe2lmKGMgaW5zdGFuY2VvZiBwKXJldHVybiBvKG4pLmNhbGwobCxjKX1lbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHApe3ZhciBoPW8ocCkuY2FsbChsLGMpO2lmKGg9PT1zKXJldHVybiBoO2lmKGgpcmV0dXJuIG8obikuY2FsbChsLGMpfWVsc2UgaWYoci5pc09iamVjdChjKSl7Zm9yKHZhciBmPWkocCksXz0wO188Zi5sZW5ndGg7KytfKXt2YXIgZD1mW19dO2lmKHBbZF0hPWNbZF0pY29udGludWUgdH1yZXR1cm4gbyhuKS5jYWxsKGwsYyl9fXJldHVybiBlfX12YXIgcj10KFwiLi91dGlsXCIpLGk9dChcIi4vZXM1XCIpLmtleXMsbz1yLnRyeUNhdGNoLHM9ci5lcnJvck9iajtyZXR1cm4gbn19LHtcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDg6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3RoaXMuX3RyYWNlPW5ldyBlLkNhcHR1cmVkVHJhY2UocigpKX1mdW5jdGlvbiBuKCl7cmV0dXJuIGk/bmV3IGU6dm9pZCAwfWZ1bmN0aW9uIHIoKXt2YXIgdD1vLmxlbmd0aC0xO3JldHVybiB0Pj0wP29bdF06dm9pZCAwfXZhciBpPSExLG89W107cmV0dXJuIHQucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZD1mdW5jdGlvbigpe30sdC5wcm90b3R5cGUuX3B1c2hDb250ZXh0PWZ1bmN0aW9uKCl7fSx0LnByb3RvdHlwZS5fcG9wQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBudWxsfSx0Ll9wZWVrQ29udGV4dD10LnByb3RvdHlwZS5fcGVla0NvbnRleHQ9ZnVuY3Rpb24oKXt9LGUucHJvdG90eXBlLl9wdXNoQ29udGV4dD1mdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMuX3RyYWNlJiYodGhpcy5fdHJhY2UuX3Byb21pc2VDcmVhdGVkPW51bGwsby5wdXNoKHRoaXMuX3RyYWNlKSl9LGUucHJvdG90eXBlLl9wb3BDb250ZXh0PWZ1bmN0aW9uKCl7aWYodm9pZCAwIT09dGhpcy5fdHJhY2Upe3ZhciB0PW8ucG9wKCksZT10Ll9wcm9taXNlQ3JlYXRlZDtyZXR1cm4gdC5fcHJvbWlzZUNyZWF0ZWQ9bnVsbCxlfXJldHVybiBudWxsfSxlLkNhcHR1cmVkVHJhY2U9bnVsbCxlLmNyZWF0ZT1uLGUuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcz1mdW5jdGlvbigpe30sZS5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcz1mdW5jdGlvbigpe3ZhciBuPXQucHJvdG90eXBlLl9wdXNoQ29udGV4dCxvPXQucHJvdG90eXBlLl9wb3BDb250ZXh0LHM9dC5fcGVla0NvbnRleHQsYT10LnByb3RvdHlwZS5fcGVla0NvbnRleHQsYz10LnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQ7ZS5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzPWZ1bmN0aW9uKCl7dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0PW4sdC5wcm90b3R5cGUuX3BvcENvbnRleHQ9byx0Ll9wZWVrQ29udGV4dD1zLHQucHJvdG90eXBlLl9wZWVrQ29udGV4dD1hLHQucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZD1jLGk9ITF9LGk9ITAsdC5wcm90b3R5cGUuX3B1c2hDb250ZXh0PWUucHJvdG90eXBlLl9wdXNoQ29udGV4dCx0LnByb3RvdHlwZS5fcG9wQ29udGV4dD1lLnByb3RvdHlwZS5fcG9wQ29udGV4dCx0Ll9wZWVrQ29udGV4dD10LnByb3RvdHlwZS5fcGVla0NvbnRleHQ9cix0LnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9wZWVrQ29udGV4dCgpO3QmJm51bGw9PXQuX3Byb21pc2VDcmVhdGVkJiYodC5fcHJvbWlzZUNyZWF0ZWQ9dGhpcyl9fSxlfX0se31dLDk6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiByKHQsZSl7cmV0dXJue3Byb21pc2U6ZX19ZnVuY3Rpb24gaSgpe3JldHVybiExfWZ1bmN0aW9uIG8odCxlLG4pe3ZhciByPXRoaXM7dHJ5e3QoZSxuLGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9uQ2FuY2VsIG11c3QgYmUgYSBmdW5jdGlvbiwgZ290OiBcIitILnRvU3RyaW5nKHQpKTtyLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayh0KX0pfWNhdGNoKGkpe3JldHVybiBpfX1mdW5jdGlvbiBzKHQpe2lmKCF0aGlzLl9pc0NhbmNlbGxhYmxlKCkpcmV0dXJuIHRoaXM7dmFyIGU9dGhpcy5fb25DYW5jZWwoKTt2b2lkIDAhPT1lP0guaXNBcnJheShlKT9lLnB1c2godCk6dGhpcy5fc2V0T25DYW5jZWwoW2UsdF0pOnRoaXMuX3NldE9uQ2FuY2VsKHQpfWZ1bmN0aW9uIGEoKXtyZXR1cm4gdGhpcy5fb25DYW5jZWxGaWVsZH1mdW5jdGlvbiBjKHQpe3RoaXMuX29uQ2FuY2VsRmllbGQ9dH1mdW5jdGlvbiBsKCl7dGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50PXZvaWQgMCx0aGlzLl9vbkNhbmNlbEZpZWxkPXZvaWQgMH1mdW5jdGlvbiB1KHQsZSl7aWYoMCE9PSgxJmUpKXt0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQ9dDt2YXIgbj10Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsO3ZvaWQgMD09PW4mJihuPTApLHQuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWw9bisxfTAhPT0oMiZlKSYmdC5faXNCb3VuZCgpJiZ0aGlzLl9zZXRCb3VuZFRvKHQuX2JvdW5kVG8pfWZ1bmN0aW9uIHAodCxlKXswIT09KDImZSkmJnQuX2lzQm91bmQoKSYmdGhpcy5fc2V0Qm91bmRUbyh0Ll9ib3VuZFRvKX1mdW5jdGlvbiBoKCl7dmFyIHQ9dGhpcy5fYm91bmRUbztyZXR1cm4gdm9pZCAwIT09dCYmdCBpbnN0YW5jZW9mIGU/dC5pc0Z1bGZpbGxlZCgpP3QudmFsdWUoKTp2b2lkIDA6dH1mdW5jdGlvbiBmKCl7dGhpcy5fdHJhY2U9bmV3IFModGhpcy5fcGVla0NvbnRleHQoKSl9ZnVuY3Rpb24gXyh0LGUpe2lmKE4odCkpe3ZhciBuPXRoaXMuX3RyYWNlO2lmKHZvaWQgMCE9PW4mJmUmJihuPW4uX3BhcmVudCksdm9pZCAwIT09biluLmF0dGFjaEV4dHJhVHJhY2UodCk7ZWxzZSBpZighdC5fX3N0YWNrQ2xlYW5lZF9fKXt2YXIgcj1qKHQpO0gubm90RW51bWVyYWJsZVByb3AodCxcInN0YWNrXCIsci5tZXNzYWdlK1wiXFxuXCIrci5zdGFjay5qb2luKFwiXFxuXCIpKSxILm5vdEVudW1lcmFibGVQcm9wKHQsXCJfX3N0YWNrQ2xlYW5lZF9fXCIsITApfX19ZnVuY3Rpb24gZCh0LGUsbixyLGkpe2lmKHZvaWQgMD09PXQmJm51bGwhPT1lJiZXKXtpZih2b2lkIDAhPT1pJiZpLl9yZXR1cm5lZE5vblVuZGVmaW5lZCgpKXJldHVybjtpZigwPT09KDY1NTM1JnIuX2JpdEZpZWxkKSlyZXR1cm47biYmKG4rPVwiIFwiKTt2YXIgbz1cIlwiLHM9XCJcIjtpZihlLl90cmFjZSl7Zm9yKHZhciBhPWUuX3RyYWNlLnN0YWNrLnNwbGl0KFwiXFxuXCIpLGM9dyhhKSxsPWMubGVuZ3RoLTE7bD49MDstLWwpe3ZhciB1PWNbbF07aWYoIVUudGVzdCh1KSl7dmFyIHA9dS5tYXRjaChNKTtwJiYobz1cImF0IFwiK3BbMV0rXCI6XCIrcFsyXStcIjpcIitwWzNdK1wiIFwiKTticmVha319aWYoYy5sZW5ndGg+MClmb3IodmFyIGg9Y1swXSxsPTA7bDxhLmxlbmd0aDsrK2wpaWYoYVtsXT09PWgpe2w+MCYmKHM9XCJcXG5cIithW2wtMV0pO2JyZWFrfX12YXIgZj1cImEgcHJvbWlzZSB3YXMgY3JlYXRlZCBpbiBhIFwiK24rXCJoYW5kbGVyIFwiK28rXCJidXQgd2FzIG5vdCByZXR1cm5lZCBmcm9tIGl0LCBzZWUgaHR0cDovL2dvby5nbC9yUnFNVXdcIitzO3IuX3dhcm4oZiwhMCxlKX19ZnVuY3Rpb24gdih0LGUpe3ZhciBuPXQrXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCI7cmV0dXJuIGUmJihuKz1cIiBVc2UgXCIrZStcIiBpbnN0ZWFkLlwiKSx5KG4pfWZ1bmN0aW9uIHkodCxuLHIpe2lmKG90Lndhcm5pbmdzKXt2YXIgaSxvPW5ldyBMKHQpO2lmKG4pci5fYXR0YWNoRXh0cmFUcmFjZShvKTtlbHNlIGlmKG90LmxvbmdTdGFja1RyYWNlcyYmKGk9ZS5fcGVla0NvbnRleHQoKSkpaS5hdHRhY2hFeHRyYVRyYWNlKG8pO2Vsc2V7dmFyIHM9aihvKTtvLnN0YWNrPXMubWVzc2FnZStcIlxcblwiK3Muc3RhY2suam9pbihcIlxcblwiKX10dChcIndhcm5pbmdcIixvKXx8RShvLFwiXCIsITApfX1mdW5jdGlvbiBtKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aC0xOysrbillW25dLnB1c2goXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiKSxlW25dPWVbbl0uam9pbihcIlxcblwiKTtyZXR1cm4gbjxlLmxlbmd0aCYmKGVbbl09ZVtuXS5qb2luKFwiXFxuXCIpKSx0K1wiXFxuXCIrZS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIGcodCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDsrK2UpKDA9PT10W2VdLmxlbmd0aHx8ZSsxPHQubGVuZ3RoJiZ0W2VdWzBdPT09dFtlKzFdWzBdKSYmKHQuc3BsaWNlKGUsMSksZS0tKX1mdW5jdGlvbiBiKHQpe2Zvcih2YXIgZT10WzBdLG49MTtuPHQubGVuZ3RoOysrbil7Zm9yKHZhciByPXRbbl0saT1lLmxlbmd0aC0xLG89ZVtpXSxzPS0xLGE9ci5sZW5ndGgtMTthPj0wOy0tYSlpZihyW2FdPT09byl7cz1hO2JyZWFrfWZvcih2YXIgYT1zO2E+PTA7LS1hKXt2YXIgYz1yW2FdO2lmKGVbaV0hPT1jKWJyZWFrO2UucG9wKCksaS0tfWU9cn19ZnVuY3Rpb24gdyh0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKXt2YXIgcj10W25dLGk9XCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiPT09cnx8cS50ZXN0KHIpLG89aSYmbnQocik7aSYmIW8mJigkJiZcIiBcIiE9PXIuY2hhckF0KDApJiYocj1cIiAgICBcIityKSxlLnB1c2gocikpfXJldHVybiBlfWZ1bmN0aW9uIEModCl7Zm9yKHZhciBlPXQuc3RhY2sucmVwbGFjZSgvXFxzKyQvZyxcIlwiKS5zcGxpdChcIlxcblwiKSxuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciByPWVbbl07aWYoXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiPT09cnx8cS50ZXN0KHIpKWJyZWFrfXJldHVybiBuPjAmJlwiU3ludGF4RXJyb3JcIiE9dC5uYW1lJiYoZT1lLnNsaWNlKG4pKSxlfWZ1bmN0aW9uIGoodCl7dmFyIGU9dC5zdGFjayxuPXQudG9TdHJpbmcoKTtyZXR1cm4gZT1cInN0cmluZ1wiPT10eXBlb2YgZSYmZS5sZW5ndGg+MD9DKHQpOltcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCJdLHttZXNzYWdlOm4sc3RhY2s6XCJTeW50YXhFcnJvclwiPT10Lm5hbWU/ZTp3KGUpfX1mdW5jdGlvbiBFKHQsZSxuKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgY29uc29sZSl7dmFyIHI7aWYoSC5pc09iamVjdCh0KSl7dmFyIGk9dC5zdGFjaztyPWUrUShpLHQpfWVsc2Ugcj1lK1N0cmluZyh0KTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBEP0QocixuKTooXCJmdW5jdGlvblwiPT10eXBlb2YgY29uc29sZS5sb2d8fFwib2JqZWN0XCI9PXR5cGVvZiBjb25zb2xlLmxvZykmJmNvbnNvbGUubG9nKHIpfX1mdW5jdGlvbiBrKHQsZSxuLHIpe3ZhciBpPSExO3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYoaT0hMCxcInJlamVjdGlvbkhhbmRsZWRcIj09PXQ/ZShyKTplKG4scikpfWNhdGNoKG8pe0kudGhyb3dMYXRlcihvKX1cInVuaGFuZGxlZFJlamVjdGlvblwiPT09dD90dCh0LG4scil8fGl8fEUobixcIlVuaGFuZGxlZCByZWplY3Rpb24gXCIpOnR0KHQscil9ZnVuY3Rpb24gRih0KXt2YXIgZTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KWU9XCJbZnVuY3Rpb24gXCIrKHQubmFtZXx8XCJhbm9ueW1vdXNcIikrXCJdXCI7ZWxzZXtlPXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudG9TdHJpbmc/dC50b1N0cmluZygpOkgudG9TdHJpbmcodCk7dmFyIG49L1xcW29iamVjdCBbYS16QS1aMC05JF9dK1xcXS87aWYobi50ZXN0KGUpKXRyeXt2YXIgcj1KU09OLnN0cmluZ2lmeSh0KTtlPXJ9Y2F0Y2goaSl7fTA9PT1lLmxlbmd0aCYmKGU9XCIoZW1wdHkgYXJyYXkpXCIpfXJldHVyblwiKDxcIit4KGUpK1wiPiwgbm8gc3RhY2sgdHJhY2UpXCJ9ZnVuY3Rpb24geCh0KXt2YXIgZT00MTtyZXR1cm4gdC5sZW5ndGg8ZT90OnQuc3Vic3RyKDAsZS0zKStcIi4uLlwifWZ1bmN0aW9uIFQoKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBpdH1mdW5jdGlvbiBQKHQpe3ZhciBlPXQubWF0Y2gocnQpO3JldHVybiBlP3tmaWxlTmFtZTplWzFdLGxpbmU6cGFyc2VJbnQoZVsyXSwxMCl9OnZvaWQgMH1mdW5jdGlvbiBSKHQsZSl7aWYoVCgpKXtmb3IodmFyIG4scixpPXQuc3RhY2suc3BsaXQoXCJcXG5cIiksbz1lLnN0YWNrLnNwbGl0KFwiXFxuXCIpLHM9LTEsYT0tMSxjPTA7YzxpLmxlbmd0aDsrK2Mpe3ZhciBsPVAoaVtjXSk7aWYobCl7bj1sLmZpbGVOYW1lLHM9bC5saW5lO2JyZWFrfX1mb3IodmFyIGM9MDtjPG8ubGVuZ3RoOysrYyl7dmFyIGw9UChvW2NdKTtpZihsKXtyPWwuZmlsZU5hbWUsYT1sLmxpbmU7YnJlYWt9fTA+c3x8MD5hfHwhbnx8IXJ8fG4hPT1yfHxzPj1hfHwobnQ9ZnVuY3Rpb24odCl7aWYoQi50ZXN0KHQpKXJldHVybiEwO3ZhciBlPVAodCk7cmV0dXJuIGUmJmUuZmlsZU5hbWU9PT1uJiZzPD1lLmxpbmUmJmUubGluZTw9YT8hMDohMX0pfX1mdW5jdGlvbiBTKHQpe3RoaXMuX3BhcmVudD10LHRoaXMuX3Byb21pc2VzQ3JlYXRlZD0wO3ZhciBlPXRoaXMuX2xlbmd0aD0xKyh2b2lkIDA9PT10PzA6dC5fbGVuZ3RoKTtpdCh0aGlzLFMpLGU+MzImJnRoaXMudW5jeWNsZSgpfXZhciBPLEEsRCxWPWUuX2dldERvbWFpbixJPWUuX2FzeW5jLEw9dChcIi4vZXJyb3JzXCIpLldhcm5pbmcsSD10KFwiLi91dGlsXCIpLE49SC5jYW5BdHRhY2hUcmFjZSxCPS9bXFxcXFxcL11ibHVlYmlyZFtcXFxcXFwvXWpzW1xcXFxcXC9dKHJlbGVhc2V8ZGVidWd8aW5zdHJ1bWVudGVkKS8sVT0vXFwoKD86dGltZXJzXFwuanMpOlxcZCs6XFxkK1xcKS8sTT0vW1xcLzxcXChdKC4rPyk6KFxcZCspOihcXGQrKVxcKT9cXHMqJC8scT1udWxsLFE9bnVsbCwkPSExLEc9ISgwPT1ILmVudihcIkJMVUVCSVJEX0RFQlVHXCIpfHwhSC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSYmXCJkZXZlbG9wbWVudFwiIT09SC5lbnYoXCJOT0RFX0VOVlwiKSksej0hKDA9PUguZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIil8fCFHJiYhSC5lbnYoXCJCTFVFQklSRF9XQVJOSU5HU1wiKSksWD0hKDA9PUguZW52KFwiQkxVRUJJUkRfTE9OR19TVEFDS19UUkFDRVNcIil8fCFHJiYhSC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSksVz0wIT1ILmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSYmKHp8fCEhSC5lbnYoXCJCTFVFQklSRF9XX0ZPUkdPVFRFTl9SRVRVUk5cIikpO2UucHJvdG90eXBlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX3RhcmdldCgpO3QuX2JpdEZpZWxkPS0xMDQ4NTc3JnQuX2JpdEZpZWxkfDUyNDI4OH0sZS5wcm90b3R5cGUuX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZD1mdW5jdGlvbigpezA9PT0oNTI0Mjg4JnRoaXMuX2JpdEZpZWxkKSYmKHRoaXMuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkKCksSS5pbnZva2VMYXRlcih0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24sdGhpcyx2b2lkIDApKX0sZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZD1mdW5jdGlvbigpe2soXCJyZWplY3Rpb25IYW5kbGVkXCIsTyx2b2lkIDAsdGhpcyl9LGUucHJvdG90eXBlLl9zZXRSZXR1cm5lZE5vblVuZGVmaW5lZD1mdW5jdGlvbigpe3RoaXMuX2JpdEZpZWxkPTI2ODQzNTQ1Nnx0aGlzLl9iaXRGaWVsZH0sZS5wcm90b3R5cGUuX3JldHVybmVkTm9uVW5kZWZpbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT0oMjY4NDM1NDU2JnRoaXMuX2JpdEZpZWxkKX0sZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMuX2lzUmVqZWN0aW9uVW5oYW5kbGVkKCkpe3ZhciB0PXRoaXMuX3NldHRsZWRWYWx1ZSgpO3RoaXMuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKSxrKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsQSx0LHRoaXMpfX0sZS5wcm90b3R5cGUuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQ9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD0yNjIxNDR8dGhpcy5fYml0RmllbGR9LGUucHJvdG90eXBlLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQ9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD0tMjYyMTQ1JnRoaXMuX2JpdEZpZWxkfSxlLnByb3RvdHlwZS5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZD1mdW5jdGlvbigpe3JldHVybigyNjIxNDQmdGhpcy5fYml0RmllbGQpPjB9LGUucHJvdG90eXBlLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZD1mdW5jdGlvbigpe3RoaXMuX2JpdEZpZWxkPTEwNDg1NzZ8dGhpcy5fYml0RmllbGR9LGUucHJvdG90eXBlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9LTEwNDg1NzcmdGhpcy5fYml0RmllbGQsdGhpcy5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCgpJiYodGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCksdGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkKCkpfSxlLnByb3RvdHlwZS5faXNSZWplY3Rpb25VbmhhbmRsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4oMTA0ODU3NiZ0aGlzLl9iaXRGaWVsZCk+MH0sZS5wcm90b3R5cGUuX3dhcm49ZnVuY3Rpb24odCxlLG4pe3JldHVybiB5KHQsZSxufHx0aGlzKX0sZS5vblBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPVYoKTtBPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/bnVsbD09PWU/dDpILmRvbWFpbkJpbmQoZSx0KTp2b2lkIDB9LGUub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkPWZ1bmN0aW9uKHQpe3ZhciBlPVYoKTtPPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/bnVsbD09PWU/dDpILmRvbWFpbkJpbmQoZSx0KTp2b2lkIDB9O3ZhciBLPWZ1bmN0aW9uKCl7fTtlLmxvbmdTdGFja1RyYWNlcz1mdW5jdGlvbigpe2lmKEkuaGF2ZUl0ZW1zUXVldWVkKCkmJiFvdC5sb25nU3RhY2tUcmFjZXMpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7aWYoIW90LmxvbmdTdGFja1RyYWNlcyYmVCgpKXt2YXIgdD1lLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2Uscj1lLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZTtvdC5sb25nU3RhY2tUcmFjZXM9ITAsSz1mdW5jdGlvbigpe2lmKEkuaGF2ZUl0ZW1zUXVldWVkKCkmJiFvdC5sb25nU3RhY2tUcmFjZXMpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7ZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlPXQsZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2U9cixuLmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKSxJLmVuYWJsZVRyYW1wb2xpbmUoKSxvdC5sb25nU3RhY2tUcmFjZXM9ITF9LGUucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZT1mLGUucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlPV8sbi5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpLEkuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSgpfX0sZS5oYXNMb25nU3RhY2tUcmFjZXM9ZnVuY3Rpb24oKXtyZXR1cm4gb3QubG9uZ1N0YWNrVHJhY2VzJiZUKCl9O3ZhciBKPWZ1bmN0aW9uKCl7dHJ5e2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIEN1c3RvbUV2ZW50KXt2YXIgdD1uZXcgQ3VzdG9tRXZlbnQoXCJDdXN0b21FdmVudFwiKTtyZXR1cm4gSC5nbG9iYWwuZGlzcGF0Y2hFdmVudCh0KSxmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBDdXN0b21FdmVudCh0LnRvTG93ZXJDYXNlKCkse2RldGFpbDplLGNhbmNlbGFibGU6ITB9KTtyZXR1cm4hSC5nbG9iYWwuZGlzcGF0Y2hFdmVudChuKX19aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgRXZlbnQpe3ZhciB0PW5ldyBFdmVudChcIkN1c3RvbUV2ZW50XCIpO3JldHVybiBILmdsb2JhbC5kaXNwYXRjaEV2ZW50KHQpLGZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEV2ZW50KHQudG9Mb3dlckNhc2UoKSx7Y2FuY2VsYWJsZTohMH0pO3JldHVybiBuLmRldGFpbD1lLCFILmdsb2JhbC5kaXNwYXRjaEV2ZW50KG4pfX12YXIgdD1kb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO3JldHVybiB0LmluaXRDdXN0b21FdmVudChcInRlc3Rpbmd0aGVldmVudFwiLCExLCEwLHt9KSxILmdsb2JhbC5kaXNwYXRjaEV2ZW50KHQpLGZ1bmN0aW9uKHQsZSl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtyZXR1cm4gbi5pbml0Q3VzdG9tRXZlbnQodC50b0xvd2VyQ2FzZSgpLCExLCEwLGUpLCFILmdsb2JhbC5kaXNwYXRjaEV2ZW50KG4pfX1jYXRjaChlKXt9cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuITF9fSgpLFk9ZnVuY3Rpb24oKXtyZXR1cm4gSC5pc05vZGU/ZnVuY3Rpb24oKXtyZXR1cm4gcHJvY2Vzcy5lbWl0LmFwcGx5KHByb2Nlc3MsYXJndW1lbnRzKX06SC5nbG9iYWw/ZnVuY3Rpb24odCl7dmFyIGU9XCJvblwiK3QudG9Mb3dlckNhc2UoKSxuPUguZ2xvYmFsW2VdO3JldHVybiBuPyhuLmFwcGx5KEguZ2xvYmFsLFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKSwhMCk6ITF9OmZ1bmN0aW9uKCl7cmV0dXJuITF9fSgpLFo9e3Byb21pc2VDcmVhdGVkOnIscHJvbWlzZUZ1bGZpbGxlZDpyLHByb21pc2VSZWplY3RlZDpyLHByb21pc2VSZXNvbHZlZDpyLHByb21pc2VDYW5jZWxsZWQ6cixwcm9taXNlQ2hhaW5lZDpmdW5jdGlvbih0LGUsbil7cmV0dXJue3Byb21pc2U6ZSxjaGlsZDpufX0sd2FybmluZzpmdW5jdGlvbih0LGUpe3JldHVybnt3YXJuaW5nOmV9fSx1bmhhbmRsZWRSZWplY3Rpb246ZnVuY3Rpb24odCxlLG4pe3JldHVybntyZWFzb246ZSxwcm9taXNlOm59fSxyZWplY3Rpb25IYW5kbGVkOnJ9LHR0PWZ1bmN0aW9uKHQpe3ZhciBlPSExO3RyeXtlPVkuYXBwbHkobnVsbCxhcmd1bWVudHMpfWNhdGNoKG4pe0kudGhyb3dMYXRlcihuKSxlPSEwfXZhciByPSExO3RyeXtyPUoodCxaW3RdLmFwcGx5KG51bGwsYXJndW1lbnRzKSl9Y2F0Y2gobil7SS50aHJvd0xhdGVyKG4pLHI9ITB9cmV0dXJuIHJ8fGV9O2UuY29uZmlnPWZ1bmN0aW9uKHQpe2lmKHQ9T2JqZWN0KHQpLFwibG9uZ1N0YWNrVHJhY2VzXCJpbiB0JiYodC5sb25nU3RhY2tUcmFjZXM/ZS5sb25nU3RhY2tUcmFjZXMoKTohdC5sb25nU3RhY2tUcmFjZXMmJmUuaGFzTG9uZ1N0YWNrVHJhY2VzKCkmJksoKSksXCJ3YXJuaW5nc1wiaW4gdCl7dmFyIG49dC53YXJuaW5ncztvdC53YXJuaW5ncz0hIW4sVz1vdC53YXJuaW5ncyxILmlzT2JqZWN0KG4pJiZcIndGb3Jnb3R0ZW5SZXR1cm5cImluIG4mJihXPSEhbi53Rm9yZ290dGVuUmV0dXJuKX1pZihcImNhbmNlbGxhdGlvblwiaW4gdCYmdC5jYW5jZWxsYXRpb24mJiFvdC5jYW5jZWxsYXRpb24pe2lmKEkuaGF2ZUl0ZW1zUXVldWVkKCkpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBjYW5jZWxsYXRpb24gYWZ0ZXIgcHJvbWlzZXMgYXJlIGluIHVzZVwiKTtlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhPWwsZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb209dSxlLnByb3RvdHlwZS5fb25DYW5jZWw9YSxlLnByb3RvdHlwZS5fc2V0T25DYW5jZWw9YyxlLnByb3RvdHlwZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2s9cyxlLnByb3RvdHlwZS5fZXhlY3V0ZT1vLGV0PXUsb3QuY2FuY2VsbGF0aW9uPSEwfXJldHVyblwibW9uaXRvcmluZ1wiaW4gdCYmKHQubW9uaXRvcmluZyYmIW90Lm1vbml0b3Jpbmc/KG90Lm1vbml0b3Jpbmc9ITAsZS5wcm90b3R5cGUuX2ZpcmVFdmVudD10dCk6IXQubW9uaXRvcmluZyYmb3QubW9uaXRvcmluZyYmKG90Lm1vbml0b3Jpbmc9ITEsZS5wcm90b3R5cGUuX2ZpcmVFdmVudD1pKSksZX0sZS5wcm90b3R5cGUuX2ZpcmVFdmVudD1pLGUucHJvdG90eXBlLl9leGVjdXRlPWZ1bmN0aW9uKHQsZSxuKXt0cnl7dChlLG4pfWNhdGNoKHIpe3JldHVybiByfX0sZS5wcm90b3R5cGUuX29uQ2FuY2VsPWZ1bmN0aW9uKCl7fSxlLnByb3RvdHlwZS5fc2V0T25DYW5jZWw9ZnVuY3Rpb24odCl7fSxlLnByb3RvdHlwZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2s9ZnVuY3Rpb24odCl7fSxlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2U9ZnVuY3Rpb24oKXt9LGUucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlPWZ1bmN0aW9uKCl7fSxlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhPWZ1bmN0aW9uKCl7fSxlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbT1mdW5jdGlvbih0LGUpe307dmFyIGV0PXAsbnQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0scnQ9L1tcXC88XFwoXShbXjpcXC9dKyk6KFxcZCspOig/OlxcZCspXFwpP1xccyokLztILmluaGVyaXRzKFMsRXJyb3IpLG4uQ2FwdHVyZWRUcmFjZT1TLFMucHJvdG90eXBlLnVuY3ljbGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9sZW5ndGg7aWYoISgyPnQpKXtmb3IodmFyIGU9W10sbj17fSxyPTAsaT10aGlzO3ZvaWQgMCE9PWk7KytyKWUucHVzaChpKSxpPWkuX3BhcmVudDt0PXRoaXMuX2xlbmd0aD1yO2Zvcih2YXIgcj10LTE7cj49MDstLXIpe3ZhciBvPWVbcl0uc3RhY2s7dm9pZCAwPT09bltvXSYmKG5bb109cil9Zm9yKHZhciByPTA7dD5yOysrcil7dmFyIHM9ZVtyXS5zdGFjayxhPW5bc107aWYodm9pZCAwIT09YSYmYSE9PXIpe2E+MCYmKGVbYS0xXS5fcGFyZW50PXZvaWQgMCxlW2EtMV0uX2xlbmd0aD0xKSxlW3JdLl9wYXJlbnQ9dm9pZCAwLGVbcl0uX2xlbmd0aD0xO3ZhciBjPXI+MD9lW3ItMV06dGhpczt0LTE+YT8oYy5fcGFyZW50PWVbYSsxXSxjLl9wYXJlbnQudW5jeWNsZSgpLGMuX2xlbmd0aD1jLl9wYXJlbnQuX2xlbmd0aCsxKTooYy5fcGFyZW50PXZvaWQgMCxjLl9sZW5ndGg9MSk7Zm9yKHZhciBsPWMuX2xlbmd0aCsxLHU9ci0yO3U+PTA7LS11KWVbdV0uX2xlbmd0aD1sLGwrKztyZXR1cm59fX19LFMucHJvdG90eXBlLmF0dGFjaEV4dHJhVHJhY2U9ZnVuY3Rpb24odCl7aWYoIXQuX19zdGFja0NsZWFuZWRfXyl7dGhpcy51bmN5Y2xlKCk7Zm9yKHZhciBlPWoodCksbj1lLm1lc3NhZ2Uscj1bZS5zdGFja10saT10aGlzO3ZvaWQgMCE9PWk7KXIucHVzaCh3KGkuc3RhY2suc3BsaXQoXCJcXG5cIikpKSxpPWkuX3BhcmVudDtiKHIpLGcociksSC5ub3RFbnVtZXJhYmxlUHJvcCh0LFwic3RhY2tcIixtKG4scikpLEgubm90RW51bWVyYWJsZVByb3AodCxcIl9fc3RhY2tDbGVhbmVkX19cIiwhMCl9fTt2YXIgaXQ9ZnVuY3Rpb24oKXt2YXIgdD0vXlxccyphdFxccyovLGU9ZnVuY3Rpb24odCxlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD90OnZvaWQgMCE9PWUubmFtZSYmdm9pZCAwIT09ZS5tZXNzYWdlP2UudG9TdHJpbmcoKTpGKGUpfTtpZihcIm51bWJlclwiPT10eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSl7RXJyb3Iuc3RhY2tUcmFjZUxpbWl0Kz02LHE9dCxRPWU7dmFyIG49RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U7cmV0dXJuIG50PWZ1bmN0aW9uKHQpe3JldHVybiBCLnRlc3QodCl9LGZ1bmN0aW9uKHQsZSl7RXJyb3Iuc3RhY2tUcmFjZUxpbWl0Kz02LG4odCxlKSxFcnJvci5zdGFja1RyYWNlTGltaXQtPTZ9fXZhciByPW5ldyBFcnJvcjtpZihcInN0cmluZ1wiPT10eXBlb2Ygci5zdGFjayYmci5zdGFjay5zcGxpdChcIlxcblwiKVswXS5pbmRleE9mKFwic3RhY2tEZXRlY3Rpb25AXCIpPj0wKXJldHVybiBxPS9ALyxRPWUsJD0hMCxmdW5jdGlvbih0KXt0LnN0YWNrPShuZXcgRXJyb3IpLnN0YWNrfTt2YXIgaTt0cnl7dGhyb3cgbmV3IEVycm9yfWNhdGNoKG8pe2k9XCJzdGFja1wiaW4gb31yZXR1cm5cInN0YWNrXCJpbiByfHwhaXx8XCJudW1iZXJcIiE9dHlwZW9mIEVycm9yLnN0YWNrVHJhY2VMaW1pdD8oUT1mdW5jdGlvbih0LGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0P3Q6XCJvYmplY3RcIiE9dHlwZW9mIGUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGV8fHZvaWQgMD09PWUubmFtZXx8dm9pZCAwPT09ZS5tZXNzYWdlP0YoZSk6ZS50b1N0cmluZygpfSxudWxsKToocT10LFE9ZSxmdW5jdGlvbih0KXtFcnJvci5zdGFja1RyYWNlTGltaXQrPTY7dHJ5e3Rocm93IG5ldyBFcnJvcn1jYXRjaChlKXt0LnN0YWNrPWUuc3RhY2t9RXJyb3Iuc3RhY2tUcmFjZUxpbWl0LT02fSl9KFtdKTtcInVuZGVmaW5lZFwiIT10eXBlb2YgY29uc29sZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNvbnNvbGUud2FybiYmKEQ9ZnVuY3Rpb24odCl7Y29uc29sZS53YXJuKHQpfSxILmlzTm9kZSYmcHJvY2Vzcy5zdGRlcnIuaXNUVFk/RD1mdW5jdGlvbih0LGUpe3ZhciBuPWU/XCJcdTAwMWJbMzNtXCI6XCJcdTAwMWJbMzFtXCI7Y29uc29sZS53YXJuKG4rdCtcIlx1MDAxYlswbVxcblwiKX06SC5pc05vZGV8fFwic3RyaW5nXCIhPXR5cGVvZihuZXcgRXJyb3IpLnN0YWNrfHwoRD1mdW5jdGlvbih0LGUpe2NvbnNvbGUud2FybihcIiVjXCIrdCxlP1wiY29sb3I6IGRhcmtvcmFuZ2VcIjpcImNvbG9yOiByZWRcIil9KSk7dmFyIG90PXt3YXJuaW5nczp6LGxvbmdTdGFja1RyYWNlczohMSxjYW5jZWxsYXRpb246ITEsbW9uaXRvcmluZzohMX07cmV0dXJuIFgmJmUubG9uZ1N0YWNrVHJhY2VzKCkse2xvbmdTdGFja1RyYWNlczpmdW5jdGlvbigpe3JldHVybiBvdC5sb25nU3RhY2tUcmFjZXN9LHdhcm5pbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIG90Lndhcm5pbmdzfSxjYW5jZWxsYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gb3QuY2FuY2VsbGF0aW9ufSxtb25pdG9yaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIG90Lm1vbml0b3Jpbmd9LHByb3BhZ2F0ZUZyb21GdW5jdGlvbjpmdW5jdGlvbigpe3JldHVybiBldH0sYm91bmRWYWx1ZUZ1bmN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGh9LGNoZWNrRm9yZ290dGVuUmV0dXJuczpkLHNldEJvdW5kczpSLHdhcm46eSxkZXByZWNhdGVkOnYsQ2FwdHVyZWRUcmFjZTpTLGZpcmVEb21FdmVudDpKLGZpcmVHbG9iYWxFdmVudDpZfX19LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDEwOltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gdGhpcy52YWx1ZX1mdW5jdGlvbiBuKCl7dGhyb3cgdGhpcy5yZWFzb259dC5wcm90b3R5cGVbXCJyZXR1cm5cIl09dC5wcm90b3R5cGUudGhlblJldHVybj1mdW5jdGlvbihuKXtyZXR1cm4gbiBpbnN0YW5jZW9mIHQmJm4uc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCksdGhpcy5fdGhlbihlLHZvaWQgMCx2b2lkIDAse3ZhbHVlOm59LHZvaWQgMCl9LHQucHJvdG90eXBlW1widGhyb3dcIl09dC5wcm90b3R5cGUudGhlblRocm93PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90aGVuKG4sdm9pZCAwLHZvaWQgMCx7cmVhc29uOnR9LHZvaWQgMCl9LHQucHJvdG90eXBlLmNhdGNoVGhyb3c9ZnVuY3Rpb24odCl7aWYoYXJndW1lbnRzLmxlbmd0aDw9MSlyZXR1cm4gdGhpcy5fdGhlbih2b2lkIDAsbix2b2lkIDAse3JlYXNvbjp0fSx2b2lkIDApO3ZhciBlPWFyZ3VtZW50c1sxXSxyPWZ1bmN0aW9uKCl7dGhyb3cgZX07cmV0dXJuIHRoaXMuY2F1Z2h0KHQscil9LHQucHJvdG90eXBlLmNhdGNoUmV0dXJuPWZ1bmN0aW9uKG4pe2lmKGFyZ3VtZW50cy5sZW5ndGg8PTEpcmV0dXJuIG4gaW5zdGFuY2VvZiB0JiZuLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpLHRoaXMuX3RoZW4odm9pZCAwLGUsdm9pZCAwLHt2YWx1ZTpufSx2b2lkIDApO3ZhciByPWFyZ3VtZW50c1sxXTtyIGluc3RhbmNlb2YgdCYmci5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTt2YXIgaT1mdW5jdGlvbigpe3JldHVybiByfTtyZXR1cm4gdGhpcy5jYXVnaHQobixpKX19fSx7fV0sMTE6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7cmV0dXJuIG8odGhpcyl9ZnVuY3Rpb24gcih0LG4pe3JldHVybiBpKHQsbixlLGUpfXZhciBpPXQucmVkdWNlLG89dC5hbGw7dC5wcm90b3R5cGUuZWFjaD1mdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLHQsZSwwKS5fdGhlbihuLHZvaWQgMCx2b2lkIDAsdGhpcyx2b2lkIDApfSx0LnByb3RvdHlwZS5tYXBTZXJpZXM9ZnVuY3Rpb24odCl7cmV0dXJuIGkodGhpcyx0LGUsZSl9LHQuZWFjaD1mdW5jdGlvbih0LHIpe3JldHVybiBpKHQscixlLDApLl90aGVuKG4sdm9pZCAwLHZvaWQgMCx0LHZvaWQgMCl9LHQubWFwU2VyaWVzPXJ9fSx7fV0sMTI6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSl7ZnVuY3Rpb24gbihyKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG4/KHAodGhpcyxcIm1lc3NhZ2VcIixcInN0cmluZ1wiPT10eXBlb2Ygcj9yOmUpLHAodGhpcyxcIm5hbWVcIix0KSx2b2lkKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlP0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsdGhpcy5jb25zdHJ1Y3Rvcik6RXJyb3IuY2FsbCh0aGlzKSkpOm5ldyBuKHIpfXJldHVybiB1KG4sRXJyb3IpLG59ZnVuY3Rpb24gaSh0KXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGk/KHAodGhpcyxcIm5hbWVcIixcIk9wZXJhdGlvbmFsRXJyb3JcIikscCh0aGlzLFwibWVzc2FnZVwiLHQpLHRoaXMuY2F1c2U9dCx0aGlzLmlzT3BlcmF0aW9uYWw9ITAsdm9pZCh0IGluc3RhbmNlb2YgRXJyb3I/KHAodGhpcyxcIm1lc3NhZ2VcIix0Lm1lc3NhZ2UpLHAodGhpcyxcInN0YWNrXCIsdC5zdGFjaykpOkVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHRoaXMuY29uc3RydWN0b3IpKSk6bmV3IGkodCl9dmFyIG8scyxhPXQoXCIuL2VzNVwiKSxjPWEuZnJlZXplLGw9dChcIi4vdXRpbFwiKSx1PWwuaW5oZXJpdHMscD1sLm5vdEVudW1lcmFibGVQcm9wLGg9cihcIldhcm5pbmdcIixcIndhcm5pbmdcIiksZj1yKFwiQ2FuY2VsbGF0aW9uRXJyb3JcIixcImNhbmNlbGxhdGlvbiBlcnJvclwiKSxfPXIoXCJUaW1lb3V0RXJyb3JcIixcInRpbWVvdXQgZXJyb3JcIiksZD1yKFwiQWdncmVnYXRlRXJyb3JcIixcImFnZ3JlZ2F0ZSBlcnJvclwiKTt0cnl7bz1UeXBlRXJyb3Iscz1SYW5nZUVycm9yfWNhdGNoKHYpe289cihcIlR5cGVFcnJvclwiLFwidHlwZSBlcnJvclwiKSxzPXIoXCJSYW5nZUVycm9yXCIsXCJyYW5nZSBlcnJvclwiKX1mb3IodmFyIHk9XCJqb2luIHBvcCBwdXNoIHNoaWZ0IHVuc2hpZnQgc2xpY2UgZmlsdGVyIGZvckVhY2ggc29tZSBldmVyeSBtYXAgaW5kZXhPZiBsYXN0SW5kZXhPZiByZWR1Y2UgcmVkdWNlUmlnaHQgc29ydCByZXZlcnNlXCIuc3BsaXQoXCIgXCIpLG09MDttPHkubGVuZ3RoOysrbSlcImZ1bmN0aW9uXCI9PXR5cGVvZiBBcnJheS5wcm90b3R5cGVbeVttXV0mJihkLnByb3RvdHlwZVt5W21dXT1BcnJheS5wcm90b3R5cGVbeVttXV0pO2EuZGVmaW5lUHJvcGVydHkoZC5wcm90b3R5cGUsXCJsZW5ndGhcIix7dmFsdWU6MCxjb25maWd1cmFibGU6ITEsd3JpdGFibGU6ITAsZW51bWVyYWJsZTohMH0pLGQucHJvdG90eXBlLmlzT3BlcmF0aW9uYWw9ITA7dmFyIGc9MDtkLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciB0PUFycmF5KDQqZysxKS5qb2luKFwiIFwiKSxlPVwiXFxuXCIrdCtcIkFnZ3JlZ2F0ZUVycm9yIG9mOlxcblwiO2crKyx0PUFycmF5KDQqZysxKS5qb2luKFwiIFwiKTtmb3IodmFyIG49MDtuPHRoaXMubGVuZ3RoOysrbil7Zm9yKHZhciByPXRoaXNbbl09PT10aGlzP1wiW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXVwiOnRoaXNbbl0rXCJcIixpPXIuc3BsaXQoXCJcXG5cIiksbz0wO288aS5sZW5ndGg7KytvKWlbb109dCtpW29dO3I9aS5qb2luKFwiXFxuXCIpLGUrPXIrXCJcXG5cIn1yZXR1cm4gZy0tLGV9LHUoaSxFcnJvcik7dmFyIGI9RXJyb3IuX19CbHVlYmlyZEVycm9yVHlwZXNfXztifHwoYj1jKHtDYW5jZWxsYXRpb25FcnJvcjpmLFRpbWVvdXRFcnJvcjpfLE9wZXJhdGlvbmFsRXJyb3I6aSxSZWplY3Rpb25FcnJvcjppLEFnZ3JlZ2F0ZUVycm9yOmR9KSxhLmRlZmluZVByb3BlcnR5KEVycm9yLFwiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiLHt2YWx1ZTpiLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExfSkpLGUuZXhwb3J0cz17RXJyb3I6RXJyb3IsVHlwZUVycm9yOm8sUmFuZ2VFcnJvcjpzLENhbmNlbGxhdGlvbkVycm9yOmIuQ2FuY2VsbGF0aW9uRXJyb3IsT3BlcmF0aW9uYWxFcnJvcjpiLk9wZXJhdGlvbmFsRXJyb3IsVGltZW91dEVycm9yOmIuVGltZW91dEVycm9yLEFnZ3JlZ2F0ZUVycm9yOmIuQWdncmVnYXRlRXJyb3IsV2FybmluZzpofX0se1wiLi9lczVcIjoxMyxcIi4vdXRpbFwiOjM2fV0sMTM6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj1mdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3JldHVybiB2b2lkIDA9PT10aGlzfSgpO2lmKHIpZS5leHBvcnRzPXtmcmVlemU6T2JqZWN0LmZyZWV6ZSxkZWZpbmVQcm9wZXJ0eTpPYmplY3QuZGVmaW5lUHJvcGVydHksZ2V0RGVzY3JpcHRvcjpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLGtleXM6T2JqZWN0LmtleXMsbmFtZXM6T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsZ2V0UHJvdG90eXBlT2Y6T2JqZWN0LmdldFByb3RvdHlwZU9mLGlzQXJyYXk6QXJyYXkuaXNBcnJheSxpc0VTNTpyLHByb3BlcnR5SXNXcml0YWJsZTpmdW5jdGlvbih0LGUpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxlKTtyZXR1cm4hKG4mJiFuLndyaXRhYmxlJiYhbi5zZXQpfX07ZWxzZXt2YXIgaT17fS5oYXNPd25Qcm9wZXJ0eSxvPXt9LnRvU3RyaW5nLHM9e30uY29uc3RydWN0b3IucHJvdG90eXBlLGE9ZnVuY3Rpb24odCl7dmFyIGU9W107Zm9yKHZhciBuIGluIHQpaS5jYWxsKHQsbikmJmUucHVzaChuKTtyZXR1cm4gZX0sYz1mdW5jdGlvbih0LGUpe3JldHVybnt2YWx1ZTp0W2VdfX0sbD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRbZV09bi52YWx1ZSx0fSx1PWZ1bmN0aW9uKHQpe3JldHVybiB0fSxwPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gT2JqZWN0KHQpLmNvbnN0cnVjdG9yLnByb3RvdHlwZX1jYXRjaChlKXtyZXR1cm4gc319LGg9ZnVuY3Rpb24odCl7dHJ5e3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PW8uY2FsbCh0KX1jYXRjaChlKXtyZXR1cm4hMX19O2UuZXhwb3J0cz17aXNBcnJheTpoLGtleXM6YSxuYW1lczphLGRlZmluZVByb3BlcnR5OmwsZ2V0RGVzY3JpcHRvcjpjLGZyZWV6ZTp1LGdldFByb3RvdHlwZU9mOnAsaXNFUzU6cixwcm9wZXJ0eUlzV3JpdGFibGU6ZnVuY3Rpb24oKXtyZXR1cm4hMH19fX0se31dLDE0OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXA7dC5wcm90b3R5cGUuZmlsdGVyPWZ1bmN0aW9uKHQscil7cmV0dXJuIG4odGhpcyx0LHIsZSl9LHQuZmlsdGVyPWZ1bmN0aW9uKHQscixpKXtyZXR1cm4gbih0LHIsaSxlKX19fSx7fV0sMTU6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiByKHQsZSxuKXt0aGlzLnByb21pc2U9dCx0aGlzLnR5cGU9ZSx0aGlzLmhhbmRsZXI9bix0aGlzLmNhbGxlZD0hMSx0aGlzLmNhbmNlbFByb21pc2U9bnVsbH1mdW5jdGlvbiBpKHQpe3RoaXMuZmluYWxseUhhbmRsZXI9dH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIG51bGwhPXQuY2FuY2VsUHJvbWlzZT8oYXJndW1lbnRzLmxlbmd0aD4xP3QuY2FuY2VsUHJvbWlzZS5fcmVqZWN0KGUpOnQuY2FuY2VsUHJvbWlzZS5fY2FuY2VsKCksdC5jYW5jZWxQcm9taXNlPW51bGwsITApOiExfWZ1bmN0aW9uIHMoKXtyZXR1cm4gYy5jYWxsKHRoaXMsdGhpcy5wcm9taXNlLl90YXJnZXQoKS5fc2V0dGxlZFZhbHVlKCkpfWZ1bmN0aW9uIGEodCl7cmV0dXJuIG8odGhpcyx0KT92b2lkIDA6KHAuZT10LHApfWZ1bmN0aW9uIGModCl7dmFyIHI9dGhpcy5wcm9taXNlLGM9dGhpcy5oYW5kbGVyO2lmKCF0aGlzLmNhbGxlZCl7dGhpcy5jYWxsZWQ9ITA7dmFyIGw9dGhpcy5pc0ZpbmFsbHlIYW5kbGVyKCk/Yy5jYWxsKHIuX2JvdW5kVmFsdWUoKSk6Yy5jYWxsKHIuX2JvdW5kVmFsdWUoKSx0KTtpZih2b2lkIDAhPT1sKXtyLl9zZXRSZXR1cm5lZE5vblVuZGVmaW5lZCgpO3ZhciBoPW4obCxyKTtpZihoIGluc3RhbmNlb2YgZSl7aWYobnVsbCE9dGhpcy5jYW5jZWxQcm9taXNlKXtpZihoLl9pc0NhbmNlbGxlZCgpKXt2YXIgZj1uZXcgdShcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO3JldHVybiByLl9hdHRhY2hFeHRyYVRyYWNlKGYpLHAuZT1mLHB9aC5pc1BlbmRpbmcoKSYmaC5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sobmV3IGkodGhpcykpfXJldHVybiBoLl90aGVuKHMsYSx2b2lkIDAsdGhpcyx2b2lkIDApfX19cmV0dXJuIHIuaXNSZWplY3RlZCgpPyhvKHRoaXMpLHAuZT10LHApOihvKHRoaXMpLHQpfXZhciBsPXQoXCIuL3V0aWxcIiksdT1lLkNhbmNlbGxhdGlvbkVycm9yLHA9bC5lcnJvck9iajtyZXR1cm4gci5wcm90b3R5cGUuaXNGaW5hbGx5SGFuZGxlcj1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy50eXBlfSxpLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkPWZ1bmN0aW9uKCl7byh0aGlzLmZpbmFsbHlIYW5kbGVyKX0sZS5wcm90b3R5cGUuX3Bhc3NUaHJvdWdoPWZ1bmN0aW9uKHQsZSxuLGkpe3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/dGhpcy50aGVuKCk6dGhpcy5fdGhlbihuLGksdm9pZCAwLG5ldyByKHRoaXMsZSx0KSx2b2lkIDApfSxlLnByb3RvdHlwZS5sYXN0bHk9ZS5wcm90b3R5cGVbXCJmaW5hbGx5XCJdPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXNzVGhyb3VnaCh0LDAsYyxjKX0sZS5wcm90b3R5cGUudGFwPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXNzVGhyb3VnaCh0LDEsYyl9LHJ9fSx7XCIuL3V0aWxcIjozNn1dLDE2OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbixyLGksbyxzKXtmdW5jdGlvbiBhKHQsbixyKXtmb3IodmFyIG89MDtvPG4ubGVuZ3RoOysrbyl7ci5fcHVzaENvbnRleHQoKTt2YXIgcz1mKG5bb10pKHQpO2lmKHIuX3BvcENvbnRleHQoKSxzPT09aCl7ci5fcHVzaENvbnRleHQoKTt2YXIgYT1lLnJlamVjdChoLmUpO3JldHVybiByLl9wb3BDb250ZXh0KCksYX12YXIgYz1pKHMscik7aWYoYyBpbnN0YW5jZW9mIGUpcmV0dXJuIGN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gYyh0LG4saSxvKXtpZihzLmNhbmNlbGxhdGlvbigpKXt2YXIgYT1uZXcgZShyKSxjPXRoaXMuX2ZpbmFsbHlQcm9taXNlPW5ldyBlKHIpO3RoaXMuX3Byb21pc2U9YS5sYXN0bHkoZnVuY3Rpb24oKXtyZXR1cm4gY30pLGEuX2NhcHR1cmVTdGFja1RyYWNlKCksYS5fc2V0T25DYW5jZWwodGhpcyl9ZWxzZXt2YXIgbD10aGlzLl9wcm9taXNlPW5ldyBlKHIpO2wuX2NhcHR1cmVTdGFja1RyYWNlKCl9dGhpcy5fc3RhY2s9byx0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbj10LHRoaXMuX3JlY2VpdmVyPW4sdGhpcy5fZ2VuZXJhdG9yPXZvaWQgMCx0aGlzLl95aWVsZEhhbmRsZXJzPVwiZnVuY3Rpb25cIj09dHlwZW9mIGk/W2ldLmNvbmNhdChfKTpfLHRoaXMuX3lpZWxkZWRQcm9taXNlPW51bGwsdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2U9ITF9dmFyIGw9dChcIi4vZXJyb3JzXCIpLHU9bC5UeXBlRXJyb3IscD10KFwiLi91dGlsXCIpLGg9cC5lcnJvck9iaixmPXAudHJ5Q2F0Y2gsXz1bXTtwLmluaGVyaXRzKGMsbyksYy5wcm90b3R5cGUuX2lzUmVzb2x2ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuX3Byb21pc2V9LGMucHJvdG90eXBlLl9jbGVhbnVwPWZ1bmN0aW9uKCl7dGhpcy5fcHJvbWlzZT10aGlzLl9nZW5lcmF0b3I9bnVsbCxzLmNhbmNlbGxhdGlvbigpJiZudWxsIT09dGhpcy5fZmluYWxseVByb21pc2UmJih0aGlzLl9maW5hbGx5UHJvbWlzZS5fZnVsZmlsbCgpLHRoaXMuX2ZpbmFsbHlQcm9taXNlPW51bGwpfSxjLnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZD1mdW5jdGlvbigpe2lmKCF0aGlzLl9pc1Jlc29sdmVkKCkpe3ZhciB0LG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXTtpZihuKXRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCksdD1mKHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3Isdm9pZCAwKSx0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7ZWxzZXt2YXIgcj1uZXcgZS5DYW5jZWxsYXRpb25FcnJvcihcImdlbmVyYXRvciAucmV0dXJuKCkgc2VudGluZWxcIik7ZS5jb3JvdXRpbmUucmV0dXJuU2VudGluZWw9cix0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHIpLHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCksdD1mKHRoaXMuX2dlbmVyYXRvcltcInRocm93XCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvcixyKSx0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCl9dGhpcy5fY2FuY2VsbGF0aW9uUGhhc2U9ITAsdGhpcy5feWllbGRlZFByb21pc2U9bnVsbCx0aGlzLl9jb250aW51ZSh0KX19LGMucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkPWZ1bmN0aW9uKHQpe3RoaXMuX3lpZWxkZWRQcm9taXNlPW51bGwsdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTt2YXIgZT1mKHRoaXMuX2dlbmVyYXRvci5uZXh0KS5jYWxsKHRoaXMuX2dlbmVyYXRvcix0KTt0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCksdGhpcy5fY29udGludWUoZSl9LGMucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQ9ZnVuY3Rpb24odCl7dGhpcy5feWllbGRlZFByb21pc2U9bnVsbCx0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHQpLHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7dmFyIGU9Zih0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsdCk7dGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpLHRoaXMuX2NvbnRpbnVlKGUpfSxjLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkPWZ1bmN0aW9uKCl7aWYodGhpcy5feWllbGRlZFByb21pc2UgaW5zdGFuY2VvZiBlKXt2YXIgdD10aGlzLl95aWVsZGVkUHJvbWlzZTt0aGlzLl95aWVsZGVkUHJvbWlzZT1udWxsLHQuY2FuY2VsKCl9fSxjLnByb3RvdHlwZS5wcm9taXNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Byb21pc2V9LGMucHJvdG90eXBlLl9ydW49ZnVuY3Rpb24oKXt0aGlzLl9nZW5lcmF0b3I9dGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24uY2FsbCh0aGlzLl9yZWNlaXZlciksdGhpcy5fcmVjZWl2ZXI9dGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb249dm9pZCAwLHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodm9pZCAwKX0sYy5wcm90b3R5cGUuX2NvbnRpbnVlPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuX3Byb21pc2U7aWYodD09PWgpcmV0dXJuIHRoaXMuX2NsZWFudXAoKSx0aGlzLl9jYW5jZWxsYXRpb25QaGFzZT9uLmNhbmNlbCgpOm4uX3JlamVjdENhbGxiYWNrKHQuZSwhMSk7dmFyIHI9dC52YWx1ZTtpZih0LmRvbmU9PT0hMClyZXR1cm4gdGhpcy5fY2xlYW51cCgpLHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlP24uY2FuY2VsKCk6bi5fcmVzb2x2ZUNhbGxiYWNrKHIpO3ZhciBvPWkocix0aGlzLl9wcm9taXNlKTtpZighKG8gaW5zdGFuY2VvZiBlKSYmKG89YShvLHRoaXMuX3lpZWxkSGFuZGxlcnMsdGhpcy5fcHJvbWlzZSksbnVsbD09PW8pKXJldHVybiB2b2lkIHRoaXMuX3Byb21pc2VSZWplY3RlZChuZXcgdShcIkEgdmFsdWUgJXMgd2FzIHlpZWxkZWQgdGhhdCBjb3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIHByb21pc2VcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXFxuXCIucmVwbGFjZShcIiVzXCIscikrXCJGcm9tIGNvcm91dGluZTpcXG5cIit0aGlzLl9zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxLC03KS5qb2luKFwiXFxuXCIpKSk7bz1vLl90YXJnZXQoKTt2YXIgcz1vLl9iaXRGaWVsZDswPT09KDUwMzk3MTg0JnMpPyh0aGlzLl95aWVsZGVkUHJvbWlzZT1vLG8uX3Byb3h5KHRoaXMsbnVsbCkpOjAhPT0oMzM1NTQ0MzImcyk/ZS5fYXN5bmMuaW52b2tlKHRoaXMuX3Byb21pc2VGdWxmaWxsZWQsdGhpcyxvLl92YWx1ZSgpKTowIT09KDE2Nzc3MjE2JnMpP2UuX2FzeW5jLmludm9rZSh0aGlzLl9wcm9taXNlUmVqZWN0ZWQsdGhpcyxvLl9yZWFzb24oKSk6dGhpcy5fcHJvbWlzZUNhbmNlbGxlZCgpfSxlLmNvcm91dGluZT1mdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IHUoXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO3ZhciBuPU9iamVjdChlKS55aWVsZEhhbmRsZXIscj1jLGk9KG5ldyBFcnJvcikuc3RhY2s7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dC5hcHBseSh0aGlzLGFyZ3VtZW50cyksbz1uZXcgcih2b2lkIDAsdm9pZCAwLG4saSkscz1vLnByb21pc2UoKTtyZXR1cm4gby5fZ2VuZXJhdG9yPWUsby5fcHJvbWlzZUZ1bGZpbGxlZCh2b2lkIDApLFxuc319LGUuY29yb3V0aW5lLmFkZFlpZWxkSGFuZGxlcj1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyB1KFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIitwLmNsYXNzU3RyaW5nKHQpKTtfLnB1c2godCl9LGUuc3Bhd249ZnVuY3Rpb24odCl7aWYocy5kZXByZWNhdGVkKFwiUHJvbWlzZS5zcGF3bigpXCIsXCJQcm9taXNlLmNvcm91dGluZSgpXCIpLFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJuIG4oXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO3ZhciByPW5ldyBjKHQsdGhpcyksaT1yLnByb21pc2UoKTtyZXR1cm4gci5fcnVuKGUuc3Bhd24pLGl9fX0se1wiLi9lcnJvcnNcIjoxMixcIi4vdXRpbFwiOjM2fV0sMTc6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsaSxvLHMpe3ZhciBhPXQoXCIuL3V0aWxcIik7YS5jYW5FdmFsdWF0ZSxhLnRyeUNhdGNoLGEuZXJyb3JPYmo7ZS5qb2luPWZ1bmN0aW9uKCl7dmFyIHQsZT1hcmd1bWVudHMubGVuZ3RoLTE7aWYoZT4wJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhcmd1bWVudHNbZV0pe3Q9YXJndW1lbnRzW2VdO3ZhciByfXZhciBpPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTt0JiZpLnBvcCgpO3ZhciByPW5ldyBuKGkpLnByb21pc2UoKTtyZXR1cm4gdm9pZCAwIT09dD9yLnNwcmVhZCh0KTpyfX19LHtcIi4vdXRpbFwiOjM2fV0sMTg6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsaSxvLHMpe2Z1bmN0aW9uIGEodCxlLG4scil7dGhpcy5jb25zdHJ1Y3RvciQodCksdGhpcy5fcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTt2YXIgaT1sKCk7dGhpcy5fY2FsbGJhY2s9bnVsbD09PWk/ZTp1LmRvbWFpbkJpbmQoaSxlKSx0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM9cj09PW8/bmV3IEFycmF5KHRoaXMubGVuZ3RoKCkpOm51bGwsdGhpcy5fbGltaXQ9bix0aGlzLl9pbkZsaWdodD0wLHRoaXMuX3F1ZXVlPVtdLGYuaW52b2tlKHRoaXMuX2FzeW5jSW5pdCx0aGlzLHZvaWQgMCl9ZnVuY3Rpb24gYyh0LG4saSxvKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXJldHVybiByKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIit1LmNsYXNzU3RyaW5nKG4pKTt2YXIgcz0wO2lmKHZvaWQgMCE9PWkpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBpfHxudWxsPT09aSlyZXR1cm4gZS5yZWplY3QobmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QgYnV0IGl0IGlzIFwiK3UuY2xhc3NTdHJpbmcoaSkpKTtpZihcIm51bWJlclwiIT10eXBlb2YgaS5jb25jdXJyZW5jeSlyZXR1cm4gZS5yZWplY3QobmV3IFR5cGVFcnJvcihcIidjb25jdXJyZW5jeScgbXVzdCBiZSBhIG51bWJlciBidXQgaXQgaXMgXCIrdS5jbGFzc1N0cmluZyhpLmNvbmN1cnJlbmN5KSkpO3M9aS5jb25jdXJyZW5jeX1yZXR1cm4gcz1cIm51bWJlclwiPT10eXBlb2YgcyYmaXNGaW5pdGUocykmJnM+PTE/czowLG5ldyBhKHQsbixzLG8pLnByb21pc2UoKX12YXIgbD1lLl9nZXREb21haW4sdT10KFwiLi91dGlsXCIpLHA9dS50cnlDYXRjaCxoPXUuZXJyb3JPYmosZj1lLl9hc3luYzt1LmluaGVyaXRzKGEsbiksYS5wcm90b3R5cGUuX2FzeW5jSW5pdD1mdW5jdGlvbigpe3RoaXMuX2luaXQkKHZvaWQgMCwtMil9LGEucHJvdG90eXBlLl9pbml0PWZ1bmN0aW9uKCl7fSxhLnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZD1mdW5jdGlvbih0LG4pe3ZhciByPXRoaXMuX3ZhbHVlcyxvPXRoaXMubGVuZ3RoKCksYT10aGlzLl9wcmVzZXJ2ZWRWYWx1ZXMsYz10aGlzLl9saW1pdDtpZigwPm4pe2lmKG49LTEqbi0xLHJbbl09dCxjPj0xJiYodGhpcy5faW5GbGlnaHQtLSx0aGlzLl9kcmFpblF1ZXVlKCksdGhpcy5faXNSZXNvbHZlZCgpKSlyZXR1cm4hMH1lbHNle2lmKGM+PTEmJnRoaXMuX2luRmxpZ2h0Pj1jKXJldHVybiByW25dPXQsdGhpcy5fcXVldWUucHVzaChuKSwhMTtudWxsIT09YSYmKGFbbl09dCk7dmFyIGw9dGhpcy5fcHJvbWlzZSx1PXRoaXMuX2NhbGxiYWNrLGY9bC5fYm91bmRWYWx1ZSgpO2wuX3B1c2hDb250ZXh0KCk7dmFyIF89cCh1KS5jYWxsKGYsdCxuLG8pLGQ9bC5fcG9wQ29udGV4dCgpO2lmKHMuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKF8sZCxudWxsIT09YT9cIlByb21pc2UuZmlsdGVyXCI6XCJQcm9taXNlLm1hcFwiLGwpLF89PT1oKXJldHVybiB0aGlzLl9yZWplY3QoXy5lKSwhMDt2YXIgdj1pKF8sdGhpcy5fcHJvbWlzZSk7aWYodiBpbnN0YW5jZW9mIGUpe3Y9di5fdGFyZ2V0KCk7dmFyIHk9di5fYml0RmllbGQ7aWYoMD09PSg1MDM5NzE4NCZ5KSlyZXR1cm4gYz49MSYmdGhpcy5faW5GbGlnaHQrKyxyW25dPXYsdi5fcHJveHkodGhpcywtMSoobisxKSksITE7aWYoMD09PSgzMzU1NDQzMiZ5KSlyZXR1cm4gMCE9PSgxNjc3NzIxNiZ5KT8odGhpcy5fcmVqZWN0KHYuX3JlYXNvbigpKSwhMCk6KHRoaXMuX2NhbmNlbCgpLCEwKTtfPXYuX3ZhbHVlKCl9cltuXT1ffXZhciBtPSsrdGhpcy5fdG90YWxSZXNvbHZlZDtyZXR1cm4gbT49bz8obnVsbCE9PWE/dGhpcy5fZmlsdGVyKHIsYSk6dGhpcy5fcmVzb2x2ZShyKSwhMCk6ITF9LGEucHJvdG90eXBlLl9kcmFpblF1ZXVlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX3F1ZXVlLGU9dGhpcy5fbGltaXQsbj10aGlzLl92YWx1ZXM7dC5sZW5ndGg+MCYmdGhpcy5faW5GbGlnaHQ8ZTspe2lmKHRoaXMuX2lzUmVzb2x2ZWQoKSlyZXR1cm47dmFyIHI9dC5wb3AoKTt0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG5bcl0scil9fSxhLnByb3RvdHlwZS5fZmlsdGVyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUubGVuZ3RoLHI9bmV3IEFycmF5KG4pLGk9MCxvPTA7bj5vOysrbyl0W29dJiYocltpKytdPWVbb10pO3IubGVuZ3RoPWksdGhpcy5fcmVzb2x2ZShyKX0sYS5wcm90b3R5cGUucHJlc2VydmVkVmFsdWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ByZXNlcnZlZFZhbHVlc30sZS5wcm90b3R5cGUubWFwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGModGhpcyx0LGUsbnVsbCl9LGUubWFwPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBjKHQsZSxuLHIpfX19LHtcIi4vdXRpbFwiOjM2fV0sMTk6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsaSxvKXt2YXIgcz10KFwiLi91dGlsXCIpLGE9cy50cnlDYXRjaDtlLm1ldGhvZD1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBlLlR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIrcy5jbGFzc1N0cmluZyh0KSk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHI9bmV3IGUobik7ci5fY2FwdHVyZVN0YWNrVHJhY2UoKSxyLl9wdXNoQ29udGV4dCgpO3ZhciBpPWEodCkuYXBwbHkodGhpcyxhcmd1bWVudHMpLHM9ci5fcG9wQ29udGV4dCgpO3JldHVybiBvLmNoZWNrRm9yZ290dGVuUmV0dXJucyhpLHMsXCJQcm9taXNlLm1ldGhvZFwiLHIpLHIuX3Jlc29sdmVGcm9tU3luY1ZhbHVlKGkpLHJ9fSxlLmF0dGVtcHQ9ZVtcInRyeVwiXT1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiBpKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIitzLmNsYXNzU3RyaW5nKHQpKTt2YXIgcj1uZXcgZShuKTtyLl9jYXB0dXJlU3RhY2tUcmFjZSgpLHIuX3B1c2hDb250ZXh0KCk7dmFyIGM7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtvLmRlcHJlY2F0ZWQoXCJjYWxsaW5nIFByb21pc2UudHJ5IHdpdGggbW9yZSB0aGFuIDEgYXJndW1lbnRcIik7dmFyIGw9YXJndW1lbnRzWzFdLHU9YXJndW1lbnRzWzJdO2M9cy5pc0FycmF5KGwpP2EodCkuYXBwbHkodSxsKTphKHQpLmNhbGwodSxsKX1lbHNlIGM9YSh0KSgpO3ZhciBwPXIuX3BvcENvbnRleHQoKTtyZXR1cm4gby5jaGVja0ZvcmdvdHRlblJldHVybnMoYyxwLFwiUHJvbWlzZS50cnlcIixyKSxyLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZShjKSxyfSxlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21TeW5jVmFsdWU9ZnVuY3Rpb24odCl7dD09PXMuZXJyb3JPYmo/dGhpcy5fcmVqZWN0Q2FsbGJhY2sodC5lLCExKTp0aGlzLl9yZXNvbHZlQ2FsbGJhY2sodCwhMCl9fX0se1wiLi91dGlsXCI6MzZ9XSwyMDpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBFcnJvciYmdS5nZXRQcm90b3R5cGVPZih0KT09PUVycm9yLnByb3RvdHlwZX1mdW5jdGlvbiBpKHQpe3ZhciBlO2lmKHIodCkpe2U9bmV3IGwodCksZS5uYW1lPXQubmFtZSxlLm1lc3NhZ2U9dC5tZXNzYWdlLGUuc3RhY2s9dC5zdGFjaztmb3IodmFyIG49dS5rZXlzKHQpLGk9MDtpPG4ubGVuZ3RoOysraSl7dmFyIG89bltpXTtwLnRlc3Qobyl8fChlW29dPXRbb10pfXJldHVybiBlfXJldHVybiBzLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbih0KSx0fWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZnVuY3Rpb24obixyKXtpZihudWxsIT09dCl7aWYobil7dmFyIG89aShhKG4pKTt0Ll9hdHRhY2hFeHRyYVRyYWNlKG8pLHQuX3JlamVjdChvKX1lbHNlIGlmKGUpe3ZhciBzPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3QuX2Z1bGZpbGwocyl9ZWxzZSB0Ll9mdWxmaWxsKHIpO3Q9bnVsbH19fXZhciBzPXQoXCIuL3V0aWxcIiksYT1zLm1heWJlV3JhcEFzRXJyb3IsYz10KFwiLi9lcnJvcnNcIiksbD1jLk9wZXJhdGlvbmFsRXJyb3IsdT10KFwiLi9lczVcIikscD0vXig/Om5hbWV8bWVzc2FnZXxzdGFja3xjYXVzZSkkLztlLmV4cG9ydHM9b30se1wiLi9lcnJvcnNcIjoxMixcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDIxOltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCxlKXt2YXIgbj10aGlzO2lmKCFvLmlzQXJyYXkodCkpcmV0dXJuIHIuY2FsbChuLHQsZSk7dmFyIGk9YShlKS5hcHBseShuLl9ib3VuZFZhbHVlKCksW251bGxdLmNvbmNhdCh0KSk7aT09PWMmJnMudGhyb3dMYXRlcihpLmUpfWZ1bmN0aW9uIHIodCxlKXt2YXIgbj10aGlzLHI9bi5fYm91bmRWYWx1ZSgpLGk9dm9pZCAwPT09dD9hKGUpLmNhbGwocixudWxsKTphKGUpLmNhbGwocixudWxsLHQpO2k9PT1jJiZzLnRocm93TGF0ZXIoaS5lKX1mdW5jdGlvbiBpKHQsZSl7dmFyIG49dGhpcztpZighdCl7dmFyIHI9bmV3IEVycm9yKHQrXCJcIik7ci5jYXVzZT10LHQ9cn12YXIgaT1hKGUpLmNhbGwobi5fYm91bmRWYWx1ZSgpLHQpO2k9PT1jJiZzLnRocm93TGF0ZXIoaS5lKX12YXIgbz10KFwiLi91dGlsXCIpLHM9ZS5fYXN5bmMsYT1vLnRyeUNhdGNoLGM9by5lcnJvck9iajtlLnByb3RvdHlwZS5hc0NhbGxiYWNrPWUucHJvdG90eXBlLm5vZGVpZnk9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KXt2YXIgbz1yO3ZvaWQgMCE9PWUmJk9iamVjdChlKS5zcHJlYWQmJihvPW4pLHRoaXMuX3RoZW4obyxpLHZvaWQgMCx0aGlzLHQpfXJldHVybiB0aGlzfX19LHtcIi4vdXRpbFwiOjM2fV0sMjI6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKCl7fWZ1bmN0aW9uIHIodCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBtKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIitmLmNsYXNzU3RyaW5nKGUpKTtpZih0LmNvbnN0cnVjdG9yIT09aSl0aHJvdyBuZXcgbShcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKX1mdW5jdGlvbiBpKHQpe3RoaXMuX2JpdEZpZWxkPTAsdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMD12b2lkIDAsdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA9dm9pZCAwLHRoaXMuX3Byb21pc2UwPXZvaWQgMCx0aGlzLl9yZWNlaXZlcjA9dm9pZCAwLHQhPT1iJiYocih0aGlzLHQpLHRoaXMuX3Jlc29sdmVGcm9tRXhlY3V0b3IodCkpLHRoaXMuX3Byb21pc2VDcmVhdGVkKCksdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUNyZWF0ZWRcIix0aGlzKX1mdW5jdGlvbiBvKHQpe3RoaXMucHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHQpfWZ1bmN0aW9uIHModCl7dGhpcy5wcm9taXNlLl9yZWplY3RDYWxsYmFjayh0LCExKX1mdW5jdGlvbiBhKHQpe3ZhciBlPW5ldyBpKGIpO2UuX2Z1bGZpbGxtZW50SGFuZGxlcjA9dCxlLl9yZWplY3Rpb25IYW5kbGVyMD10LGUuX3Byb21pc2UwPXQsZS5fcmVjZWl2ZXIwPXR9dmFyIGMsbD1mdW5jdGlvbigpe3JldHVybiBuZXcgbShcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIil9LHU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGkuUHJvbWlzZUluc3BlY3Rpb24odGhpcy5fdGFyZ2V0KCkpfSxwPWZ1bmN0aW9uKHQpe3JldHVybiBpLnJlamVjdChuZXcgbSh0KSl9LGg9e30sZj10KFwiLi91dGlsXCIpO2M9Zi5pc05vZGU/ZnVuY3Rpb24oKXt2YXIgdD1wcm9jZXNzLmRvbWFpbjtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdH06ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sZi5ub3RFbnVtZXJhYmxlUHJvcChpLFwiX2dldERvbWFpblwiLGMpO3ZhciBfPXQoXCIuL2VzNVwiKSxkPXQoXCIuL2FzeW5jXCIpLHY9bmV3IGQ7Xy5kZWZpbmVQcm9wZXJ0eShpLFwiX2FzeW5jXCIse3ZhbHVlOnZ9KTt2YXIgeT10KFwiLi9lcnJvcnNcIiksbT1pLlR5cGVFcnJvcj15LlR5cGVFcnJvcjtpLlJhbmdlRXJyb3I9eS5SYW5nZUVycm9yO3ZhciBnPWkuQ2FuY2VsbGF0aW9uRXJyb3I9eS5DYW5jZWxsYXRpb25FcnJvcjtpLlRpbWVvdXRFcnJvcj15LlRpbWVvdXRFcnJvcixpLk9wZXJhdGlvbmFsRXJyb3I9eS5PcGVyYXRpb25hbEVycm9yLGkuUmVqZWN0aW9uRXJyb3I9eS5PcGVyYXRpb25hbEVycm9yLGkuQWdncmVnYXRlRXJyb3I9eS5BZ2dyZWdhdGVFcnJvcjt2YXIgYj1mdW5jdGlvbigpe30sdz17fSxDPXt9LGo9dChcIi4vdGhlbmFibGVzXCIpKGksYiksRT10KFwiLi9wcm9taXNlX2FycmF5XCIpKGksYixqLHAsbiksaz10KFwiLi9jb250ZXh0XCIpKGkpLEY9ay5jcmVhdGUseD10KFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKGksayksVD0oeC5DYXB0dXJlZFRyYWNlLHQoXCIuL2ZpbmFsbHlcIikoaSxqKSksUD10KFwiLi9jYXRjaF9maWx0ZXJcIikoQyksUj10KFwiLi9ub2RlYmFja1wiKSxTPWYuZXJyb3JPYmosTz1mLnRyeUNhdGNoO3JldHVybiBpLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBQcm9taXNlXVwifSxpLnByb3RvdHlwZS5jYXVnaHQ9aS5wcm90b3R5cGVbXCJjYXRjaFwiXT1mdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoO2lmKGU+MSl7dmFyIG4scj1uZXcgQXJyYXkoZS0xKSxpPTA7Zm9yKG49MDtlLTE+bjsrK24pe3ZhciBvPWFyZ3VtZW50c1tuXTtpZighZi5pc09iamVjdChvKSlyZXR1cm4gcChcImV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBBIGNhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGUgXCIrZi5jbGFzc1N0cmluZyhvKSk7cltpKytdPW99cmV0dXJuIHIubGVuZ3RoPWksdD1hcmd1bWVudHNbbl0sdGhpcy50aGVuKHZvaWQgMCxQKHIsdCx0aGlzKSl9cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsdCl9LGkucHJvdG90eXBlLnJlZmxlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGhlbih1LHUsdm9pZCAwLHRoaXMsdm9pZCAwKX0saS5wcm90b3R5cGUudGhlbj1mdW5jdGlvbih0LGUpe2lmKHgud2FybmluZ3MoKSYmYXJndW1lbnRzLmxlbmd0aD4wJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXt2YXIgbj1cIi50aGVuKCkgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBidXQgd2FzIHBhc3NlZDogXCIrZi5jbGFzc1N0cmluZyh0KTthcmd1bWVudHMubGVuZ3RoPjEmJihuKz1cIiwgXCIrZi5jbGFzc1N0cmluZyhlKSksdGhpcy5fd2FybihuKX1yZXR1cm4gdGhpcy5fdGhlbih0LGUsdm9pZCAwLHZvaWQgMCx2b2lkIDApfSxpLnByb3RvdHlwZS5kb25lPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fdGhlbih0LGUsdm9pZCAwLHZvaWQgMCx2b2lkIDApO24uX3NldElzRmluYWwoKX0saS5wcm90b3R5cGUuc3ByZWFkPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/cChcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIrZi5jbGFzc1N0cmluZyh0KSk6dGhpcy5hbGwoKS5fdGhlbih0LHZvaWQgMCx2b2lkIDAsdyx2b2lkIDApfSxpLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXt2YXIgdD17aXNGdWxmaWxsZWQ6ITEsaXNSZWplY3RlZDohMSxmdWxmaWxsbWVudFZhbHVlOnZvaWQgMCxyZWplY3Rpb25SZWFzb246dm9pZCAwfTtyZXR1cm4gdGhpcy5pc0Z1bGZpbGxlZCgpPyh0LmZ1bGZpbGxtZW50VmFsdWU9dGhpcy52YWx1ZSgpLHQuaXNGdWxmaWxsZWQ9ITApOnRoaXMuaXNSZWplY3RlZCgpJiYodC5yZWplY3Rpb25SZWFzb249dGhpcy5yZWFzb24oKSx0LmlzUmVqZWN0ZWQ9ITApLHR9LGkucHJvdG90eXBlLmFsbD1mdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjAmJnRoaXMuX3dhcm4oXCIuYWxsKCkgd2FzIHBhc3NlZCBhcmd1bWVudHMgYnV0IGl0IGRvZXMgbm90IHRha2UgYW55XCIpLG5ldyBFKHRoaXMpLnByb21pc2UoKX0saS5wcm90b3R5cGUuZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2F1Z2h0KGYub3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sdCl9LGkuZ2V0TmV3TGlicmFyeUNvcHk9ZS5leHBvcnRzLGkuaXM9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBpfSxpLmZyb21Ob2RlPWkuZnJvbUNhbGxiYWNrPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBpKGIpO2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xPyEhT2JqZWN0KGFyZ3VtZW50c1sxXSkubXVsdGlBcmdzOiExLHI9Tyh0KShSKGUsbikpO3JldHVybiByPT09UyYmZS5fcmVqZWN0Q2FsbGJhY2soci5lLCEwKSxlLl9pc0ZhdGVTZWFsZWQoKXx8ZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCksZX0saS5hbGw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBFKHQpLnByb21pc2UoKX0saS5jYXN0PWZ1bmN0aW9uKHQpe3ZhciBlPWoodCk7cmV0dXJuIGUgaW5zdGFuY2VvZiBpfHwoZT1uZXcgaShiKSxlLl9jYXB0dXJlU3RhY2tUcmFjZSgpLGUuX3NldEZ1bGZpbGxlZCgpLGUuX3JlamVjdGlvbkhhbmRsZXIwPXQpLGV9LGkucmVzb2x2ZT1pLmZ1bGZpbGxlZD1pLmNhc3QsaS5yZWplY3Q9aS5yZWplY3RlZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgaShiKTtyZXR1cm4gZS5fY2FwdHVyZVN0YWNrVHJhY2UoKSxlLl9yZWplY3RDYWxsYmFjayh0LCEwKSxlfSxpLnNldFNjaGVkdWxlcj1mdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBtKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIitmLmNsYXNzU3RyaW5nKHQpKTtyZXR1cm4gdi5zZXRTY2hlZHVsZXIodCl9LGkucHJvdG90eXBlLl90aGVuPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIHM9dm9pZCAwIT09byxhPXM/bzpuZXcgaShiKSxsPXRoaXMuX3RhcmdldCgpLHU9bC5fYml0RmllbGQ7c3x8KGEuX3Byb3BhZ2F0ZUZyb20odGhpcywzKSxhLl9jYXB0dXJlU3RhY2tUcmFjZSgpLHZvaWQgMD09PXImJjAhPT0oMjA5NzE1MiZ0aGlzLl9iaXRGaWVsZCkmJihyPTAhPT0oNTAzOTcxODQmdSk/dGhpcy5fYm91bmRWYWx1ZSgpOmw9PT10aGlzP3ZvaWQgMDp0aGlzLl9ib3VuZFRvKSx0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2hhaW5lZFwiLHRoaXMsYSkpO3ZhciBwPWMoKTtpZigwIT09KDUwMzk3MTg0JnUpKXt2YXIgaCxfLGQ9bC5fc2V0dGxlUHJvbWlzZUN0eDswIT09KDMzNTU0NDMyJnUpPyhfPWwuX3JlamVjdGlvbkhhbmRsZXIwLGg9dCk6MCE9PSgxNjc3NzIxNiZ1KT8oXz1sLl9mdWxmaWxsbWVudEhhbmRsZXIwLGg9ZSxsLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCkpOihkPWwuX3NldHRsZVByb21pc2VMYXRlQ2FuY2VsbGF0aW9uT2JzZXJ2ZXIsXz1uZXcgZyhcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpLGwuX2F0dGFjaEV4dHJhVHJhY2UoXyksaD1lKSx2Lmludm9rZShkLGwse2hhbmRsZXI6bnVsbD09PXA/aDpcImZ1bmN0aW9uXCI9PXR5cGVvZiBoJiZmLmRvbWFpbkJpbmQocCxoKSxwcm9taXNlOmEscmVjZWl2ZXI6cix2YWx1ZTpffSl9ZWxzZSBsLl9hZGRDYWxsYmFja3ModCxlLGEscixwKTtyZXR1cm4gYX0saS5wcm90b3R5cGUuX2xlbmd0aD1mdW5jdGlvbigpe3JldHVybiA2NTUzNSZ0aGlzLl9iaXRGaWVsZH0saS5wcm90b3R5cGUuX2lzRmF0ZVNlYWxlZD1mdW5jdGlvbigpe3JldHVybiAwIT09KDExNzUwNjA0OCZ0aGlzLl9iaXRGaWVsZCl9LGkucHJvdG90eXBlLl9pc0ZvbGxvd2luZz1mdW5jdGlvbigpe3JldHVybiA2NzEwODg2ND09PSg2NzEwODg2NCZ0aGlzLl9iaXRGaWVsZCl9LGkucHJvdG90eXBlLl9zZXRMZW5ndGg9ZnVuY3Rpb24odCl7dGhpcy5fYml0RmllbGQ9LTY1NTM2JnRoaXMuX2JpdEZpZWxkfDY1NTM1JnR9LGkucHJvdG90eXBlLl9zZXRGdWxmaWxsZWQ9ZnVuY3Rpb24oKXt0aGlzLl9iaXRGaWVsZD0zMzU1NDQzMnx0aGlzLl9iaXRGaWVsZCx0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlRnVsZmlsbGVkXCIsdGhpcyl9LGkucHJvdG90eXBlLl9zZXRSZWplY3RlZD1mdW5jdGlvbigpe3RoaXMuX2JpdEZpZWxkPTE2Nzc3MjE2fHRoaXMuX2JpdEZpZWxkLHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VSZWplY3RlZFwiLHRoaXMpfSxpLnByb3RvdHlwZS5fc2V0Rm9sbG93aW5nPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9NjcxMDg4NjR8dGhpcy5fYml0RmllbGQsdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlc29sdmVkXCIsdGhpcyl9LGkucHJvdG90eXBlLl9zZXRJc0ZpbmFsPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9NDE5NDMwNHx0aGlzLl9iaXRGaWVsZH0saS5wcm90b3R5cGUuX2lzRmluYWw9ZnVuY3Rpb24oKXtyZXR1cm4oNDE5NDMwNCZ0aGlzLl9iaXRGaWVsZCk+MH0saS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9LTY1NTM3JnRoaXMuX2JpdEZpZWxkfSxpLnByb3RvdHlwZS5fc2V0Q2FuY2VsbGVkPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9NjU1MzZ8dGhpcy5fYml0RmllbGQsdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUNhbmNlbGxlZFwiLHRoaXMpfSxpLnByb3RvdHlwZS5fc2V0V2lsbEJlQ2FuY2VsbGVkPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9ODM4ODYwOHx0aGlzLl9iaXRGaWVsZH0saS5wcm90b3R5cGUuX3NldEFzeW5jR3VhcmFudGVlZD1mdW5jdGlvbigpe3YuaGFzQ3VzdG9tU2NoZWR1bGVyKCl8fCh0aGlzLl9iaXRGaWVsZD0xMzQyMTc3Mjh8dGhpcy5fYml0RmllbGQpfSxpLnByb3RvdHlwZS5fcmVjZWl2ZXJBdD1mdW5jdGlvbih0KXt2YXIgZT0wPT09dD90aGlzLl9yZWNlaXZlcjA6dGhpc1s0KnQtNCszXTtyZXR1cm4gZT09PWg/dm9pZCAwOnZvaWQgMD09PWUmJnRoaXMuX2lzQm91bmQoKT90aGlzLl9ib3VuZFZhbHVlKCk6ZX0saS5wcm90b3R5cGUuX3Byb21pc2VBdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1s0KnQtNCsyXX0saS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzWzQqdC00KzBdfSxpLnByb3RvdHlwZS5fcmVqZWN0aW9uSGFuZGxlckF0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzWzQqdC00KzFdfSxpLnByb3RvdHlwZS5fYm91bmRWYWx1ZT1mdW5jdGlvbigpe30saS5wcm90b3R5cGUuX21pZ3JhdGVDYWxsYmFjazA9ZnVuY3Rpb24odCl7dmFyIGU9KHQuX2JpdEZpZWxkLHQuX2Z1bGZpbGxtZW50SGFuZGxlcjApLG49dC5fcmVqZWN0aW9uSGFuZGxlcjAscj10Ll9wcm9taXNlMCxpPXQuX3JlY2VpdmVyQXQoMCk7dm9pZCAwPT09aSYmKGk9aCksdGhpcy5fYWRkQ2FsbGJhY2tzKGUsbixyLGksbnVsbCl9LGkucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2tBdD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGUpLHI9dC5fcmVqZWN0aW9uSGFuZGxlckF0KGUpLGk9dC5fcHJvbWlzZUF0KGUpLG89dC5fcmVjZWl2ZXJBdChlKTt2b2lkIDA9PT1vJiYobz1oKSx0aGlzLl9hZGRDYWxsYmFja3MobixyLGksbyxudWxsKX0saS5wcm90b3R5cGUuX2FkZENhbGxiYWNrcz1mdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPXRoaXMuX2xlbmd0aCgpO2lmKG8+PTY1NTMxJiYobz0wLHRoaXMuX3NldExlbmd0aCgwKSksMD09PW8pdGhpcy5fcHJvbWlzZTA9bix0aGlzLl9yZWNlaXZlcjA9cixcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYodGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMD1udWxsPT09aT90OmYuZG9tYWluQmluZChpLHQpKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYodGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA9bnVsbD09PWk/ZTpmLmRvbWFpbkJpbmQoaSxlKSk7ZWxzZXt2YXIgcz00Km8tNDt0aGlzW3MrMl09bix0aGlzW3MrM109cixcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYodGhpc1tzKzBdPW51bGw9PT1pP3Q6Zi5kb21haW5CaW5kKGksdCkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJih0aGlzW3MrMV09bnVsbD09PWk/ZTpmLmRvbWFpbkJpbmQoaSxlKSl9cmV0dXJuIHRoaXMuX3NldExlbmd0aChvKzEpLG99LGkucHJvdG90eXBlLl9wcm94eT1mdW5jdGlvbih0LGUpe3RoaXMuX2FkZENhbGxiYWNrcyh2b2lkIDAsdm9pZCAwLGUsdCxudWxsKX0saS5wcm90b3R5cGUuX3Jlc29sdmVDYWxsYmFjaz1mdW5jdGlvbih0LGUpe2lmKDA9PT0oMTE3NTA2MDQ4JnRoaXMuX2JpdEZpZWxkKSl7aWYodD09PXRoaXMpcmV0dXJuIHRoaXMuX3JlamVjdENhbGxiYWNrKGwoKSwhMSk7dmFyIG49aih0LHRoaXMpO2lmKCEobiBpbnN0YW5jZW9mIGkpKXJldHVybiB0aGlzLl9mdWxmaWxsKHQpO2UmJnRoaXMuX3Byb3BhZ2F0ZUZyb20obiwyKTt2YXIgcj1uLl90YXJnZXQoKTtpZihyPT09dGhpcylyZXR1cm4gdm9pZCB0aGlzLl9yZWplY3QobCgpKTt2YXIgbz1yLl9iaXRGaWVsZDtpZigwPT09KDUwMzk3MTg0Jm8pKXt2YXIgcz10aGlzLl9sZW5ndGgoKTtzPjAmJnIuX21pZ3JhdGVDYWxsYmFjazAodGhpcyk7Zm9yKHZhciBhPTE7cz5hOysrYSlyLl9taWdyYXRlQ2FsbGJhY2tBdCh0aGlzLGEpO3RoaXMuX3NldEZvbGxvd2luZygpLHRoaXMuX3NldExlbmd0aCgwKSx0aGlzLl9zZXRGb2xsb3dlZShyKX1lbHNlIGlmKDAhPT0oMzM1NTQ0MzImbykpdGhpcy5fZnVsZmlsbChyLl92YWx1ZSgpKTtlbHNlIGlmKDAhPT0oMTY3NzcyMTYmbykpdGhpcy5fcmVqZWN0KHIuX3JlYXNvbigpKTtlbHNle3ZhciBjPW5ldyBnKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7ci5fYXR0YWNoRXh0cmFUcmFjZShjKSx0aGlzLl9yZWplY3QoYyl9fX0saS5wcm90b3R5cGUuX3JlamVjdENhbGxiYWNrPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1mLmVuc3VyZUVycm9yT2JqZWN0KHQpLGk9cj09PXQ7aWYoIWkmJiFuJiZ4Lndhcm5pbmdzKCkpe3ZhciBvPVwiYSBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgbm9uLWVycm9yOiBcIitmLmNsYXNzU3RyaW5nKHQpO3RoaXMuX3dhcm4obywhMCl9dGhpcy5fYXR0YWNoRXh0cmFUcmFjZShyLGU/aTohMSksdGhpcy5fcmVqZWN0KHQpfSxpLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21FeGVjdXRvcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMuX2NhcHR1cmVTdGFja1RyYWNlKCksdGhpcy5fcHVzaENvbnRleHQoKTt2YXIgbj0hMCxyPXRoaXMuX2V4ZWN1dGUodCxmdW5jdGlvbih0KXtlLl9yZXNvbHZlQ2FsbGJhY2sodCl9LGZ1bmN0aW9uKHQpe2UuX3JlamVjdENhbGxiYWNrKHQsbil9KTtuPSExLHRoaXMuX3BvcENvbnRleHQoKSx2b2lkIDAhPT1yJiZlLl9yZWplY3RDYWxsYmFjayhyLCEwKX0saS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcj1mdW5jdGlvbih0LGUsbixyKXt2YXIgaT1yLl9iaXRGaWVsZDtpZigwPT09KDY1NTM2JmkpKXtyLl9wdXNoQ29udGV4dCgpO3ZhciBvO2U9PT13P24mJlwibnVtYmVyXCI9PXR5cGVvZiBuLmxlbmd0aD9vPU8odCkuYXBwbHkodGhpcy5fYm91bmRWYWx1ZSgpLG4pOihvPVMsby5lPW5ldyBtKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIrZi5jbGFzc1N0cmluZyhuKSkpOm89Tyh0KS5jYWxsKGUsbik7dmFyIHM9ci5fcG9wQ29udGV4dCgpO2k9ci5fYml0RmllbGQsMD09PSg2NTUzNiZpKSYmKG89PT1DP3IuX3JlamVjdChuKTpvPT09Uz9yLl9yZWplY3RDYWxsYmFjayhvLmUsITEpOih4LmNoZWNrRm9yZ290dGVuUmV0dXJucyhvLHMsXCJcIixyLHRoaXMpLHIuX3Jlc29sdmVDYWxsYmFjayhvKSkpfX0saS5wcm90b3R5cGUuX3RhcmdldD1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzO3QuX2lzRm9sbG93aW5nKCk7KXQ9dC5fZm9sbG93ZWUoKTtyZXR1cm4gdH0saS5wcm90b3R5cGUuX2ZvbGxvd2VlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwfSxpLnByb3RvdHlwZS5fc2V0Rm9sbG93ZWU9ZnVuY3Rpb24odCl7dGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA9dH0saS5wcm90b3R5cGUuX3NldHRsZVByb21pc2U9ZnVuY3Rpb24odCxlLHIsbyl7dmFyIHM9dCBpbnN0YW5jZW9mIGksYT10aGlzLl9iaXRGaWVsZCxjPTAhPT0oMTM0MjE3NzI4JmEpOzAhPT0oNjU1MzYmYSk/KHMmJnQuX2ludm9rZUludGVybmFsT25DYW5jZWwoKSxyIGluc3RhbmNlb2YgVCYmci5pc0ZpbmFsbHlIYW5kbGVyKCk/KHIuY2FuY2VsUHJvbWlzZT10LE8oZSkuY2FsbChyLG8pPT09UyYmdC5fcmVqZWN0KFMuZSkpOmU9PT11P3QuX2Z1bGZpbGwodS5jYWxsKHIpKTpyIGluc3RhbmNlb2Ygbj9yLl9wcm9taXNlQ2FuY2VsbGVkKHQpOnN8fHQgaW5zdGFuY2VvZiBFP3QuX2NhbmNlbCgpOnIuY2FuY2VsKCkpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGU/cz8oYyYmdC5fc2V0QXN5bmNHdWFyYW50ZWVkKCksdGhpcy5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyKGUscixvLHQpKTplLmNhbGwocixvLHQpOnIgaW5zdGFuY2VvZiBuP3IuX2lzUmVzb2x2ZWQoKXx8KDAhPT0oMzM1NTQ0MzImYSk/ci5fcHJvbWlzZUZ1bGZpbGxlZChvLHQpOnIuX3Byb21pc2VSZWplY3RlZChvLHQpKTpzJiYoYyYmdC5fc2V0QXN5bmNHdWFyYW50ZWVkKCksMCE9PSgzMzU1NDQzMiZhKT90Ll9mdWxmaWxsKG8pOnQuX3JlamVjdChvKSl9LGkucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlTGF0ZUNhbmNlbGxhdGlvbk9ic2VydmVyPWZ1bmN0aW9uKHQpe3ZhciBlPXQuaGFuZGxlcixuPXQucHJvbWlzZSxyPXQucmVjZWl2ZXIsbz10LnZhbHVlO1wiZnVuY3Rpb25cIj09dHlwZW9mIGU/biBpbnN0YW5jZW9mIGk/dGhpcy5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyKGUscixvLG4pOmUuY2FsbChyLG8sbik6biBpbnN0YW5jZW9mIGkmJm4uX3JlamVjdChvKX0saS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VDdHg9ZnVuY3Rpb24odCl7dGhpcy5fc2V0dGxlUHJvbWlzZSh0LnByb21pc2UsdC5oYW5kbGVyLHQucmVjZWl2ZXIsdC52YWx1ZSl9LGkucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlMD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy5fcHJvbWlzZTAsaT10aGlzLl9yZWNlaXZlckF0KDApO3RoaXMuX3Byb21pc2UwPXZvaWQgMCx0aGlzLl9yZWNlaXZlcjA9dm9pZCAwLHRoaXMuX3NldHRsZVByb21pc2Uocix0LGksZSl9LGkucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXg9ZnVuY3Rpb24odCl7dmFyIGU9NCp0LTQ7dGhpc1tlKzJdPXRoaXNbZSszXT10aGlzW2UrMF09dGhpc1tlKzFdPXZvaWQgMH0saS5wcm90b3R5cGUuX2Z1bGZpbGw9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fYml0RmllbGQ7aWYoISgoMTE3NTA2MDQ4JmUpPj4+MTYpKXtpZih0PT09dGhpcyl7dmFyIG49bCgpO3JldHVybiB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKG4pLHRoaXMuX3JlamVjdChuKX10aGlzLl9zZXRGdWxmaWxsZWQoKSx0aGlzLl9yZWplY3Rpb25IYW5kbGVyMD10LCg2NTUzNSZlKT4wJiYoMCE9PSgxMzQyMTc3MjgmZSk/dGhpcy5fc2V0dGxlUHJvbWlzZXMoKTp2LnNldHRsZVByb21pc2VzKHRoaXMpKX19LGkucHJvdG90eXBlLl9yZWplY3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fYml0RmllbGQ7aWYoISgoMTE3NTA2MDQ4JmUpPj4+MTYpKXJldHVybiB0aGlzLl9zZXRSZWplY3RlZCgpLHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA9dCx0aGlzLl9pc0ZpbmFsKCk/di5mYXRhbEVycm9yKHQsZi5pc05vZGUpOnZvaWQoKDY1NTM1JmUpPjA/di5zZXR0bGVQcm9taXNlcyh0aGlzKTp0aGlzLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQoKSl9LGkucHJvdG90eXBlLl9mdWxmaWxsUHJvbWlzZXM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MTt0Pm47bisrKXt2YXIgcj10aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJBdChuKSxpPXRoaXMuX3Byb21pc2VBdChuKSxvPXRoaXMuX3JlY2VpdmVyQXQobik7dGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KG4pLHRoaXMuX3NldHRsZVByb21pc2UoaSxyLG8sZSl9fSxpLnByb3RvdHlwZS5fcmVqZWN0UHJvbWlzZXM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MTt0Pm47bisrKXt2YXIgcj10aGlzLl9yZWplY3Rpb25IYW5kbGVyQXQobiksaT10aGlzLl9wcm9taXNlQXQobiksbz10aGlzLl9yZWNlaXZlckF0KG4pO3RoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChuKSx0aGlzLl9zZXR0bGVQcm9taXNlKGkscixvLGUpfX0saS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fYml0RmllbGQsZT02NTUzNSZ0O2lmKGU+MCl7aWYoMCE9PSgxNjg0Mjc1MiZ0KSl7dmFyIG49dGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDt0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCxuLHQpLHRoaXMuX3JlamVjdFByb21pc2VzKGUsbil9ZWxzZXt2YXIgcj10aGlzLl9yZWplY3Rpb25IYW5kbGVyMDt0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwLHIsdCksdGhpcy5fZnVsZmlsbFByb21pc2VzKGUscil9dGhpcy5fc2V0TGVuZ3RoKDApfXRoaXMuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpfSxpLnByb3RvdHlwZS5fc2V0dGxlZFZhbHVlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fYml0RmllbGQ7cmV0dXJuIDAhPT0oMzM1NTQ0MzImdCk/dGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA6MCE9PSgxNjc3NzIxNiZ0KT90aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwOnZvaWQgMH0saS5kZWZlcj1pLnBlbmRpbmc9ZnVuY3Rpb24oKXt4LmRlcHJlY2F0ZWQoXCJQcm9taXNlLmRlZmVyXCIsXCJuZXcgUHJvbWlzZVwiKTt2YXIgdD1uZXcgaShiKTtyZXR1cm57cHJvbWlzZTp0LHJlc29sdmU6byxyZWplY3Q6c319LGYubm90RW51bWVyYWJsZVByb3AoaSxcIl9tYWtlU2VsZlJlc29sdXRpb25FcnJvclwiLGwpLHQoXCIuL21ldGhvZFwiKShpLGIsaixwLHgpLHQoXCIuL2JpbmRcIikoaSxiLGoseCksdChcIi4vY2FuY2VsXCIpKGksRSxwLHgpLHQoXCIuL2RpcmVjdF9yZXNvbHZlXCIpKGkpLHQoXCIuL3N5bmNocm9ub3VzX2luc3BlY3Rpb25cIikoaSksdChcIi4vam9pblwiKShpLEUsaixiLHYsYyksaS5Qcm9taXNlPWksaS52ZXJzaW9uPVwiMy40LjdcIix0KFwiLi9tYXAuanNcIikoaSxFLHAsaixiLHgpLHQoXCIuL2NhbGxfZ2V0LmpzXCIpKGkpLHQoXCIuL3VzaW5nLmpzXCIpKGkscCxqLEYsYix4KSx0KFwiLi90aW1lcnMuanNcIikoaSxiLHgpLHQoXCIuL2dlbmVyYXRvcnMuanNcIikoaSxwLGIsaixuLHgpLHQoXCIuL25vZGVpZnkuanNcIikoaSksdChcIi4vcHJvbWlzaWZ5LmpzXCIpKGksYiksdChcIi4vcHJvcHMuanNcIikoaSxFLGoscCksdChcIi4vcmFjZS5qc1wiKShpLGIsaixwKSx0KFwiLi9yZWR1Y2UuanNcIikoaSxFLHAsaixiLHgpLHQoXCIuL3NldHRsZS5qc1wiKShpLEUseCksdChcIi4vc29tZS5qc1wiKShpLEUscCksdChcIi4vZmlsdGVyLmpzXCIpKGksYiksdChcIi4vZWFjaC5qc1wiKShpLGIpLHQoXCIuL2FueS5qc1wiKShpKSxmLnRvRmFzdFByb3BlcnRpZXMoaSksZi50b0Zhc3RQcm9wZXJ0aWVzKGkucHJvdG90eXBlKSxhKHthOjF9KSxhKHtiOjJ9KSxhKHtjOjN9KSxhKDEpLGEoZnVuY3Rpb24oKXt9KSxhKHZvaWQgMCksYSghMSksYShuZXcgaShiKSkseC5zZXRCb3VuZHMoZC5maXJzdExpbmVFcnJvcixmLmxhc3RMaW5lRXJyb3IpLGl9fSx7XCIuL2FueS5qc1wiOjEsXCIuL2FzeW5jXCI6MixcIi4vYmluZFwiOjMsXCIuL2NhbGxfZ2V0LmpzXCI6NSxcIi4vY2FuY2VsXCI6NixcIi4vY2F0Y2hfZmlsdGVyXCI6NyxcIi4vY29udGV4dFwiOjgsXCIuL2RlYnVnZ2FiaWxpdHlcIjo5LFwiLi9kaXJlY3RfcmVzb2x2ZVwiOjEwLFwiLi9lYWNoLmpzXCI6MTEsXCIuL2Vycm9yc1wiOjEyLFwiLi9lczVcIjoxMyxcIi4vZmlsdGVyLmpzXCI6MTQsXCIuL2ZpbmFsbHlcIjoxNSxcIi4vZ2VuZXJhdG9ycy5qc1wiOjE2LFwiLi9qb2luXCI6MTcsXCIuL21hcC5qc1wiOjE4LFwiLi9tZXRob2RcIjoxOSxcIi4vbm9kZWJhY2tcIjoyMCxcIi4vbm9kZWlmeS5qc1wiOjIxLFwiLi9wcm9taXNlX2FycmF5XCI6MjMsXCIuL3Byb21pc2lmeS5qc1wiOjI0LFwiLi9wcm9wcy5qc1wiOjI1LFwiLi9yYWNlLmpzXCI6MjcsXCIuL3JlZHVjZS5qc1wiOjI4LFwiLi9zZXR0bGUuanNcIjozMCxcIi4vc29tZS5qc1wiOjMxLFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCI6MzIsXCIuL3RoZW5hYmxlc1wiOjMzLFwiLi90aW1lcnMuanNcIjozNCxcIi4vdXNpbmcuanNcIjozNSxcIi4vdXRpbFwiOjM2fV0sMjM6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsaSxvKXtmdW5jdGlvbiBzKHQpe3N3aXRjaCh0KXtjYXNlLTI6cmV0dXJuW107Y2FzZS0zOnJldHVybnt9fX1mdW5jdGlvbiBhKHQpe3ZhciByPXRoaXMuX3Byb21pc2U9bmV3IGUobik7dCBpbnN0YW5jZW9mIGUmJnIuX3Byb3BhZ2F0ZUZyb20odCwzKSxyLl9zZXRPbkNhbmNlbCh0aGlzKSx0aGlzLl92YWx1ZXM9dCx0aGlzLl9sZW5ndGg9MCx0aGlzLl90b3RhbFJlc29sdmVkPTAsdGhpcy5faW5pdCh2b2lkIDAsLTIpfXZhciBjPXQoXCIuL3V0aWxcIik7Yy5pc0FycmF5O3JldHVybiBjLmluaGVyaXRzKGEsbyksYS5wcm90b3R5cGUubGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xlbmd0aH0sYS5wcm90b3R5cGUucHJvbWlzZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9taXNlfSxhLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbiBsKHQsbil7dmFyIG89cih0aGlzLl92YWx1ZXMsdGhpcy5fcHJvbWlzZSk7aWYobyBpbnN0YW5jZW9mIGUpe289by5fdGFyZ2V0KCk7dmFyIGE9by5fYml0RmllbGQ7aWYodGhpcy5fdmFsdWVzPW8sMD09PSg1MDM5NzE4NCZhKSlyZXR1cm4gdGhpcy5fcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCksby5fdGhlbihsLHRoaXMuX3JlamVjdCx2b2lkIDAsdGhpcyxuKTtpZigwPT09KDMzNTU0NDMyJmEpKXJldHVybiAwIT09KDE2Nzc3MjE2JmEpP3RoaXMuX3JlamVjdChvLl9yZWFzb24oKSk6dGhpcy5fY2FuY2VsKCk7bz1vLl92YWx1ZSgpfWlmKG89Yy5hc0FycmF5KG8pLG51bGw9PT1vKXt2YXIgdT1pKFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiK2MuY2xhc3NTdHJpbmcobykpLnJlYXNvbigpO3JldHVybiB2b2lkIHRoaXMuX3Byb21pc2UuX3JlamVjdENhbGxiYWNrKHUsITEpfXJldHVybiAwPT09by5sZW5ndGg/dm9pZCgtNT09PW4/dGhpcy5fcmVzb2x2ZUVtcHR5QXJyYXkoKTp0aGlzLl9yZXNvbHZlKHMobikpKTp2b2lkIHRoaXMuX2l0ZXJhdGUobyl9LGEucHJvdG90eXBlLl9pdGVyYXRlPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuZ2V0QWN0dWFsTGVuZ3RoKHQubGVuZ3RoKTt0aGlzLl9sZW5ndGg9bix0aGlzLl92YWx1ZXM9dGhpcy5zaG91bGRDb3B5VmFsdWVzKCk/bmV3IEFycmF5KG4pOnRoaXMuX3ZhbHVlcztmb3IodmFyIGk9dGhpcy5fcHJvbWlzZSxvPSExLHM9bnVsbCxhPTA7bj5hOysrYSl7dmFyIGM9cih0W2FdLGkpO2MgaW5zdGFuY2VvZiBlPyhjPWMuX3RhcmdldCgpLHM9Yy5fYml0RmllbGQpOnM9bnVsbCxvP251bGwhPT1zJiZjLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpOm51bGwhPT1zPzA9PT0oNTAzOTcxODQmcyk/KGMuX3Byb3h5KHRoaXMsYSksdGhpcy5fdmFsdWVzW2FdPWMpOm89MCE9PSgzMzU1NDQzMiZzKT90aGlzLl9wcm9taXNlRnVsZmlsbGVkKGMuX3ZhbHVlKCksYSk6MCE9PSgxNjc3NzIxNiZzKT90aGlzLl9wcm9taXNlUmVqZWN0ZWQoYy5fcmVhc29uKCksYSk6dGhpcy5fcHJvbWlzZUNhbmNlbGxlZChhKTpvPXRoaXMuX3Byb21pc2VGdWxmaWxsZWQoYyxhKX1vfHxpLl9zZXRBc3luY0d1YXJhbnRlZWQoKX0sYS5wcm90b3R5cGUuX2lzUmVzb2x2ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuX3ZhbHVlc30sYS5wcm90b3R5cGUuX3Jlc29sdmU9ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWVzPW51bGwsdGhpcy5fcHJvbWlzZS5fZnVsZmlsbCh0KX0sYS5wcm90b3R5cGUuX2NhbmNlbD1mdW5jdGlvbigpeyF0aGlzLl9pc1Jlc29sdmVkKCkmJnRoaXMuX3Byb21pc2UuX2lzQ2FuY2VsbGFibGUoKSYmKHRoaXMuX3ZhbHVlcz1udWxsLHRoaXMuX3Byb21pc2UuX2NhbmNlbCgpKX0sYS5wcm90b3R5cGUuX3JlamVjdD1mdW5jdGlvbih0KXt0aGlzLl92YWx1ZXM9bnVsbCx0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayh0LCExKX0sYS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQ9ZnVuY3Rpb24odCxlKXt0aGlzLl92YWx1ZXNbZV09dDt2YXIgbj0rK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7cmV0dXJuIG4+PXRoaXMuX2xlbmd0aD8odGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpLCEwKTohMX0sYS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY2FuY2VsKCksITB9LGEucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3RvdGFsUmVzb2x2ZWQrKyx0aGlzLl9yZWplY3QodCksITB9LGEucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtpZighdGhpcy5faXNSZXNvbHZlZCgpKXt2YXIgdD10aGlzLl92YWx1ZXM7aWYodGhpcy5fY2FuY2VsKCksdCBpbnN0YW5jZW9mIGUpdC5jYW5jZWwoKTtlbHNlIGZvcih2YXIgbj0wO248dC5sZW5ndGg7KytuKXRbbl1pbnN0YW5jZW9mIGUmJnRbbl0uY2FuY2VsKCl9fSxhLnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGEucHJvdG90eXBlLmdldEFjdHVhbExlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4gdH0sYX19LHtcIi4vdXRpbFwiOjM2fV0sMjQ6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiFDLnRlc3QodCl9ZnVuY3Rpb24gaSh0KXt0cnl7cmV0dXJuIHQuX19pc1Byb21pc2lmaWVkX189PT0hMH1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24gbyh0LGUsbil7dmFyIHI9Zi5nZXREYXRhUHJvcGVydHlPckRlZmF1bHQodCxlK24sYik7cmV0dXJuIHI/aShyKTohMX1mdW5jdGlvbiBzKHQsZSxuKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrPTIpe3ZhciBpPXRbcl07aWYobi50ZXN0KGkpKWZvcih2YXIgbz1pLnJlcGxhY2UobixcIlwiKSxzPTA7czx0Lmxlbmd0aDtzKz0yKWlmKHRbc109PT1vKXRocm93IG5ldyBtKFwiQ2Fubm90IHByb21pc2lmeSBhbiBBUEkgdGhhdCBoYXMgbm9ybWFsIG1ldGhvZHMgd2l0aCAnJXMnLXN1ZmZpeFxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIi5yZXBsYWNlKFwiJXNcIixlKSl9fWZ1bmN0aW9uIGEodCxlLG4scil7Zm9yKHZhciBhPWYuaW5oZXJpdGVkRGF0YUtleXModCksYz1bXSxsPTA7bDxhLmxlbmd0aDsrK2wpe3ZhciB1PWFbbF0scD10W3VdLGg9cj09PWo/ITA6aih1LHAsdCk7XCJmdW5jdGlvblwiIT10eXBlb2YgcHx8aShwKXx8byh0LHUsZSl8fCFyKHUscCx0LGgpfHxjLnB1c2godSxwKX1yZXR1cm4gcyhjLGUsbiksY31mdW5jdGlvbiBjKHQscixpLG8scyxhKXtmdW5jdGlvbiBjKCl7dmFyIGk9cjtyPT09aCYmKGk9dGhpcyk7dmFyIG89bmV3IGUobik7by5fY2FwdHVyZVN0YWNrVHJhY2UoKTt2YXIgcz1cInN0cmluZ1wiPT10eXBlb2YgdSYmdGhpcyE9PWw/dGhpc1t1XTp0LGM9XyhvLGEpO3RyeXtzLmFwcGx5KGksZChhcmd1bWVudHMsYykpfWNhdGNoKHApe28uX3JlamVjdENhbGxiYWNrKHYocCksITAsITApfXJldHVybiBvLl9pc0ZhdGVTZWFsZWQoKXx8by5fc2V0QXN5bmNHdWFyYW50ZWVkKCksb312YXIgbD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpLHU9dDtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdSYmKHQ9byksZi5ub3RFbnVtZXJhYmxlUHJvcChjLFwiX19pc1Byb21pc2lmaWVkX19cIiwhMCksY31mdW5jdGlvbiBsKHQsZSxuLHIsaSl7Zm9yKHZhciBvPW5ldyBSZWdFeHAoRShlKStcIiRcIikscz1hKHQsZSxvLG4pLGM9MCxsPXMubGVuZ3RoO2w+YztjKz0yKXt2YXIgdT1zW2NdLHA9c1tjKzFdLF89dStlO2lmKHI9PT1rKXRbX109ayh1LGgsdSxwLGUsaSk7ZWxzZXt2YXIgZD1yKHAsZnVuY3Rpb24oKXtyZXR1cm4gayh1LGgsdSxwLGUsaSl9KTtmLm5vdEVudW1lcmFibGVQcm9wKGQsXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCEwKSx0W19dPWR9fXJldHVybiBmLnRvRmFzdFByb3BlcnRpZXModCksdH1mdW5jdGlvbiB1KHQsZSxuKXtyZXR1cm4gayh0LGUsdm9pZCAwLHQsbnVsbCxuKX12YXIgcCxoPXt9LGY9dChcIi4vdXRpbFwiKSxfPXQoXCIuL25vZGViYWNrXCIpLGQ9Zi53aXRoQXBwZW5kZWQsdj1mLm1heWJlV3JhcEFzRXJyb3IseT1mLmNhbkV2YWx1YXRlLG09dChcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcixnPVwiQXN5bmNcIixiPXtfX2lzUHJvbWlzaWZpZWRfXzohMH0sdz1bXCJhcml0eVwiLFwibGVuZ3RoXCIsXCJuYW1lXCIsXCJhcmd1bWVudHNcIixcImNhbGxlclwiLFwiY2FsbGVlXCIsXCJwcm90b3R5cGVcIixcIl9faXNQcm9taXNpZmllZF9fXCJdLEM9bmV3IFJlZ0V4cChcIl4oPzpcIit3LmpvaW4oXCJ8XCIpK1wiKSRcIiksaj1mdW5jdGlvbih0KXtyZXR1cm4gZi5pc0lkZW50aWZpZXIodCkmJlwiX1wiIT09dC5jaGFyQXQoMCkmJlwiY29uc3RydWN0b3JcIiE9PXR9LEU9ZnVuY3Rpb24odCl7cmV0dXJuIHQucmVwbGFjZSgvKFskXSkvLFwiXFxcXCRcIil9LGs9eT9wOmM7ZS5wcm9taXNpZnk9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBtKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIitmLmNsYXNzU3RyaW5nKHQpKTtpZihpKHQpKXJldHVybiB0O2U9T2JqZWN0KGUpO3ZhciBuPXZvaWQgMD09PWUuY29udGV4dD9oOmUuY29udGV4dCxvPSEhZS5tdWx0aUFyZ3Mscz11KHQsbixvKTtyZXR1cm4gZi5jb3B5RGVzY3JpcHRvcnModCxzLHIpLHN9LGUucHJvbWlzaWZ5QWxsPWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IG0oXCJ0aGUgdGFyZ2V0IG9mIHByb21pc2lmeUFsbCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTtlPU9iamVjdChlKTt2YXIgbj0hIWUubXVsdGlBcmdzLHI9ZS5zdWZmaXg7XCJzdHJpbmdcIiE9dHlwZW9mIHImJihyPWcpO3ZhciBpPWUuZmlsdGVyO1wiZnVuY3Rpb25cIiE9dHlwZW9mIGkmJihpPWopO3ZhciBvPWUucHJvbWlzaWZpZXI7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgbyYmKG89ayksIWYuaXNJZGVudGlmaWVyKHIpKXRocm93IG5ldyBSYW5nZUVycm9yKFwic3VmZml4IG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTtmb3IodmFyIHM9Zi5pbmhlcml0ZWREYXRhS2V5cyh0KSxhPTA7YTxzLmxlbmd0aDsrK2Epe3ZhciBjPXRbc1thXV07XCJjb25zdHJ1Y3RvclwiIT09c1thXSYmZi5pc0NsYXNzKGMpJiYobChjLnByb3RvdHlwZSxyLGksbyxuKSxsKGMscixpLG8sbikpfXJldHVybiBsKHQscixpLG8sbil9fX0se1wiLi9lcnJvcnNcIjoxMixcIi4vbm9kZWJhY2tcIjoyMCxcIi4vdXRpbFwiOjM2fV0sMjU6W2Z1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuLHIsaSl7ZnVuY3Rpb24gbyh0KXt2YXIgZSxuPSExO2lmKHZvaWQgMCE9PWEmJnQgaW5zdGFuY2VvZiBhKWU9cCh0KSxuPSEwO2Vsc2V7dmFyIHI9dS5rZXlzKHQpLGk9ci5sZW5ndGg7ZT1uZXcgQXJyYXkoMippKTtmb3IodmFyIG89MDtpPm87KytvKXt2YXIgcz1yW29dO2Vbb109dFtzXSxlW28raV09c319dGhpcy5jb25zdHJ1Y3RvciQoZSksdGhpcy5faXNNYXA9bix0aGlzLl9pbml0JCh2b2lkIDAsLTMpfWZ1bmN0aW9uIHModCl7dmFyIG4scz1yKHQpO3JldHVybiBsKHMpPyhuPXMgaW5zdGFuY2VvZiBlP3MuX3RoZW4oZS5wcm9wcyx2b2lkIDAsdm9pZCAwLHZvaWQgMCx2b2lkIDApOm5ldyBvKHMpLnByb21pc2UoKSxzIGluc3RhbmNlb2YgZSYmbi5fcHJvcGFnYXRlRnJvbShzLDIpLG4pOmkoXCJjYW5ub3QgYXdhaXQgcHJvcGVydGllcyBvZiBhIG5vbi1vYmplY3RcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpfXZhciBhLGM9dChcIi4vdXRpbFwiKSxsPWMuaXNPYmplY3QsdT10KFwiLi9lczVcIik7XCJmdW5jdGlvblwiPT10eXBlb2YgTWFwJiYoYT1NYXApO3ZhciBwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LHIpe3RoaXNbZV09dCx0aGlzW2Urbl09cixlKyt9dmFyIGU9MCxuPTA7cmV0dXJuIGZ1bmN0aW9uKHIpe249ci5zaXplLGU9MDt2YXIgaT1uZXcgQXJyYXkoMipyLnNpemUpO3JldHVybiByLmZvckVhY2godCxpKSxpfX0oKSxoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgYSxuPXQubGVuZ3RoLzJ8MCxyPTA7bj5yOysrcil7dmFyIGk9dFtuK3JdLG89dFtyXTtlLnNldChpLG8pfXJldHVybiBlfTtjLmluaGVyaXRzKG8sbiksby5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oKXt9LG8ucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkPWZ1bmN0aW9uKHQsZSl7dGhpcy5fdmFsdWVzW2VdPXQ7dmFyIG49Kyt0aGlzLl90b3RhbFJlc29sdmVkO2lmKG4+PXRoaXMuX2xlbmd0aCl7dmFyIHI7aWYodGhpcy5faXNNYXApcj1oKHRoaXMuX3ZhbHVlcyk7ZWxzZXtyPXt9O2Zvcih2YXIgaT10aGlzLmxlbmd0aCgpLG89MCxzPXRoaXMubGVuZ3RoKCk7cz5vOysrbylyW3RoaXMuX3ZhbHVlc1tvK2ldXT10aGlzLl92YWx1ZXNbb119cmV0dXJuIHRoaXMuX3Jlc29sdmUociksITB9cmV0dXJuITF9LG8ucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sby5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoPWZ1bmN0aW9uKHQpe3JldHVybiB0Pj4xfSxlLnByb3RvdHlwZS5wcm9wcz1mdW5jdGlvbigpe3JldHVybiBzKHRoaXMpfSxlLnByb3BzPWZ1bmN0aW9uKHQpe3JldHVybiBzKHQpfX19LHtcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDI2OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0LGUsbixyLGkpe2Zvcih2YXIgbz0wO2k+bzsrK28pbltvK3JdPXRbbytlXSx0W28rZV09dm9pZCAwfWZ1bmN0aW9uIGkodCl7dGhpcy5fY2FwYWNpdHk9dCx0aGlzLl9sZW5ndGg9MCx0aGlzLl9mcm9udD0wfWkucHJvdG90eXBlLl93aWxsQmVPdmVyQ2FwYWNpdHk9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NhcGFjaXR5PHR9LGkucHJvdG90eXBlLl9wdXNoT25lPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubGVuZ3RoKCk7dGhpcy5fY2hlY2tDYXBhY2l0eShlKzEpO3ZhciBuPXRoaXMuX2Zyb250K2UmdGhpcy5fY2FwYWNpdHktMTt0aGlzW25dPXQsdGhpcy5fbGVuZ3RoPWUrMX0saS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy5sZW5ndGgoKSszO2lmKHRoaXMuX3dpbGxCZU92ZXJDYXBhY2l0eShyKSlyZXR1cm4gdGhpcy5fcHVzaE9uZSh0KSx0aGlzLl9wdXNoT25lKGUpLHZvaWQgdGhpcy5fcHVzaE9uZShuKTt2YXIgaT10aGlzLl9mcm9udCtyLTM7dGhpcy5fY2hlY2tDYXBhY2l0eShyKTt2YXIgbz10aGlzLl9jYXBhY2l0eS0xO3RoaXNbaSswJm9dPXQsdGhpc1tpKzEmb109ZSx0aGlzW2krMiZvXT1uLHRoaXMuX2xlbmd0aD1yfSxpLnByb3RvdHlwZS5zaGlmdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2Zyb250LGU9dGhpc1t0XTtyZXR1cm4gdGhpc1t0XT12b2lkIDAsdGhpcy5fZnJvbnQ9dCsxJnRoaXMuX2NhcGFjaXR5LTEsdGhpcy5fbGVuZ3RoLS0sZX0saS5wcm90b3R5cGUubGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xlbmd0aH0saS5wcm90b3R5cGUuX2NoZWNrQ2FwYWNpdHk9ZnVuY3Rpb24odCl7dGhpcy5fY2FwYWNpdHk8dCYmdGhpcy5fcmVzaXplVG8odGhpcy5fY2FwYWNpdHk8PDEpfSxpLnByb3RvdHlwZS5fcmVzaXplVG89ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fY2FwYWNpdHk7dGhpcy5fY2FwYWNpdHk9dDt2YXIgbj10aGlzLl9mcm9udCxpPXRoaXMuX2xlbmd0aCxvPW4raSZlLTE7cih0aGlzLDAsdGhpcyxlLG8pfSxlLmV4cG9ydHM9aX0se31dLDI3OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbixyLGkpe2Z1bmN0aW9uIG8odCxvKXt2YXIgYz1yKHQpO2lmKGMgaW5zdGFuY2VvZiBlKXJldHVybiBhKGMpO2lmKHQ9cy5hc0FycmF5KHQpLG51bGw9PT10KXJldHVybiBpKFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiK3MuY2xhc3NTdHJpbmcodCkpO3ZhciBsPW5ldyBlKG4pO3ZvaWQgMCE9PW8mJmwuX3Byb3BhZ2F0ZUZyb20obywzKTtmb3IodmFyIHU9bC5fZnVsZmlsbCxwPWwuX3JlamVjdCxoPTAsZj10Lmxlbmd0aDtmPmg7KytoKXt2YXIgXz10W2hdOyh2b2lkIDAhPT1ffHxoIGluIHQpJiZlLmNhc3QoXykuX3RoZW4odSxwLHZvaWQgMCxsLG51bGwpfXJldHVybiBsfXZhciBzPXQoXCIuL3V0aWxcIiksYT1mdW5jdGlvbih0KXtyZXR1cm4gdC50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBvKGUsdCl9KX07ZS5yYWNlPWZ1bmN0aW9uKHQpe3JldHVybiBvKHQsdm9pZCAwKX0sZS5wcm90b3R5cGUucmFjZT1mdW5jdGlvbigpe3JldHVybiBvKHRoaXMsdm9pZCAwKX19fSx7XCIuL3V0aWxcIjozNn1dLDI4OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbixyLGksbyxzKXtmdW5jdGlvbiBhKHQsbixyLGkpe3RoaXMuY29uc3RydWN0b3IkKHQpO3ZhciBzPWgoKTt0aGlzLl9mbj1udWxsPT09cz9uOmYuZG9tYWluQmluZChzLG4pLHZvaWQgMCE9PXImJihyPWUucmVzb2x2ZShyKSxyLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayh0aGlzKSksdGhpcy5faW5pdGlhbFZhbHVlPXIsdGhpcy5fY3VycmVudENhbmNlbGxhYmxlPW51bGwsaT09PW8/dGhpcy5fZWFjaFZhbHVlcz1BcnJheSh0aGlzLl9sZW5ndGgpOjA9PT1pP3RoaXMuX2VhY2hWYWx1ZXM9bnVsbDp0aGlzLl9lYWNoVmFsdWVzPXZvaWQgMCx0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpLHRoaXMuX2luaXQkKHZvaWQgMCwtNSl9ZnVuY3Rpb24gYyh0LGUpe3RoaXMuaXNGdWxmaWxsZWQoKT9lLl9yZXNvbHZlKHQpOmUuX3JlamVjdCh0KX1mdW5jdGlvbiBsKHQsZSxuLGkpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpcmV0dXJuIHIoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiK2YuY2xhc3NTdHJpbmcoZSkpO3ZhciBvPW5ldyBhKHQsZSxuLGkpO3JldHVybiBvLnByb21pc2UoKX1mdW5jdGlvbiB1KHQpe3RoaXMuYWNjdW09dCx0aGlzLmFycmF5Ll9nb3RBY2N1bSh0KTt2YXIgbj1pKHRoaXMudmFsdWUsdGhpcy5hcnJheS5fcHJvbWlzZSk7cmV0dXJuIG4gaW5zdGFuY2VvZiBlPyh0aGlzLmFycmF5Ll9jdXJyZW50Q2FuY2VsbGFibGU9bixuLl90aGVuKHAsdm9pZCAwLHZvaWQgMCx0aGlzLHZvaWQgMCkpOnAuY2FsbCh0aGlzLG4pfWZ1bmN0aW9uIHAodCl7dmFyIG49dGhpcy5hcnJheSxyPW4uX3Byb21pc2UsaT1fKG4uX2ZuKTtyLl9wdXNoQ29udGV4dCgpO3ZhciBvO289dm9pZCAwIT09bi5fZWFjaFZhbHVlcz9pLmNhbGwoci5fYm91bmRWYWx1ZSgpLHQsdGhpcy5pbmRleCx0aGlzLmxlbmd0aCk6aS5jYWxsKHIuX2JvdW5kVmFsdWUoKSx0aGlzLmFjY3VtLHQsdGhpcy5pbmRleCx0aGlzLmxlbmd0aCksbyBpbnN0YW5jZW9mIGUmJihuLl9jdXJyZW50Q2FuY2VsbGFibGU9byk7dmFyIGE9ci5fcG9wQ29udGV4dCgpO3JldHVybiBzLmNoZWNrRm9yZ290dGVuUmV0dXJucyhvLGEsdm9pZCAwIT09bi5fZWFjaFZhbHVlcz9cIlByb21pc2UuZWFjaFwiOlwiUHJvbWlzZS5yZWR1Y2VcIixyKSxvfXZhciBoPWUuX2dldERvbWFpbixmPXQoXCIuL3V0aWxcIiksXz1mLnRyeUNhdGNoO2YuaW5oZXJpdHMoYSxuKSxhLnByb3RvdHlwZS5fZ290QWNjdW09ZnVuY3Rpb24odCl7dm9pZCAwIT09dGhpcy5fZWFjaFZhbHVlcyYmbnVsbCE9PXRoaXMuX2VhY2hWYWx1ZXMmJnQhPT1vJiZ0aGlzLl9lYWNoVmFsdWVzLnB1c2godCl9LGEucHJvdG90eXBlLl9lYWNoQ29tcGxldGU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10aGlzLl9lYWNoVmFsdWVzJiZ0aGlzLl9lYWNoVmFsdWVzLnB1c2godCksdGhpcy5fZWFjaFZhbHVlc30sYS5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oKXt9LGEucHJvdG90eXBlLl9yZXNvbHZlRW1wdHlBcnJheT1mdW5jdGlvbigpe3RoaXMuX3Jlc29sdmUodm9pZCAwIT09dGhpcy5fZWFjaFZhbHVlcz90aGlzLl9lYWNoVmFsdWVzOnRoaXMuX2luaXRpYWxWYWx1ZSl9LGEucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sYS5wcm90b3R5cGUuX3Jlc29sdmU9ZnVuY3Rpb24odCl7dGhpcy5fcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHQpLHRoaXMuX3ZhbHVlcz1udWxsfSxhLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5faW5pdGlhbFZhbHVlP3RoaXMuX2NhbmNlbCgpOnZvaWQodGhpcy5faXNSZXNvbHZlZCgpfHwodGhpcy5fcmVzdWx0Q2FuY2VsbGVkJCgpLHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSBpbnN0YW5jZW9mIGUmJnRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZS5jYW5jZWwoKSx0aGlzLl9pbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBlJiZ0aGlzLl9pbml0aWFsVmFsdWUuY2FuY2VsKCkpKX0sYS5wcm90b3R5cGUuX2l0ZXJhdGU9ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWVzPXQ7dmFyIG4scixpPXQubGVuZ3RoO2lmKHZvaWQgMCE9PXRoaXMuX2luaXRpYWxWYWx1ZT8obj10aGlzLl9pbml0aWFsVmFsdWUscj0wKToobj1lLnJlc29sdmUodFswXSkscj0xKSx0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGU9biwhbi5pc1JlamVjdGVkKCkpZm9yKDtpPnI7KytyKXt2YXIgbz17YWNjdW06bnVsbCx2YWx1ZTp0W3JdLGluZGV4OnIsbGVuZ3RoOmksYXJyYXk6dGhpc307bj1uLl90aGVuKHUsdm9pZCAwLHZvaWQgMCxvLHZvaWQgMCl9dm9pZCAwIT09dGhpcy5fZWFjaFZhbHVlcyYmKG49bi5fdGhlbih0aGlzLl9lYWNoQ29tcGxldGUsdm9pZCAwLHZvaWQgMCx0aGlzLHZvaWQgMCkpLG4uX3RoZW4oYyxjLHZvaWQgMCxuLHRoaXMpfSxlLnByb3RvdHlwZS5yZWR1Y2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbCh0aGlzLHQsZSxudWxsKX0sZS5yZWR1Y2U9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGwodCxlLG4scil9fX0se1wiLi91dGlsXCI6MzZ9XSwyOTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByLGk9dChcIi4vdXRpbFwiKSxvPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIil9LHM9aS5nZXROYXRpdmVQcm9taXNlKCk7aWYoaS5pc05vZGUmJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBNdXRhdGlvbk9ic2VydmVyKXt2YXIgYT1nbG9iYWwuc2V0SW1tZWRpYXRlLGM9cHJvY2Vzcy5uZXh0VGljaztyPWkuaXNSZWNlbnROb2RlP2Z1bmN0aW9uKHQpe2EuY2FsbChnbG9iYWwsdCl9OmZ1bmN0aW9uKHQpe2MuY2FsbChwcm9jZXNzLHQpfX1lbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHMucmVzb2x2ZSl7dmFyIGw9cy5yZXNvbHZlKCk7cj1mdW5jdGlvbih0KXtsLnRoZW4odCl9fWVsc2Ugcj1cInVuZGVmaW5lZFwiPT10eXBlb2YgTXV0YXRpb25PYnNlcnZlcnx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93Lm5hdmlnYXRvciYmKHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZXx8d2luZG93LmNvcmRvdmEpP1widW5kZWZpbmVkXCIhPXR5cGVvZiBzZXRJbW1lZGlhdGU/ZnVuY3Rpb24odCl7c2V0SW1tZWRpYXRlKHQpfTpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2V0VGltZW91dD9mdW5jdGlvbih0KXtzZXRUaW1lb3V0KHQsMCl9Om86ZnVuY3Rpb24oKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGU9e2F0dHJpYnV0ZXM6ITB9LG49ITEscj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGk9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKXt0LmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIiksbj0hMX0pO2kub2JzZXJ2ZShyLGUpO3ZhciBvPWZ1bmN0aW9uKCl7bnx8KG49ITAsci5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpKX07cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByPW5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCl7ci5kaXNjb25uZWN0KCksbigpfSk7ci5vYnNlcnZlKHQsZSksbygpfX0oKTtlLmV4cG9ydHM9cn0se1wiLi91dGlsXCI6MzZ9XSwzMDpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scil7ZnVuY3Rpb24gaSh0KXt0aGlzLmNvbnN0cnVjdG9yJCh0KX12YXIgbz1lLlByb21pc2VJbnNwZWN0aW9uLHM9dChcIi4vdXRpbFwiKTtzLmluaGVyaXRzKGksbiksaS5wcm90b3R5cGUuX3Byb21pc2VSZXNvbHZlZD1mdW5jdGlvbih0LGUpe3RoaXMuX3ZhbHVlc1t0XT1lO3ZhciBuPSsrdGhpcy5fdG90YWxSZXNvbHZlZDtyZXR1cm4gbj49dGhpcy5fbGVuZ3RoPyh0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyksITApOiExfSxpLnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBvO3JldHVybiBuLl9iaXRGaWVsZD0zMzU1NDQzMixuLl9zZXR0bGVkVmFsdWVGaWVsZD10LHRoaXMuX3Byb21pc2VSZXNvbHZlZChlLG4pfSxpLnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IG87cmV0dXJuIG4uX2JpdEZpZWxkPTE2Nzc3MjE2LG4uX3NldHRsZWRWYWx1ZUZpZWxkPXQsdGhpcy5fcHJvbWlzZVJlc29sdmVkKGUsbil9LGUuc2V0dGxlPWZ1bmN0aW9uKHQpe3JldHVybiByLmRlcHJlY2F0ZWQoXCIuc2V0dGxlKClcIixcIi5yZWZsZWN0KClcIiksbmV3IGkodCkucHJvbWlzZSgpfSxlLnByb3RvdHlwZS5zZXR0bGU9ZnVuY3Rpb24oKXtyZXR1cm4gZS5zZXR0bGUodGhpcyl9fX0se1wiLi91dGlsXCI6MzZ9XSwzMTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scil7ZnVuY3Rpb24gaSh0KXt0aGlzLmNvbnN0cnVjdG9yJCh0KSx0aGlzLl9ob3dNYW55PTAsdGhpcy5fdW53cmFwPSExLHRoaXMuX2luaXRpYWxpemVkPSExfWZ1bmN0aW9uIG8odCxlKXtpZigoMHxlKSE9PWV8fDA+ZSlyZXR1cm4gcihcImV4cGVjdGluZyBhIHBvc2l0aXZlIGludGVnZXJcXG5cXG4gICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFxuXCIpO3ZhciBuPW5ldyBpKHQpLG89bi5wcm9taXNlKCk7cmV0dXJuIG4uc2V0SG93TWFueShlKSxuLmluaXQoKSxvfXZhciBzPXQoXCIuL3V0aWxcIiksYT10KFwiLi9lcnJvcnNcIikuUmFuZ2VFcnJvcixjPXQoXCIuL2Vycm9yc1wiKS5BZ2dyZWdhdGVFcnJvcixsPXMuaXNBcnJheSx1PXt9O3MuaW5oZXJpdHMoaSxuKSxpLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbigpe1xuaWYodGhpcy5faW5pdGlhbGl6ZWQpe2lmKDA9PT10aGlzLl9ob3dNYW55KXJldHVybiB2b2lkIHRoaXMuX3Jlc29sdmUoW10pO3RoaXMuX2luaXQkKHZvaWQgMCwtNSk7dmFyIHQ9bCh0aGlzLl92YWx1ZXMpOyF0aGlzLl9pc1Jlc29sdmVkKCkmJnQmJnRoaXMuX2hvd01hbnk+dGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkmJnRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKHRoaXMubGVuZ3RoKCkpKX19LGkucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLl9pbml0aWFsaXplZD0hMCx0aGlzLl9pbml0KCl9LGkucHJvdG90eXBlLnNldFVud3JhcD1mdW5jdGlvbigpe3RoaXMuX3Vud3JhcD0hMH0saS5wcm90b3R5cGUuaG93TWFueT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ob3dNYW55fSxpLnByb3RvdHlwZS5zZXRIb3dNYW55PWZ1bmN0aW9uKHQpe3RoaXMuX2hvd01hbnk9dH0saS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2FkZEZ1bGZpbGxlZCh0KSx0aGlzLl9mdWxmaWxsZWQoKT09PXRoaXMuaG93TWFueSgpPyh0aGlzLl92YWx1ZXMubGVuZ3RoPXRoaXMuaG93TWFueSgpLDE9PT10aGlzLmhvd01hbnkoKSYmdGhpcy5fdW53cmFwP3RoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzWzBdKTp0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyksITApOiExfSxpLnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9hZGRSZWplY3RlZCh0KSx0aGlzLl9jaGVja091dGNvbWUoKX0saS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWVzIGluc3RhbmNlb2YgZXx8bnVsbD09dGhpcy5fdmFsdWVzP3RoaXMuX2NhbmNlbCgpOih0aGlzLl9hZGRSZWplY3RlZCh1KSx0aGlzLl9jaGVja091dGNvbWUoKSl9LGkucHJvdG90eXBlLl9jaGVja091dGNvbWU9ZnVuY3Rpb24oKXtpZih0aGlzLmhvd01hbnkoKT50aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSl7Zm9yKHZhciB0PW5ldyBjLGU9dGhpcy5sZW5ndGgoKTtlPHRoaXMuX3ZhbHVlcy5sZW5ndGg7KytlKXRoaXMuX3ZhbHVlc1tlXSE9PXUmJnQucHVzaCh0aGlzLl92YWx1ZXNbZV0pO3JldHVybiB0Lmxlbmd0aD4wP3RoaXMuX3JlamVjdCh0KTp0aGlzLl9jYW5jZWwoKSwhMH1yZXR1cm4hMX0saS5wcm90b3R5cGUuX2Z1bGZpbGxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90b3RhbFJlc29sdmVkfSxpLnByb3RvdHlwZS5fcmVqZWN0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aC10aGlzLmxlbmd0aCgpfSxpLnByb3RvdHlwZS5fYWRkUmVqZWN0ZWQ9ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWVzLnB1c2godCl9LGkucHJvdG90eXBlLl9hZGRGdWxmaWxsZWQ9ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWVzW3RoaXMuX3RvdGFsUmVzb2x2ZWQrK109dH0saS5wcm90b3R5cGUuX2NhblBvc3NpYmx5RnVsZmlsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aCgpLXRoaXMuX3JlamVjdGVkKCl9LGkucHJvdG90eXBlLl9nZXRSYW5nZUVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPVwiSW5wdXQgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IFwiK3RoaXMuX2hvd01hbnkrXCIgaXRlbXMgYnV0IGNvbnRhaW5zIG9ubHkgXCIrdCtcIiBpdGVtc1wiO3JldHVybiBuZXcgYShlKX0saS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5PWZ1bmN0aW9uKCl7dGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IoMCkpfSxlLnNvbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbyh0LGUpfSxlLnByb3RvdHlwZS5zb21lPWZ1bmN0aW9uKHQpe3JldHVybiBvKHRoaXMsdCl9LGUuX1NvbWVQcm9taXNlQXJyYXk9aX19LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDMyOltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7dm9pZCAwIT09dD8odD10Ll90YXJnZXQoKSx0aGlzLl9iaXRGaWVsZD10Ll9iaXRGaWVsZCx0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZD10Ll9pc0ZhdGVTZWFsZWQoKT90Ll9zZXR0bGVkVmFsdWUoKTp2b2lkIDApOih0aGlzLl9iaXRGaWVsZD0wLHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkPXZvaWQgMCl9ZS5wcm90b3R5cGUuX3NldHRsZWRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZH07dmFyIG49ZS5wcm90b3R5cGUudmFsdWU9ZnVuY3Rpb24oKXtpZighdGhpcy5pc0Z1bGZpbGxlZCgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIG9mIGEgbm9uLWZ1bGZpbGxlZCBwcm9taXNlXFxuXFxuICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcblwiKTtyZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCl9LHI9ZS5wcm90b3R5cGUuZXJyb3I9ZS5wcm90b3R5cGUucmVhc29uPWZ1bmN0aW9uKCl7aWYoIXRoaXMuaXNSZWplY3RlZCgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IHJlamVjdGlvbiByZWFzb24gb2YgYSBub24tcmVqZWN0ZWQgcHJvbWlzZVxcblxcbiAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXG5cIik7cmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpfSxpPWUucHJvdG90eXBlLmlzRnVsZmlsbGVkPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT0oMzM1NTQ0MzImdGhpcy5fYml0RmllbGQpfSxvPWUucHJvdG90eXBlLmlzUmVqZWN0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PSgxNjc3NzIxNiZ0aGlzLl9iaXRGaWVsZCl9LHM9ZS5wcm90b3R5cGUuaXNQZW5kaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT0oNTAzOTcxODQmdGhpcy5fYml0RmllbGQpfSxhPWUucHJvdG90eXBlLmlzUmVzb2x2ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PSg1MDMzMTY0OCZ0aGlzLl9iaXRGaWVsZCl9O2UucHJvdG90eXBlLmlzQ2FuY2VsbGVkPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT0oODQ1NDE0NCZ0aGlzLl9iaXRGaWVsZCl9LHQucHJvdG90eXBlLl9faXNDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gNjU1MzY9PT0oNjU1MzYmdGhpcy5fYml0RmllbGQpfSx0LnByb3RvdHlwZS5faXNDYW5jZWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX19pc0NhbmNlbGxlZCgpfSx0LnByb3RvdHlwZS5pc0NhbmNlbGxlZD1mdW5jdGlvbigpe3JldHVybiAwIT09KDg0NTQxNDQmdGhpcy5fdGFyZ2V0KCkuX2JpdEZpZWxkKX0sdC5wcm90b3R5cGUuaXNQZW5kaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHMuY2FsbCh0aGlzLl90YXJnZXQoKSl9LHQucHJvdG90eXBlLmlzUmVqZWN0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gby5jYWxsKHRoaXMuX3RhcmdldCgpKX0sdC5wcm90b3R5cGUuaXNGdWxmaWxsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gaS5jYWxsKHRoaXMuX3RhcmdldCgpKX0sdC5wcm90b3R5cGUuaXNSZXNvbHZlZD1mdW5jdGlvbigpe3JldHVybiBhLmNhbGwodGhpcy5fdGFyZ2V0KCkpfSx0LnByb3RvdHlwZS52YWx1ZT1mdW5jdGlvbigpe3JldHVybiBuLmNhbGwodGhpcy5fdGFyZ2V0KCkpfSx0LnByb3RvdHlwZS5yZWFzb249ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl90YXJnZXQoKTtyZXR1cm4gdC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpLHIuY2FsbCh0KX0sdC5wcm90b3R5cGUuX3ZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpfSx0LnByb3RvdHlwZS5fcmVhc29uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKSx0aGlzLl9zZXR0bGVkVmFsdWUoKX0sdC5Qcm9taXNlSW5zcGVjdGlvbj1lfX0se31dLDMzOltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gcih0LHIpe2lmKHUodCkpe2lmKHQgaW5zdGFuY2VvZiBlKXJldHVybiB0O3ZhciBpPW8odCk7aWYoaT09PWwpe3ImJnIuX3B1c2hDb250ZXh0KCk7dmFyIGM9ZS5yZWplY3QoaS5lKTtyZXR1cm4gciYmci5fcG9wQ29udGV4dCgpLGN9aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgaSl7aWYocyh0KSl7dmFyIGM9bmV3IGUobik7cmV0dXJuIHQuX3RoZW4oYy5fZnVsZmlsbCxjLl9yZWplY3Qsdm9pZCAwLGMsbnVsbCksY31yZXR1cm4gYSh0LGkscil9fXJldHVybiB0fWZ1bmN0aW9uIGkodCl7cmV0dXJuIHQudGhlbn1mdW5jdGlvbiBvKHQpe3RyeXtyZXR1cm4gaSh0KX1jYXRjaChlKXtyZXR1cm4gbC5lPWUsbH19ZnVuY3Rpb24gcyh0KXt0cnl7cmV0dXJuIHAuY2FsbCh0LFwiX3Byb21pc2UwXCIpfWNhdGNoKGUpe3JldHVybiExfX1mdW5jdGlvbiBhKHQscixpKXtmdW5jdGlvbiBvKHQpe2EmJihhLl9yZXNvbHZlQ2FsbGJhY2sodCksYT1udWxsKX1mdW5jdGlvbiBzKHQpe2EmJihhLl9yZWplY3RDYWxsYmFjayh0LHAsITApLGE9bnVsbCl9dmFyIGE9bmV3IGUobiksdT1hO2kmJmkuX3B1c2hDb250ZXh0KCksYS5fY2FwdHVyZVN0YWNrVHJhY2UoKSxpJiZpLl9wb3BDb250ZXh0KCk7dmFyIHA9ITAsaD1jLnRyeUNhdGNoKHIpLmNhbGwodCxvLHMpO3JldHVybiBwPSExLGEmJmg9PT1sJiYoYS5fcmVqZWN0Q2FsbGJhY2soaC5lLCEwLCEwKSxhPW51bGwpLHV9dmFyIGM9dChcIi4vdXRpbFwiKSxsPWMuZXJyb3JPYmosdT1jLmlzT2JqZWN0LHA9e30uaGFzT3duUHJvcGVydHk7cmV0dXJuIHJ9fSx7XCIuL3V0aWxcIjozNn1dLDM0OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbixyKXtmdW5jdGlvbiBpKHQpe3RoaXMuaGFuZGxlPXR9ZnVuY3Rpb24gbyh0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKSx0fWZ1bmN0aW9uIHModCl7dGhyb3cgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKSx0fXZhciBhPXQoXCIuL3V0aWxcIiksYz1lLlRpbWVvdXRFcnJvcjtpLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKX07dmFyIGw9ZnVuY3Rpb24odCl7cmV0dXJuIHUoK3RoaXMpLnRoZW5SZXR1cm4odCl9LHU9ZS5kZWxheT1mdW5jdGlvbih0LG8pe3ZhciBzLGE7cmV0dXJuIHZvaWQgMCE9PW8/KHM9ZS5yZXNvbHZlKG8pLl90aGVuKGwsbnVsbCxudWxsLHQsdm9pZCAwKSxyLmNhbmNlbGxhdGlvbigpJiZvIGluc3RhbmNlb2YgZSYmcy5fc2V0T25DYW5jZWwobykpOihzPW5ldyBlKG4pLGE9c2V0VGltZW91dChmdW5jdGlvbigpe3MuX2Z1bGZpbGwoKX0sK3QpLHIuY2FuY2VsbGF0aW9uKCkmJnMuX3NldE9uQ2FuY2VsKG5ldyBpKGEpKSxzLl9jYXB0dXJlU3RhY2tUcmFjZSgpKSxzLl9zZXRBc3luY0d1YXJhbnRlZWQoKSxzfTtlLnByb3RvdHlwZS5kZWxheT1mdW5jdGlvbih0KXtyZXR1cm4gdSh0LHRoaXMpfTt2YXIgcD1mdW5jdGlvbih0LGUsbil7dmFyIHI7cj1cInN0cmluZ1wiIT10eXBlb2YgZT9lIGluc3RhbmNlb2YgRXJyb3I/ZTpuZXcgYyhcIm9wZXJhdGlvbiB0aW1lZCBvdXRcIik6bmV3IGMoZSksYS5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ociksdC5fYXR0YWNoRXh0cmFUcmFjZShyKSx0Ll9yZWplY3QociksbnVsbCE9biYmbi5jYW5jZWwoKX07ZS5wcm90b3R5cGUudGltZW91dD1mdW5jdGlvbih0LGUpe3Q9K3Q7dmFyIG4sYSxjPW5ldyBpKHNldFRpbWVvdXQoZnVuY3Rpb24oKXtuLmlzUGVuZGluZygpJiZwKG4sZSxhKX0sdCkpO3JldHVybiByLmNhbmNlbGxhdGlvbigpPyhhPXRoaXMudGhlbigpLG49YS5fdGhlbihvLHMsdm9pZCAwLGMsdm9pZCAwKSxuLl9zZXRPbkNhbmNlbChjKSk6bj10aGlzLl90aGVuKG8scyx2b2lkIDAsYyx2b2lkIDApLG59fX0se1wiLi91dGlsXCI6MzZ9XSwzNTpbZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4scixpLG8scyl7ZnVuY3Rpb24gYSh0KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgdH0sMCl9ZnVuY3Rpb24gYyh0KXt2YXIgZT1yKHQpO3JldHVybiBlIT09dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5faXNEaXNwb3NhYmxlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0Ll9nZXREaXNwb3NlciYmdC5faXNEaXNwb3NhYmxlKCkmJmUuX3NldERpc3Bvc2FibGUodC5fZ2V0RGlzcG9zZXIoKSksZX1mdW5jdGlvbiBsKHQsbil7ZnVuY3Rpb24gaSgpe2lmKHM+PWwpcmV0dXJuIHUuX2Z1bGZpbGwoKTt2YXIgbz1jKHRbcysrXSk7aWYobyBpbnN0YW5jZW9mIGUmJm8uX2lzRGlzcG9zYWJsZSgpKXt0cnl7bz1yKG8uX2dldERpc3Bvc2VyKCkudHJ5RGlzcG9zZShuKSx0LnByb21pc2UpfWNhdGNoKHApe3JldHVybiBhKHApfWlmKG8gaW5zdGFuY2VvZiBlKXJldHVybiBvLl90aGVuKGksYSxudWxsLG51bGwsbnVsbCl9aSgpfXZhciBzPTAsbD10Lmxlbmd0aCx1PW5ldyBlKG8pO3JldHVybiBpKCksdX1mdW5jdGlvbiB1KHQsZSxuKXt0aGlzLl9kYXRhPXQsdGhpcy5fcHJvbWlzZT1lLHRoaXMuX2NvbnRleHQ9bn1mdW5jdGlvbiBwKHQsZSxuKXt0aGlzLmNvbnN0cnVjdG9yJCh0LGUsbil9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gdS5pc0Rpc3Bvc2VyKHQpPyh0aGlzLnJlc291cmNlc1t0aGlzLmluZGV4XS5fc2V0RGlzcG9zYWJsZSh0KSx0LnByb21pc2UoKSk6dH1mdW5jdGlvbiBmKHQpe3RoaXMubGVuZ3RoPXQsdGhpcy5wcm9taXNlPW51bGwsdGhpc1t0LTFdPW51bGx9dmFyIF89dChcIi4vdXRpbFwiKSxkPXQoXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3Isdj10KFwiLi91dGlsXCIpLmluaGVyaXRzLHk9Xy5lcnJvck9iaixtPV8udHJ5Q2F0Y2gsZz17fTt1LnByb3RvdHlwZS5kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RhdGF9LHUucHJvdG90eXBlLnByb21pc2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvbWlzZX0sdS5wcm90b3R5cGUucmVzb3VyY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9taXNlKCkuaXNGdWxmaWxsZWQoKT90aGlzLnByb21pc2UoKS52YWx1ZSgpOmd9LHUucHJvdG90eXBlLnRyeURpc3Bvc2U9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZXNvdXJjZSgpLG49dGhpcy5fY29udGV4dDt2b2lkIDAhPT1uJiZuLl9wdXNoQ29udGV4dCgpO3ZhciByPWUhPT1nP3RoaXMuZG9EaXNwb3NlKGUsdCk6bnVsbDtyZXR1cm4gdm9pZCAwIT09biYmbi5fcG9wQ29udGV4dCgpLHRoaXMuX3Byb21pc2UuX3Vuc2V0RGlzcG9zYWJsZSgpLHRoaXMuX2RhdGE9bnVsbCxyfSx1LmlzRGlzcG9zZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQucmVzb3VyY2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudHJ5RGlzcG9zZX0sdihwLHUpLHAucHJvdG90eXBlLmRvRGlzcG9zZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZGF0YSgpO3JldHVybiBuLmNhbGwodCx0LGUpfSxmLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubGVuZ3RoLG49MDt0Pm47KytuKXt2YXIgcj10aGlzW25dO3IgaW5zdGFuY2VvZiBlJiZyLmNhbmNlbCgpfX0sZS51c2luZz1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg7aWYoMj50KXJldHVybiBuKFwieW91IG11c3QgcGFzcyBhdCBsZWFzdCAyIGFyZ3VtZW50cyB0byBQcm9taXNlLnVzaW5nXCIpO3ZhciBpPWFyZ3VtZW50c1t0LTFdO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpcmV0dXJuIG4oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiK18uY2xhc3NTdHJpbmcoaSkpO3ZhciBvLGE9ITA7Mj09PXQmJkFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKT8obz1hcmd1bWVudHNbMF0sdD1vLmxlbmd0aCxhPSExKToobz1hcmd1bWVudHMsdC0tKTtmb3IodmFyIGM9bmV3IGYodCkscD0wO3Q+cDsrK3Ape3ZhciBkPW9bcF07aWYodS5pc0Rpc3Bvc2VyKGQpKXt2YXIgdj1kO2Q9ZC5wcm9taXNlKCksZC5fc2V0RGlzcG9zYWJsZSh2KX1lbHNle3ZhciBnPXIoZCk7ZyBpbnN0YW5jZW9mIGUmJihkPWcuX3RoZW4oaCxudWxsLG51bGwse3Jlc291cmNlczpjLGluZGV4OnB9LHZvaWQgMCkpfWNbcF09ZH1mb3IodmFyIGI9bmV3IEFycmF5KGMubGVuZ3RoKSxwPTA7cDxiLmxlbmd0aDsrK3ApYltwXT1lLnJlc29sdmUoY1twXSkucmVmbGVjdCgpO3ZhciB3PWUuYWxsKGIpLnRoZW4oZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDsrK2Upe3ZhciBuPXRbZV07aWYobi5pc1JlamVjdGVkKCkpcmV0dXJuIHkuZT1uLmVycm9yKCkseTtpZighbi5pc0Z1bGZpbGxlZCgpKXJldHVybiB2b2lkIHcuY2FuY2VsKCk7dFtlXT1uLnZhbHVlKCl9Qy5fcHVzaENvbnRleHQoKSxpPW0oaSk7dmFyIHI9YT9pLmFwcGx5KHZvaWQgMCx0KTppKHQpLG89Qy5fcG9wQ29udGV4dCgpO3JldHVybiBzLmNoZWNrRm9yZ290dGVuUmV0dXJucyhyLG8sXCJQcm9taXNlLnVzaW5nXCIsQykscn0pLEM9dy5sYXN0bHkoZnVuY3Rpb24oKXt2YXIgdD1uZXcgZS5Qcm9taXNlSW5zcGVjdGlvbih3KTtyZXR1cm4gbChjLHQpfSk7cmV0dXJuIGMucHJvbWlzZT1DLEMuX3NldE9uQ2FuY2VsKGMpLEN9LGUucHJvdG90eXBlLl9zZXREaXNwb3NhYmxlPWZ1bmN0aW9uKHQpe3RoaXMuX2JpdEZpZWxkPTEzMTA3Mnx0aGlzLl9iaXRGaWVsZCx0aGlzLl9kaXNwb3Nlcj10fSxlLnByb3RvdHlwZS5faXNEaXNwb3NhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuKDEzMTA3MiZ0aGlzLl9iaXRGaWVsZCk+MH0sZS5wcm90b3R5cGUuX2dldERpc3Bvc2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc3Bvc2VyfSxlLnByb3RvdHlwZS5fdW5zZXREaXNwb3NhYmxlPWZ1bmN0aW9uKCl7dGhpcy5fYml0RmllbGQ9LTEzMTA3MyZ0aGlzLl9iaXRGaWVsZCx0aGlzLl9kaXNwb3Nlcj12b2lkIDB9LGUucHJvdG90eXBlLmRpc3Bvc2VyPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpcmV0dXJuIG5ldyBwKHQsdGhpcyxpKCkpO3Rocm93IG5ldyBkfX19LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDM2OltmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcigpe3RyeXt2YXIgdD1QO3JldHVybiBQPW51bGwsdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2goZSl7cmV0dXJuIFQuZT1lLFR9fWZ1bmN0aW9uIGkodCl7cmV0dXJuIFA9dCxyfWZ1bmN0aW9uIG8odCl7cmV0dXJuIG51bGw9PXR8fHQ9PT0hMHx8dD09PSExfHxcInN0cmluZ1wiPT10eXBlb2YgdHx8XCJudW1iZXJcIj09dHlwZW9mIHR9ZnVuY3Rpb24gcyh0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fHxcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXR9ZnVuY3Rpb24gYSh0KXtyZXR1cm4gbyh0KT9uZXcgRXJyb3Iodih0KSk6dH1mdW5jdGlvbiBjKHQsZSl7dmFyIG4scj10Lmxlbmd0aCxpPW5ldyBBcnJheShyKzEpO2ZvcihuPTA7cj5uOysrbilpW25dPXRbbl07cmV0dXJuIGlbbl09ZSxpfWZ1bmN0aW9uIGwodCxlLG4pe2lmKCFGLmlzRVM1KXJldHVybnt9Lmhhc093blByb3BlcnR5LmNhbGwodCxlKT90W2VdOnZvaWQgMDt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSk7cmV0dXJuIG51bGwhPXI/bnVsbD09ci5nZXQmJm51bGw9PXIuc2V0P3IudmFsdWU6bjp2b2lkIDB9ZnVuY3Rpb24gdSh0LGUsbil7aWYobyh0KSlyZXR1cm4gdDt2YXIgcj17dmFsdWU6bixjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMH07cmV0dXJuIEYuZGVmaW5lUHJvcGVydHkodCxlLHIpLHR9ZnVuY3Rpb24gcCh0KXt0aHJvdyB0fWZ1bmN0aW9uIGgodCl7dHJ5e2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpe3ZhciBlPUYubmFtZXModC5wcm90b3R5cGUpLG49Ri5pc0VTNSYmZS5sZW5ndGg+MSxyPWUubGVuZ3RoPjAmJiEoMT09PWUubGVuZ3RoJiZcImNvbnN0cnVjdG9yXCI9PT1lWzBdKSxpPUEudGVzdCh0K1wiXCIpJiZGLm5hbWVzKHQpLmxlbmd0aD4wO2lmKG58fHJ8fGkpcmV0dXJuITB9cmV0dXJuITF9Y2F0Y2gobyl7cmV0dXJuITF9fWZ1bmN0aW9uIGYodCl7ZnVuY3Rpb24gZSgpe31lLnByb3RvdHlwZT10O2Zvcih2YXIgbj04O24tLTspbmV3IGU7cmV0dXJuIHR9ZnVuY3Rpb24gXyh0KXtyZXR1cm4gRC50ZXN0KHQpfWZ1bmN0aW9uIGQodCxlLG4pe2Zvcih2YXIgcj1uZXcgQXJyYXkodCksaT0wO3Q+aTsrK2kpcltpXT1lK2krbjtyZXR1cm4gcn1mdW5jdGlvbiB2KHQpe3RyeXtyZXR1cm4gdCtcIlwifWNhdGNoKGUpe3JldHVyblwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIn19ZnVuY3Rpb24geSh0KXtyZXR1cm4gbnVsbCE9PXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZcInN0cmluZ1wiPT10eXBlb2YgdC5tZXNzYWdlJiZcInN0cmluZ1wiPT10eXBlb2YgdC5uYW1lfWZ1bmN0aW9uIG0odCl7dHJ5e3UodCxcImlzT3BlcmF0aW9uYWxcIiwhMCl9Y2F0Y2goZSl7fX1mdW5jdGlvbiBnKHQpe3JldHVybiBudWxsPT10PyExOnQgaW5zdGFuY2VvZiBFcnJvci5fX0JsdWViaXJkRXJyb3JUeXBlc19fLk9wZXJhdGlvbmFsRXJyb3J8fHQuaXNPcGVyYXRpb25hbD09PSEwfWZ1bmN0aW9uIGIodCl7cmV0dXJuIHkodCkmJkYucHJvcGVydHlJc1dyaXRhYmxlKHQsXCJzdGFja1wiKX1mdW5jdGlvbiB3KHQpe3JldHVybnt9LnRvU3RyaW5nLmNhbGwodCl9ZnVuY3Rpb24gQyh0LGUsbil7Zm9yKHZhciByPUYubmFtZXModCksaT0wO2k8ci5sZW5ndGg7KytpKXt2YXIgbz1yW2ldO2lmKG4obykpdHJ5e0YuZGVmaW5lUHJvcGVydHkoZSxvLEYuZ2V0RGVzY3JpcHRvcih0LG8pKX1jYXRjaChzKXt9fX1mdW5jdGlvbiBqKHQpe3JldHVybiBOP3Byb2Nlc3MuZW52W3RdOnZvaWQgMH1mdW5jdGlvbiBFKCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZSl0cnl7dmFyIHQ9bmV3IFByb21pc2UoZnVuY3Rpb24oKXt9KTtpZihcIltvYmplY3QgUHJvbWlzZV1cIj09PXt9LnRvU3RyaW5nLmNhbGwodCkpcmV0dXJuIFByb21pc2V9Y2F0Y2goZSl7fX1mdW5jdGlvbiBrKHQsZSl7cmV0dXJuIHQuYmluZChlKX12YXIgRj10KFwiLi9lczVcIikseD1cInVuZGVmaW5lZFwiPT10eXBlb2YgbmF2aWdhdG9yLFQ9e2U6e319LFAsUj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnZvaWQgMCE9PXRoaXM/dGhpczpudWxsLFM9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10LHRoaXMuY29uc3RydWN0b3IkPWU7Zm9yKHZhciBuIGluIGUucHJvdG90eXBlKXIuY2FsbChlLnByb3RvdHlwZSxuKSYmXCIkXCIhPT1uLmNoYXJBdChuLmxlbmd0aC0xKSYmKHRoaXNbbitcIiRcIl09ZS5wcm90b3R5cGVbbl0pfXZhciByPXt9Lmhhc093blByb3BlcnR5O3JldHVybiBuLnByb3RvdHlwZT1lLnByb3RvdHlwZSx0LnByb3RvdHlwZT1uZXcgbix0LnByb3RvdHlwZX0sTz1mdW5jdGlvbigpe3ZhciB0PVtBcnJheS5wcm90b3R5cGUsT2JqZWN0LnByb3RvdHlwZSxGdW5jdGlvbi5wcm90b3R5cGVdLGU9ZnVuY3Rpb24oZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24paWYodFtuXT09PWUpcmV0dXJuITA7cmV0dXJuITF9O2lmKEYuaXNFUzUpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3JldHVybiBmdW5jdGlvbih0KXtmb3IodmFyIHI9W10saT1PYmplY3QuY3JlYXRlKG51bGwpO251bGwhPXQmJiFlKHQpOyl7dmFyIG87dHJ5e289bih0KX1jYXRjaChzKXtyZXR1cm4gcn1mb3IodmFyIGE9MDthPG8ubGVuZ3RoOysrYSl7dmFyIGM9b1thXTtpZighaVtjXSl7aVtjXT0hMDt2YXIgbD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsYyk7bnVsbCE9bCYmbnVsbD09bC5nZXQmJm51bGw9PWwuc2V0JiZyLnB1c2goYyl9fXQ9Ri5nZXRQcm90b3R5cGVPZih0KX1yZXR1cm4gcn19dmFyIHI9e30uaGFzT3duUHJvcGVydHk7cmV0dXJuIGZ1bmN0aW9uKG4pe2lmKGUobikpcmV0dXJuW107dmFyIGk9W107dDpmb3IodmFyIG8gaW4gbilpZihyLmNhbGwobixvKSlpLnB1c2gobyk7ZWxzZXtmb3IodmFyIHM9MDtzPHQubGVuZ3RoOysrcylpZihyLmNhbGwodFtzXSxvKSljb250aW51ZSB0O2kucHVzaChvKX1yZXR1cm4gaX19KCksQT0vdGhpc1xccypcXC5cXHMqXFxTK1xccyo9LyxEPS9eW2EteiRfXVthLXokXzAtOV0qJC9pLFY9ZnVuY3Rpb24oKXtyZXR1cm5cInN0YWNrXCJpbiBuZXcgRXJyb3I/ZnVuY3Rpb24odCl7cmV0dXJuIGIodCk/dDpuZXcgRXJyb3Iodih0KSl9OmZ1bmN0aW9uKHQpe2lmKGIodCkpcmV0dXJuIHQ7dHJ5e3Rocm93IG5ldyBFcnJvcih2KHQpKX1jYXRjaChlKXtyZXR1cm4gZX19fSgpLEk9ZnVuY3Rpb24odCl7cmV0dXJuIEYuaXNBcnJheSh0KT90Om51bGx9O2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcil7dmFyIEw9XCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXkuZnJvbT9mdW5jdGlvbih0KXtyZXR1cm4gQXJyYXkuZnJvbSh0KX06ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49W10scj10W1N5bWJvbC5pdGVyYXRvcl0oKTshKGU9ci5uZXh0KCkpLmRvbmU7KW4ucHVzaChlLnZhbHVlKTtyZXR1cm4gbn07ST1mdW5jdGlvbih0KXtyZXR1cm4gRi5pc0FycmF5KHQpP3Q6bnVsbCE9dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdFtTeW1ib2wuaXRlcmF0b3JdP0wodCk6bnVsbH19dmFyIEg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJlwiW29iamVjdCBwcm9jZXNzXVwiPT09dyhwcm9jZXNzKS50b0xvd2VyQ2FzZSgpLE49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzLmVudixCPXtpc0NsYXNzOmgsaXNJZGVudGlmaWVyOl8saW5oZXJpdGVkRGF0YUtleXM6TyxnZXREYXRhUHJvcGVydHlPckRlZmF1bHQ6bCx0aHJvd2VyOnAsaXNBcnJheTpGLmlzQXJyYXksYXNBcnJheTpJLG5vdEVudW1lcmFibGVQcm9wOnUsaXNQcmltaXRpdmU6byxpc09iamVjdDpzLGlzRXJyb3I6eSxjYW5FdmFsdWF0ZTp4LGVycm9yT2JqOlQsdHJ5Q2F0Y2g6aSxpbmhlcml0czpTLHdpdGhBcHBlbmRlZDpjLG1heWJlV3JhcEFzRXJyb3I6YSx0b0Zhc3RQcm9wZXJ0aWVzOmYsZmlsbGVkUmFuZ2U6ZCx0b1N0cmluZzp2LGNhbkF0dGFjaFRyYWNlOmIsZW5zdXJlRXJyb3JPYmplY3Q6VixvcmlnaW5hdGVzRnJvbVJlamVjdGlvbjpnLG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbjptLGNsYXNzU3RyaW5nOncsY29weURlc2NyaXB0b3JzOkMsaGFzRGV2VG9vbHM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNocm9tZSYmY2hyb21lJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjaHJvbWUubG9hZFRpbWVzLGlzTm9kZTpILGhhc0VudlZhcmlhYmxlczpOLGVudjpqLGdsb2JhbDpSLGdldE5hdGl2ZVByb21pc2U6RSxkb21haW5CaW5kOmt9O0IuaXNSZWNlbnROb2RlPUIuaXNOb2RlJiZmdW5jdGlvbigpe3ZhciB0PXByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7cmV0dXJuIDA9PT10WzBdJiZ0WzFdPjEwfHx0WzBdPjB9KCksQi5pc05vZGUmJkIudG9GYXN0UHJvcGVydGllcyhwcm9jZXNzKTt0cnl7dGhyb3cgbmV3IEVycm9yfWNhdGNoKFUpe0IubGFzdExpbmVFcnJvcj1VfWUuZXhwb3J0cz1CfSx7XCIuL2VzNVwiOjEzfV19LHt9LFs0XSkoNCl9KSxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZudWxsIT09d2luZG93P3dpbmRvdy5QPXdpbmRvdy5Qcm9taXNlOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZudWxsIT09c2VsZiYmKHNlbGYuUD1zZWxmLlByb21pc2UpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcHAvanMvdmVuZG9yL2JsdWViaXJkLm1pbi5qcyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBpbmRleCwgdmFsdWUpe1xuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0LWltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuc2V0SW1tZWRpYXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdGFzayAgID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAgICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL21hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5NYXA7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBtZXRhICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBhbkluc3RhbmNlICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgZWFjaCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSBnbG9iYWxbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIGlmKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSwgJ19jJyk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIGVhY2goJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTicuc3BsaXQoJywnKSxmdW5jdGlvbihLRVkpe1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKWhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgS0VZKTtcbiAgICAgICAgaWYoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKXJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoJ3NpemUnIGluIHByb3RvKWRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Muc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiwgTyk7XG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcbiAgdmFyIEM7XG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcbiAgICBpZihpc09iamVjdChDKSl7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyLCBJVEVSQVRPUil7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktbmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktbmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5cztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRrZXlzICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHJldHVybiAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKXtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZnJlZXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmZyZWV6ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9mcmVlemUuanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKXtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCBTRUFSQ0hfQkFSX1NFTEVDVE9SID0gJyNzZWFyY2gtYmFyJ1xuY29uc3QgU0VBUkNIX0RPUFBMRV9TRUxFQ1RPUiA9ICcuYy1zZWFyY2gtYmFyX19kb3BwbGUnXG5jb25zdCBQTEFZTElTVF9SRVNVTFRTX1NFTEVDVE9SID0gJyNzZWFyY2gtcmVzdWx0cyAuYy1zZWFyY2hfX3BsYXlsaXN0LXJlc3VsdHMnXG5jb25zdCBTT05HX1JFU1VMVFNfU0VMRUNUT1IgPSAnI3NlYXJjaC1yZXN1bHRzIC5jLXNlYXJjaF9fc29uZy1yZXN1bHRzJ1xuXG5jb25zdCBfc29uZ3NNYXRjaGluZyA9IGZ1bmN0aW9uKHNlYXJjaEtleSkge1xuICAgIGNvbnN0IHNlYXJjaEtleUV4cCA9IG5ldyBSZWdFeHAoc2VhcmNoS2V5LCAnaScpXG4gICAgcmV0dXJuIFNPTkdTLmZpbHRlcihzb25nID0+IHNlYXJjaEtleUV4cC50ZXN0KHNvbmcuYXJ0aXN0KSB8fCBzZWFyY2hLZXlFeHAudGVzdChzb25nLnRpdGxlKSlcbn1cblxuY29uc3QgX3BsYXlsaXN0c01hdGNoaW5nID0gZnVuY3Rpb24oc2VhcmNoS2V5KSB7XG4gICAgY29uc3Qgc2VhcmNoS2V5RXhwID0gbmV3IFJlZ0V4cChzZWFyY2hLZXksICdpJylcbiAgICByZXR1cm4gUExBWUxJU1RTLmZpbHRlcihwbGF5bGlzdCA9PiBzZWFyY2hLZXlFeHAudGVzdChwbGF5bGlzdC5uYW1lKSlcbn1cblxuY29uc3QgX2JpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBhY3RpdmVDbGFzcyA9ICdjLS1hY3RpdmUnXG4gICAgY29uc3QgJHNlYXJjaEJhciA9ICQoU0VBUkNIX0JBUl9TRUxFQ1RPUilcbiAgICBjb25zdCAkc2VhcmNoRG9wcGxlID0gJChTRUFSQ0hfRE9QUExFX1NFTEVDVE9SKVxuICAgIGNvbnN0ICRzb25nUmVzdWx0cyA9ICQoU09OR19SRVNVTFRTX1NFTEVDVE9SKVxuICAgIGNvbnN0ICRwbGF5bGlzdFJlc3VsdHMgPSAkKFBMQVlMSVNUX1JFU1VMVFNfU0VMRUNUT1IpXG5cbiAgICAkc2VhcmNoQmFyLm9uKCdpbnB1dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgJHNvbmdSZXN1bHRzLmh0bWwoJycpXG4gICAgICAgICRwbGF5bGlzdFJlc3VsdHMuaHRtbCgnJylcbiAgICAgICAgaWYgKCRzZWFyY2hCYXIudmFsKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGluZ1NvbmdzID0gX3NvbmdzTWF0Y2hpbmcoJHNlYXJjaEJhci52YWwoKSlcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdQbGF5bGlzdHMgPSBfcGxheWxpc3RzTWF0Y2hpbmcoJHNlYXJjaEJhci52YWwoKSlcblxuICAgICAgICBtYXRjaGluZ1NvbmdzLmZvckVhY2goKHNvbmcpID0+IHtcbiAgICAgICAgICAgICRzb25nUmVzdWx0cy5hcHBlbmQoVVRJTFMuc29uZ0VsZW1lbnRGb3Ioc29uZylbMF0pXG4gICAgICAgIH0pXG4gICAgICAgIG1hdGNoaW5nUGxheWxpc3RzLmZvckVhY2goKHBsYXlsaXN0KSA9PiB7XG4gICAgICAgICAgICAkcGxheWxpc3RSZXN1bHRzLmFwcGVuZChVVElMUy5wbGF5bGlzdEVsZW1lbnRGb3IocGxheWxpc3QpWzBdKVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICAkc2VhcmNoQmFyLm9uKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoJHNlYXJjaEJhci52YWwoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICRzZWFyY2hCYXIucmVtb3ZlQ2xhc3MoYWN0aXZlQ2xhc3MpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAkc2VhcmNoQmFyLmFkZENsYXNzKGFjdGl2ZUNsYXNzKVxuICAgIH0pXG5cbiAgICAkc2VhcmNoRG9wcGxlLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAkc2VhcmNoQmFyLmZvY3VzKClcbiAgICB9KVxufVxuXG5jb25zdCBTZWFyY2hVSSA9IGZ1bmN0aW9uKCkge1xuICAgIF9iaW5kRXZlbnRzKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VhcmNoVUlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcHAvanMvdWkvc2VhcmNoLmpzIiwiaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9nbG9iYWwvZXZlbnRzJ1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnLi4vZ2xvYmFsL3JlcXVlc3QnXG5pbXBvcnQgU29ja2V0IGZyb20gJy4uL2dsb2JhbC9zb2NrZXQnXG5pbXBvcnQgeyBOYXZCYXIgfSBmcm9tICcuLi9jb21wb25lbnRzL25hdi1iYXInXG5cbmNvbnN0IExPR0lOX0JVVFRPTl9TRUxFQ1RPUiA9ICcuanMtbG9naW4tYnV0dG9uJ1xuY29uc3QgTE9HSU5fRk9STV9TRUxFQ1RPUiA9ICcuanMtbG9naW4tZm9ybSdcblxuY29uc3QgX3JlZGlyZWN0VG9BcHAgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBoaWRkZW5DbGFzcyA9ICd1LWhpZGRlbidcbiAgICBjb25zdCAkbG9naW5QYWdlID0gJCgnI2xvZ2luLXBhZ2UnKVxuICAgIGNvbnN0ICRwbGF5bGlzdEFwcCA9ICQoJyNwbGF5bGlzdC1hcHAnKVxuXG4gICAgJHBsYXlsaXN0QXBwLnJlbW92ZUNsYXNzKGhpZGRlbkNsYXNzKVxuICAgICRsb2dpblBhZ2UuYWRkQ2xhc3MoaGlkZGVuQ2xhc3MpXG5cbiAgICBOYXZCYXIuc2V0VGFiQWN0aXZlKCQoJy5jLW5hdi1iYXJfX3RhYltkYXRhLXRhYj1cInBsYXlsaXN0c1wiXScpLCB0cnVlKVxufVxuXG5jb25zdCBfYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0ICRib2R5ID0gJCgnYm9keScpXG4gICAgY29uc3Qgc3VibWl0Rm9ybUhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCBsb2dpbkluZm8gPSB7XG4gICAgICAgICAgICB1c2VybmFtZTogJCgnLmpzLXVzZXJuYW1lLWlucHV0JykudmFsKCksXG4gICAgICAgICAgICBwYXNzd29yZDogJCgnLmpzLXBhc3N3b3JkLWlucHV0JykudmFsKClcbiAgICAgICAgfVxuICAgICAgICBSZXF1ZXN0LnN1Ym1pdExvZ2luKGxvZ2luSW5mbylcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICAgICAgICAgICAgICAgIFNvY2tldC5jb25uZWN0KClcbiAgICAgICAgICAgICAgICAkYm9keS50cmlnZ2VyKEV2ZW50cy5uYW1lcy5TSUdORURfSU4pXG4gICAgICAgICAgICAgICAgJGJvZHkudHJpZ2dlcihFdmVudHMubmFtZXMuUExBWUxJU1RTX1VQREFURV9ORUVERUQpXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmxvZyhlcnIpKVxuICAgIH1cblxuICAgICQoTE9HSU5fRk9STV9TRUxFQ1RPUikub24oJ3N1Ym1pdCcsIHN1Ym1pdEZvcm1IYW5kbGVyKVxuICAgICQoTE9HSU5fQlVUVE9OX1NFTEVDVE9SKS5vbignY2xpY2snLCBzdWJtaXRGb3JtSGFuZGxlcilcblxuICAgICRib2R5Lm9uKEV2ZW50cy5uYW1lcy5TSUdORURfSU4sIF9yZWRpcmVjdFRvQXBwKVxufVxuXG5jb25zdCBMb2dpblVJID0gZnVuY3Rpb24oKSB7XG4gICAgX2JpbmRFdmVudHMoKVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2dpblVJXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBwL2pzL3VpL2xvZ2luLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==